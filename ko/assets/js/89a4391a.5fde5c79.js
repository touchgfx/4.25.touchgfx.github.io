"use strict";(self.webpackChunktouchgfx_documentation=self.webpackChunktouchgfx_documentation||[]).push([[56311],{49613:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>f});var a=n(59496);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},d="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=c(n),u=r,f=d["".concat(s,".").concat(u)]||d[u]||h[u]||i;return n?a.createElement(f,o(o({ref:t},p),{},{components:n})):a.createElement(f,o({ref:t},p))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[d]="string"==typeof e?e:r,o[1]=l;for(var c=2;c<i;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},28128:(e,t,n)=>{n.d(t,{Z:()=>i});var a=n(59496);class r extends a.Component{render(){return a.createElement("div",{className:"code-header"},a.createElement("div",null,a.createElement("h5",null,this.props.children)))}}const i=r},89639:(e,t,n)=>{n.d(t,{Z:()=>i});var a=n(59496),r=n(7029);const i=function(e){const t=e.noShadow||!1,n=e.width,i=e.height,o=(0,r.Z)(e.imageSource);return t?a.createElement("div",{className:"figure noshadow"},a.createElement("a",{href:o,target:"_blank"},a.createElement("img",{width:n,height:i,src:o})),a.createElement("p",null,e.children)):a.createElement("div",{className:"figure"},a.createElement("a",{href:o,target:"_blank"},a.createElement("img",{width:n,height:i,src:o})),a.createElement("p",null,e.children))}},48753:(e,t,n)=>{n.d(t,{Z:()=>l});var a=n(59496),r=n(96151);const i=a.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},a.createElement("path",{fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}));class o extends a.Component{render(){return a.createElement(r.Z,{color:"var(--highlight-color-further-reading)",header:"Further reading",type:"further-reading",icon:i},this.props.children)}}const l=o},96151:(e,t,n)=>{n.d(t,{Z:()=>i});var a=n(59496);class r extends a.Component{render(){const e=`highlight highlight-${this.props.type}`;return a.createElement("div",{className:e},a.createElement("div",{className:"highlight-heading"},a.createElement("h5",null,a.createElement("div",{className:"highlight-icon"},this.props.icon),this.props.header)),a.createElement("div",{className:"highlight-content"},this.props.children))}}const i=r},49018:(e,t,n)=>{n.d(t,{Z:()=>l});var a=n(59496),r=n(96151);const i=a.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},a.createElement("path",{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}));class o extends a.Component{render(){return a.createElement(r.Z,{color:"var(--highlight-color-note)",header:"Note",type:"note",icon:i},this.props.children)}}const l=o},21100:(e,t,n)=>{n.d(t,{Z:()=>l});var a=n(59496),r=n(96151);const i=a.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},a.createElement("path",{fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}));class o extends a.Component{render(){return a.createElement(r.Z,{color:"var(--highlight-color-tip)",header:"Tip",type:"tip",icon:i},this.props.children)}}const l=o},48318:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>m,contentTitle:()=>u,default:()=>T,frontMatter:()=>h,metadata:()=>f,toc:()=>g});n(59496);var a=n(49613),r=n(89639),i=n(49018),o=n(21100),l=n(28128),s=n(48753),c=n(95375);function p(){return p=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},p.apply(this,arguments)}function d(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}const h={id:"scenarios-fmc",title:"FMC Display Interface"},u=void 0,f={unversionedId:"development/touchgfx-hal-development/scenarios/scenarios-fmc",id:"development/touchgfx-hal-development/scenarios/scenarios-fmc",title:"FMC Display Interface",description:"This scenario describes how to configure the STM32 FMC (Flexible Memory Controller) and TouchGFX Generator when using a display with a FMC parallel interface and GRAM.",source:"@site/i18n/ko/docusaurus-plugin-content-docs/current/development/touchgfx-hal-development/scenarios/scenarios-fmc.mdx",sourceDirName:"development/touchgfx-hal-development/scenarios",slug:"/development/touchgfx-hal-development/scenarios/scenarios-fmc",permalink:"/4.25/ko/docs/development/touchgfx-hal-development/scenarios/scenarios-fmc",draft:!1,tags:[],version:"current",frontMatter:{id:"scenarios-fmc",title:"FMC Display Interface"},sidebar:"docs",previous:{title:"MIPI-DSI Video Mode",permalink:"/4.25/ko/docs/development/touchgfx-hal-development/scenarios/scenarios-dsi-video-mode"},next:{title:"SPI Display Interface",permalink:"/4.25/ko/docs/development/touchgfx-hal-development/scenarios/scenarios-spi"}},m={},g=[{value:"Configuration",id:"configuration",level:2},{value:"FMC configuration",id:"fmc-configuration",level:3},{value:"TouchGFX Generator",id:"touchgfx-generator",level:3},{value:"Display Interface: Parallel RGB (FMC)",id:"display-interface-parallel-rgb-fmc",level:4},{value:"Display Interface: Custom",id:"display-interface-custom",level:4},{value:"DMA configuration",id:"dma-configuration",level:3},{value:"User Code",id:"user-code",level:2},{value:"Supported Framebuffer Strategies",id:"supported-framebuffer-strategies",level:2},{value:"Single",id:"single",level:3},{value:"Reference implementation",id:"reference-implementation",level:4},{value:"Double",id:"double",level:3},{value:"Reference implementation",id:"reference-implementation-1",level:4},{value:"Partial - GRAM display",id:"partial",level:3},{value:"Reference implementation",id:"reference-implementation-2",level:4}],y={toc:g},k="wrapper";function T(e){var{components:t}=e,n=d(e,["components"]);return(0,a.kt)(k,p({},y,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"This scenario describes how to configure the STM32 FMC (Flexible Memory Controller) and ",(0,a.kt)("em",{parentName:"p"},"TouchGFX Generator")," when using a display with a FMC parallel interface and GRAM."),(0,a.kt)(i.Z,{mdxType:"Note"},"This scenario assumes that a working display driver has been developed during the Board Bringup phase. \ub4dc\ub77c\uc774\ubc84\ub294 \ud53d\uc140\uc744 \ub514\uc2a4\ud50c\ub808\uc774\uc5d0 \uc804\uc1a1\ud558\uace0 \ub514\uc2a4\ud50c\ub808\uc774\uc758 \uba54\ubaa8\ub9ac \uc791\uc131 \uc704\uce58\ub97c \uc81c\uc5b4\ud560 \uc218 \uc788\uc5b4\uc57c \ud569\ub2c8\ub2e4. \uc790\uc138\ud55c \ub0b4\uc6a9\uc740 \ub514\uc2a4\ud50c\ub808\uc774\uc758 \ub370\uc774\ud130\uc2dc\ud2b8\ub97c \ud655\uc778\ud558\uc2ed\uc2dc\uc624."),(0,a.kt)("h2",p({},{id:"configuration"}),"Configuration"),(0,a.kt)("h3",p({},{id:"fmc-configuration"}),"FMC configuration"),(0,a.kt)("p",null,"Enable the ",(0,a.kt)("em",{parentName:"p"},"FMC")," from the ",(0,a.kt)("em",{parentName:"p"},"Connectivity")," group in the STM32CubeMX category list. From here, one of the available FMC Banks must be configured to ",(0,a.kt)("em",{parentName:"p"},"LCD Interface"),". This is done by setting the ",(0,a.kt)("em",{parentName:"p"},"Memory type")," to ",(0,a.kt)("em",{parentName:"p"},"LCD Interface")," in STM32CubeMX. The number of parallel data lines used to transfer pixels to the display is also selected here, i.e., 16-bit or 8-bit parallel interface."),(0,a.kt)(r.Z,{imageSource:"/img/development/touchgfx-hal-development/scenarios/fmc-bank-configuration.png",width:"600",noShadow:!1,mdxType:"Figure"},"FMC \ubc45\ud06c \uad6c\uc131"),(0,a.kt)("p",null,"Be sure to configure the timings correctly for the display used. Verify the base address of the FMC for your MCU and the bank used to interface with the display."),(0,a.kt)("h3",p({},{id:"touchgfx-generator"}),"TouchGFX Generator"),(0,a.kt)("h4",p({},{id:"display-interface-parallel-rgb-fmc"}),"Display Interface: Parallel RGB (FMC)"),(0,a.kt)("p",null,"If using a 16-bit parallel interface, the TouchGFX Generator can generate a HAL which provide a simple API with default implementations to Read/Write data and registers to the LCD:"),(0,a.kt)(l.Z,{mdxType:"CodeHeader"},"TouchGFXGeneratedHAL.cpp"),(0,a.kt)("pre",null,(0,a.kt)("code",p({parentName:"pre"},{className:"language-cpp"}),"...\n    /**\n     * @brief  Initialize the LCD IO.\n     * @param  None\n     * @retval None\n     */\n    __weak void LCD_IO_Init(void)\n    {\n        // Already Done by MX_FMC_Init()\n    }\n\n    /**\n     * @brief  Writes data on LCD data register.\n     * @param  Data: Data to be written\n     * @retval None\n     */\n    __weak void LCD_IO_WriteData(uint16_t RegValue)\n    {\n        /* Write 16-bits Reg */\n        FMC_BANK1_WriteData(RegValue);\n    }\n...\n")),(0,a.kt)("p",null,"See file ",(0,a.kt)("inlineCode",{parentName:"p"},"TouchGFXGeneratedHAL.cpp")," for the full generated code. These functions are defined as ",(0,a.kt)("inlineCode",{parentName:"p"},"__weak")," so that developers can override them in their own HAL implementation if needed."),(0,a.kt)("p",null,"If a FMC bank is correctly configured, it can be selected in the TouchGFX Generator:"),(0,a.kt)(r.Z,{imageSource:"/img/development/touchgfx-hal-development/scenarios/fmc-interface-selection.png",width:"400",noShadow:!1,mdxType:"Figure"},"Display Interface - Parallel RGB (FMC)"),(0,a.kt)("h4",p({},{id:"display-interface-custom"}),"Display Interface: Custom"),(0,a.kt)("p",null,"If using a 8-bit FMC interface (or another serial interface such as SPI or DSI Command mode), the ",(0,a.kt)("em",{parentName:"p"},"Custom")," Display Interface must be selected in the TouchGFX Generator. This means a full HAL cannot be automatically generated, so the developer must implement functionality to configure and transfer pixels from the framebuffer memory to the display manually. All necessary handles to accomplish this are generated by the TouchGFX Generator. Below shows how to select ",(0,a.kt)("em",{parentName:"p"},"Custom"),"."),(0,a.kt)(r.Z,{imageSource:"/img/development/touchgfx-hal-development/scenarios/custom-interface.png",width:"400",noShadow:!1,mdxType:"Figure"},"Display Interface - Custom"),(0,a.kt)(o.Z,{mdxType:"Tip"},"For displays connected through 8-bit FMC, SPI, or DSI Command mode a custom display interface must be selected"),(0,a.kt)("h3",p({},{id:"dma-configuration"}),"DMA configuration"),(0,a.kt)("p",null,"To minimize CPU load, a DMA channel can be configured to transfer pixel data from the framebuffer to the FMC. If using a 16-bit parallel interface, the generated LCD API can be overridden to do DMA transfers instead. Alternatively, the API can be extended in ",(0,a.kt)("inlineCode",{parentName:"p"},"TouchGFXHAL.cpp")," to include a DMA transfer functions. Below is an example of a GPDMA channel configuration for the FMC:"),(0,a.kt)(r.Z,{imageSource:"/img/development/touchgfx-hal-development/scenarios/gpdma-configuration.png",width:"400",noShadow:!1,mdxType:"Figure"},"DMA configuration"),(0,a.kt)("p",null,"The ",(0,a.kt)("em",{parentName:"p"},"Request")," is set to ",(0,a.kt)("em",{parentName:"p"},"Software")," since we need to program the requests in the HAL layer to transfer the framebuffer to the display. We enable ",(0,a.kt)("em",{parentName:"p"},"Source Address Increment")," to move the framebuffer pointer and disable ",(0,a.kt)("em",{parentName:"p"},"Destination Address Increment")," to always write to the FMC Bank memory address."),(0,a.kt)("h2",p({},{id:"user-code"}),"User Code"),(0,a.kt)("p",null,"Generally, for displays with embedded GRAM, the implementation of the generated TouchGFX HAL handles in ",(0,a.kt)("inlineCode",{parentName:"p"},"TouchGFXHAL.cpp")," should perform the following steps to transfer pixels to the display and synchronize the display with the TouchGFX Engine:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},'Wait for "VSYNC" (sometimes called Tearing Effect (TE) signal) to signal the TouchGFX Engine.'),(0,a.kt)("li",{parentName:"ol"},'Based on the area of the framebuffer to be redrawn, move the "display cursor" and "active window" (the region of the display being updated) to a place in GRAM that matches this area.'),(0,a.kt)("li",{parentName:"ol"},"GRAM\uc5d0 \uc785\ub825\ub418\ub294 \ud53d\uc140 \ub370\uc774\ud130\ub97c \uae30\ub85d\ud560 \uc900\ube44\ub97c \ud569\ub2c8\ub2e4. Depending on the framebuffer strategy and display interface used, this could be swapping framebuffer pointers, signaling TouchGFX Engine, or waiting for previous transfers to complete."),(0,a.kt)("li",{parentName:"ol"},"\ud53d\uc140 \ub370\uc774\ud130\ub97c \uc804\uc1a1\ud569\ub2c8\ub2e4.")),(0,a.kt)("p",null,"Depending on the display used and the framebuffer strategy, the implementation of the above steps will vary. The following sections describe how to implement these steps when using a GRAM display with FMC parallel interface."),(0,a.kt)("h2",p({},{id:"supported-framebuffer-strategies"}),"Supported Framebuffer Strategies"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Single"),(0,a.kt)("li",{parentName:"ul"},"Double"),(0,a.kt)("li",{parentName:"ul"},"Partial - GRAM display")),(0,a.kt)(s.Z,{mdxType:"FurtherReading"},"See article ",(0,a.kt)(c.Z,{to:"../../../basic-concepts/framebuffer#framebuffer-strategies",mdxType:"Link"},"Framebuffer Strategies")," for a general introduction to framebuffer strategies in TouchGFX."),(0,a.kt)("h3",p({},{id:"single"}),"Single"),(0,a.kt)("p",null,"Transferring pixel data to the display using FMC parallel interface often provides a very high bandwidth. Because of this, many applications may update the framebuffer in a ",(0,a.kt)("em",{parentName:"p"},"naive")," fashion, meaning that rendering of the next frame starts after the previous frame has been transferred to the display. A more optimal approach is to transfer the previous frame in smaller chunks, and signaling to the TouchGFX Engine to start rendering of the next frame in the framebuffer area that has been transferred so far. This emulates the concept of following the ",(0,a.kt)("em",{parentName:"p"},"scanline")," from LTDC driven displays, only here we follow the ",(0,a.kt)("em",{parentName:"p"},"transferline"),"."),(0,a.kt)("p",null,"To enable optimal display transfer and rendering, the TouchGFX Engine must be set to use the correct framebuffer strategy and a delay function must be provided:"),(0,a.kt)(l.Z,{mdxType:"CodeHeader"},"TouchGFXHAL.cpp"),(0,a.kt)("pre",null,(0,a.kt)("code",p({parentName:"pre"},{className:"language-cpp",metastring:"{5-6}","{5-6}":!0}),"void TouchGFXHAL::initialize()\n{\n    // Other initialization code\n\n    registerTaskDelayFunction(&OSWrappers::taskDelay);\n    setFrameRefreshStrategy(REFRESH_STRATEGY_OPTIM_SINGLE_BUFFER_TFT_CTRL);\n\n    TouchGFXGeneratedHAL::initialize();\n}\n")),(0,a.kt)("p",null,"To initiate a display transfer, an external interrupt generated by the displays TE signal is used to signal the TouchGFX Engine to start rendering the next frame and start transferring the previously rendered frame to the display. Typically, the TE signal is a pulse that signals the display scanline has left the active area on the Rising edge and enters again on the Falling edge. If the display transfer bandwidth is larger than the bandwidth the display scans pixels (which is often for case for FMC), we can safely start a transfer on the Rising edge of the TE signal without risking tearing. This is the case in the code below:"),(0,a.kt)(l.Z,{mdxType:"CodeHeader"},"TouchGFXHAL.cpp"),(0,a.kt)("pre",null,(0,a.kt)("code",p({parentName:"pre"},{className:"language-cpp",metastring:"{6,16}","{6,16}":!0}),"void HAL_GPIO_EXTI_Rising_Callback(uint16_t GPIO_Pin)\n{\n    if (GPIO_Pin == LCD_TE_Pin)\n    {\n        // VSync has occurred, increment TouchGFX engine vsync counter\n        HAL::getInstance()->vSync();\n        // VSync has occurred, signal TouchGFX engine\n        OSWrappers::signalVSync();\n        GPIO::set(GPIO::VSYNC_FREQ);\n\n        if (refreshRequested)\n        {\n            refreshRequested = false;\n            nextSendToDisplayLine = refreshMinLine;\n            maxSendToDisplayLine = refreshMaxLine;\n            sendNextFrameBufferBlockToDisplay();\n        }\n    }\n}\n")),(0,a.kt)(i.Z,{mdxType:"Note"},"If having a faster display transfer bandwidth than the display scanline, transfers can safely be initiated on the Rising edge of the TE signal with no risk of tearing."),(0,a.kt)("p",null,"In the code above, the helper variables ",(0,a.kt)("inlineCode",{parentName:"p"},"nextSendToDisplayLine")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"maxSendToDisplayLine")," are defining the region of the previous frame to be transferred to the display. The values of these variables are updated by the TouchGFX Engine in ",(0,a.kt)("inlineCode",{parentName:"p"},"TouchGFXHAL::flushFrameBuffer"),", which is called whenever a part of the framebuffer has been updated. The framebuffer is also marked ",(0,a.kt)("em",{parentName:"p"},"dirty"),", to signal that we need to transfer data on the next TE signal."),(0,a.kt)(l.Z,{mdxType:"CodeHeader"},"TouchGFXHAL.cpp"),(0,a.kt)("pre",null,(0,a.kt)("code",p({parentName:"pre"},{className:"language-cpp",metastring:"{19-20,22}","{19-20,22}":!0}),"void TouchGFXHAL::flushFrameBuffer(const touchgfx::Rect& rect)\n{\n    // Calling parent implementation of flushFrameBuffer(const touchgfx::Rect& rect).\n    TouchGFXGeneratedHAL::flushFrameBuffer(rect);\n\n    // In the below code, the refreshMinLine and refreshMaxLine variables are updated to span the\n    // smallest possible range, which covers all changes to the framebuffer.\n    int rectMin = rect.y;\n    int rectMax = rect.bottom();\n    refreshMinLine = MIN(rectMin, refreshMinLine);\n    refreshMaxLine = MAX(rectMax, refreshMaxLine);\n\n    refreshRequested = true; // Signal that the framebuffer has been updated this tick\n}\n")),(0,a.kt)("p",null,"A helper function to send chunks of framebuffer pixels to the display must be implemented using FMC functions:"),(0,a.kt)(l.Z,{mdxType:"CodeHeader"},"TouchGFXHAL.cpp"),(0,a.kt)("pre",null,(0,a.kt)("code",p({parentName:"pre"},{className:"language-cpp",metastring:"{3,9}","{3,9}":!0}),"void sendNextFrameBufferBlockToDisplay()\n{\n    maxDrawLine = nextSendToDisplayLine; // Update the area that TouchGFX framework is allow to draw to based on the progress of the transfer\n\n    const int32_t remainingLines = maxSendToDisplayLine - nextSendToDisplayLine;\n    if (remainingLines > 0)\n    {\n        // The display transfer is not done. Start transfer of the next block\n        const uint32_t sendBlockHeight = MIN(MAX_BLOCK_HEIGHT, remainingLines);\n        setDisplayWindow(0, nextSendToDisplayLine, DISPLAY_WIDTH, sendBlockHeight);\n        uint16_t* dataPtr = framebuffer + nextSendToDisplayLine * DISPLAY_WIDTH;\n        uint32_t dataSize = DISPLAY_WIDTH * sendBlockHeight * 2;\n        nextSendToDisplayLine += sendBlockHeight;\n        LCD_IO_SendDataDMA((uint8_t*)dataPtr, dataSize);\n    }\n    else\n    {\n        // The display transfer is done. Allow drawing to the entire framebuffer\n        maxDrawLine = DISPLAY_HEIGHT;\n    }\n}\n")),(0,a.kt)("p",null,"In the code above, ",(0,a.kt)("inlineCode",{parentName:"p"},"remainingLines")," is the number of lines left to transfer to the display. If there are lines left, we define ",(0,a.kt)("inlineCode",{parentName:"p"},"sendBlockHeight")," to be the number of lines being transferred. The constant ",(0,a.kt)("inlineCode",{parentName:"p"},"MAX_BLOCK_HEIGHT")," limits the size of transfers. The variable ",(0,a.kt)("inlineCode",{parentName:"p"},"maxDrawLine")," is the high watermark for the area that has been transferred, which determines the current line the TouchGFX Engine is allowed to draw to in the next frame. This value is incremented as the transfers progresses, and is set to ",(0,a.kt)("inlineCode",{parentName:"p"},"DISPLAY_HEIGHT")," when the transfer of the dirty region is complete to allow the TouchGFX Engine to complete the next frame. The TouchGFX Engine will query ",(0,a.kt)("inlineCode",{parentName:"p"},"maxDrawLine")," to know how much of the framebuffer it is allowed to update:"),(0,a.kt)(l.Z,{mdxType:"CodeHeader"},"TouchGFXHAL.cpp"),(0,a.kt)("pre",null,(0,a.kt)("code",p({parentName:"pre"},{className:"language-cpp",metastring:"{3}","{3}":!0}),"uint16_t TouchGFXHAL::getTFTCurrentLine()\n{\n    return maxDrawLine;\n}\n")),(0,a.kt)("p",null,"Once a block has been transferred, the transfer complete callback is used to initiate the next transfer:"),(0,a.kt)(l.Z,{mdxType:"CodeHeader"},"TouchGFXHAL.cpp"),(0,a.kt)("pre",null,(0,a.kt)("code",p({parentName:"pre"},{className:"language-cpp",metastring:"{5}","{5}":!0}),"static void DMA_TxCpltCallback(DMA_HandleTypeDef* hdma)\n{\n    if (hdma == DISPLAY_DMA)\n    {\n        sendNextFrameBufferBlockToDisplay();\n    }\n}\n")),(0,a.kt)("p",null,"This is repeated until all of the dirty area of the framebuffer has been transferred to the display."),(0,a.kt)("p",null,"The above described cycles repeats when the next TE signal is received."),(0,a.kt)("h4",p({},{id:"reference-implementation"}),"Reference implementation"),(0,a.kt)("p",null,"The ",(0,a.kt)("em",{parentName:"p"},"TouchGFX Board Setup")," NUCLEO-U575ZI + RVA35HI includes a reference implementation of single framebuffer strategy with optimized rendering/transferring using FMC:"),(0,a.kt)(r.Z,{imageSource:"/img/development/touchgfx-hal-development/scenarios/stm32u575zi-rva35hi.png",width:"200",mdxType:"Figure"}),(0,a.kt)("h3",p({},{id:"double"}),"Double"),(0,a.kt)("p",null,"Compared to single framebuffer, double buffering allows the TouchGFX Engine to freely write next frame into one framebuffer, while transferring the previous frame from the other framebuffer. This gives the most optimal render time, as it does not need to wait for the display transfers."),(0,a.kt)("p",null,"To initiate a display transfer, an external interrupt generated by the displays TE signal is used to signal the TouchGFX Engine to swap framebuffers and start rendering the next frame. The display is set to transfer the previously rendered frame to the display:"),(0,a.kt)(l.Z,{mdxType:"CodeHeader"},"TouchGFXHAL.cpp"),(0,a.kt)("pre",null,(0,a.kt)("code",p({parentName:"pre"},{className:"language-cpp",metastring:"{4,14,20}","{4,14,20}":!0}),"void LCD_SignalTearingEffectEvent(void)\n{\n    // VSync has occurred, increment TouchGFX engine vsync counter\n    HAL::getInstance()->vSync();\n    // VSync has occurred, signal TouchGFX engine\n    OSWrappers::signalVSync();\n\n    if (refreshRequested)\n    {\n        // Swap frame buffers immediately instead of waiting for the task to be scheduled in.\n        // Note: task will also swap when it wakes up, but that operation is guarded and will not have\n        // any effect if already swapped.\n\n        touchgfx::HAL::getInstance()->swapFrameBuffers();\n\n        // Set window, enable display reading to GRAM, transmit buffer using DMA\n        setWindow(0, 0, 240, 240);\n        LCD_IO_WriteReg(ST7789H2_WRITE_RAM);\n        dmaCompleted = false;\n        LCD_IO_SendDataDMA((uint8_t*)TFTframebuffer, (240 * 240 * 2));\n    }\n}\n")),(0,a.kt)("p",null,"In the above code, the resolution of the display is 240x240 pixels (16-bit RGB565 framebuffer), so the window is set to the entire display area. If bandwidth is limited, the windows can be made smaller to only encompass dirty regions. The TouchGFX HAL function ",(0,a.kt)("inlineCode",{parentName:"p"},"TouchGFXHAL::flushFrameBuffer")," may be used for this purpose."),(0,a.kt)("p",null,"TouchGFX HAL functions ",(0,a.kt)("inlineCode",{parentName:"p"},"TouchGFXHAL::beginFrame()")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"TouchGFXHAL::endFrame()")," are to request that a transfer must be done, i.e., the framebuffer is marked dirty."),(0,a.kt)(l.Z,{mdxType:"CodeHeader"},"TouchGFXHAL.cpp"),(0,a.kt)("pre",null,(0,a.kt)("code",p({parentName:"pre"},{className:"language-cpp",metastring:"{3,14}","{3,14}":!0}),"bool TouchGFXHAL::beginFrame()\n{\n    refreshRequested = false;\n\n    return TouchGFXGeneratedHAL::beginFrame();\n}\n\nvoid TouchGFXHAL::endFrame()\n{\n    TouchGFXGeneratedHAL::endFrame();\n\n    if (frameBufferUpdatedThisFrame)\n    {\n        refreshRequested = true;\n    }\n}\n")),(0,a.kt)("p",null,"The address of the framebuffer that is transferred to the display is maintained be the methods ",(0,a.kt)("inlineCode",{parentName:"p"},"TouchGFXHAL::setTFTFrameBuffer()")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"TouchGFXHAL::getTFTFrameBuffer()"),":"),(0,a.kt)(l.Z,{mdxType:"CodeHeader"},"TouchGFXHAL.cpp"),(0,a.kt)("pre",null,(0,a.kt)("code",p({parentName:"pre"},{className:"language-cpp",metastring:"{3,8}","{3,8}":!0}),"uint16_t* TouchGFXHAL::getTFTFrameBuffer() const\n{\n    return TFTframebuffer;\n}\n\nvoid TouchGFXHAL::setTFTFrameBuffer(uint16_t* address)\n{\n    TFTframebuffer = address;\n\n    TouchGFXGeneratedHAL::setTFTFrameBuffer(address);\n}\n")),(0,a.kt)("p",null,"The pointer ",(0,a.kt)("inlineCode",{parentName:"p"},"TFTframebuffer")," is used in the TE interrupt handler to set the source address of the windows being transferred to the display."),(0,a.kt)("h4",p({},{id:"reference-implementation-1"}),"Reference implementation"),(0,a.kt)("p",null,"The ",(0,a.kt)("em",{parentName:"p"},"TouchGFX Board Setup")," STM32H573-DK Int. Flash includes a reference implementation of double framebuffer strategy using FMC:"),(0,a.kt)(r.Z,{imageSource:"/img/development/touchgfx-hal-development/scenarios/stm32h573i-dk.png",width:"200",mdxType:"Figure"}),(0,a.kt)("h3",p({},{id:"partial"}),"Partial - GRAM display"),(0,a.kt)("p",null,"When choosing ",(0,a.kt)("em",{parentName:"p"},"Partial - GRAM display")," framebuffer strategy in the TocuhGFX Generator, user must configure the number of partial framebuffer blocks and their sizes. Code generated by the TouchGFX Generator will instantiate a ",(0,a.kt)("inlineCode",{parentName:"p"},"FrameBufferAllocator")," to track the states of the partial framebuffer blocks and configure the framebuffer strategy:"),(0,a.kt)(l.Z,{mdxType:"CodeHeader"},"TouchGFXGeneratedHAL.cpp"),(0,a.kt)("pre",null,(0,a.kt)("code",p({parentName:"pre"},{className:"language-cpp"}),"// Block Allocator for Partial Framebuffer strategy\nstatic ManyBlockAllocator<2048, /* block size */\n       3, /* number of blocks */\n       2 /* bytes per pixel */\n       > blockAllocator;\n\nvoid TouchGFXGeneratedHAL::initialize()\n{\n    HAL::initialize();\n    registerEventListener(*(Application::getInstance()));\n    // Partial framebuffer strategy\n    setFrameBufferAllocator(&blockAllocator);\n    setFrameRefreshStrategy(HAL::REFRESH_STRATEGY_PARTIAL_FRAMEBUFFER);\n}\n")),(0,a.kt)("p",null,"Another class ",(0,a.kt)("inlineCode",{parentName:"p"},"PartialFrameBufferManager")," handles the synchronization between the partial framebuffer blocks, the transferring of blocks, and the timing of the displays refresh rate. The generated code makes use of the API exposed by the ",(0,a.kt)("inlineCode",{parentName:"p"},"PartialFrameBufferManager")," to transfer the framebuffer blocks in the ",(0,a.kt)("inlineCode",{parentName:"p"},"TouchGFXGeneratedHAL::flushFrameBuffer"),":"),(0,a.kt)(l.Z,{mdxType:"CodeHeader"},"TouchGFXGeneratedHAL.cpp"),(0,a.kt)("pre",null,(0,a.kt)("code",p({parentName:"pre"},{className:"language-cpp",metastring:"{5}","{5}":!0}),"void TouchGFXGeneratedHAL::flushFrameBuffer(const touchgfx::Rect& rect)\n{\n    HAL::flushFrameBuffer(rect);\n    // Try transmitting a block\n    PartialFrameBufferManager::tryTransmitBlock();\n}\n")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"PartialFrameBufferManager")," uses three functions to interact with the display driver code. These must be implemented in the TouchGFX board setup:"),(0,a.kt)(l.Z,{mdxType:"CodeHeader"},"TouchGFXGeneratedHAL.cpp"),(0,a.kt)("pre",null,(0,a.kt)("code",p({parentName:"pre"},{className:"language-cpp",metastring:"{4-4,12-12,20-20}","{4-4,12-12,20-20}":!0}),"/**\n * Check if a Frame Buffer Block is beeing transmitted.\n */\nint transmitActive()\n{\n    return touchgfxDisplayDriverTransmitActive();\n}\n\n/**\n * Check if a Frame Buffer Block ending at bottom may be sent.\n */\nint shouldTransferBlock(uint16_t bottom)\n{\n    return touchgfxDisplayDriverShouldTransferBlock(bottom);\n}\n\n/**\n * Transmit a Frame Buffer Block.\n */\nvoid transmitBlock(const uint8_t* pixels, uint16_t x, uint16_t y, uint16_t w, uint16_t h)\n{\n    touchgfxDisplayDriverTransmitBlock(pixels, x, y, w, h);\n}\n")),(0,a.kt)("p",null,"The code above forwards the calls to C functions that can be implemented in a display driver in ",(0,a.kt)("inlineCode",{parentName:"p"},"TouchGFXHAL.cpp"),"."),(0,a.kt)("p",null,"In the example below, the implementations call the FMC API functions with the parameters from the ",(0,a.kt)("inlineCode",{parentName:"p"},"PartialFrameBufferManager"),":"),(0,a.kt)(l.Z,{mdxType:"CodeHeader"},"TouchGFXHAL.cpp"),(0,a.kt)("pre",null,(0,a.kt)("code",p({parentName:"pre"},{className:"language-cpp"}),'extern "C" void touchgfxDisplayDriverTransmitBlock(const uint8_t* pixels, uint16_t x, uint16_t y, uint16_t w, uint16_t h)\n{\n    isTransmittingBlock = true;\n\n    setDisplayWindow(x, y, w, h);\n\n    LCD_IO_SendDataDMA((uint8_t*)pixels, w * h * 2);\n}\n')),(0,a.kt)("p",null,"The function ",(0,a.kt)("inlineCode",{parentName:"p"},"touchgfxDisplayDriverTransmitActive")," simply returns the value of the global variable ",(0,a.kt)("inlineCode",{parentName:"p"},"isTransmittingBlock"),":"),(0,a.kt)(l.Z,{mdxType:"CodeHeader"},"TouchGFXHAL.cpp"),(0,a.kt)("pre",null,(0,a.kt)("code",p({parentName:"pre"},{className:"language-cpp"}),'extern "C" int touchgfxDisplayDriverTransmitActive()\n{\n    return isTransmittingBlock ? 1 : 0;\n}\n')),(0,a.kt)("p",null,"This value is reset in the Transfer Complete callback."),(0,a.kt)("p",null,"The function ",(0,a.kt)("inlineCode",{parentName:"p"},"touchgfxDisplayDriverShouldTransferBlock")," checks if the display is ready to receive a new block. Partial framebuffer blocks are transmitted ",(0,a.kt)("strong",{parentName:"p"},"behind")," the display scanline. For example if the displays scanline has scanned down to line 50, and the ",(0,a.kt)("em",{parentName:"p"},"bottom")," of the block to be transferred is at line 70, then the TouchGFX Engine must wait until the display has progressed below line 70 to start transferring the block. This is to avoid tearing on the display."),(0,a.kt)("p",null,"Many displays do not support this feature, so a hardware Timer can be used to estimate the line by incrementing a counter at every line. The rate at which the counter should be incremented should ideally be every Frame Duration (ms) / Display Height (pixels), for example 16.67 ms / 320 pixels = 52.1 us per line. An example implementation of ",(0,a.kt)("inlineCode",{parentName:"p"},"touchgfxDisplayDriverShouldTransferBlock")," using a ",(0,a.kt)("em",{parentName:"p"},"Line Timer")," is shown below:"),(0,a.kt)(l.Z,{mdxType:"CodeHeader"},"TouchGFXHAL.cpp"),(0,a.kt)("pre",null,(0,a.kt)("code",p({parentName:"pre"},{className:"language-cpp"}),'extern "C" int touchgfxDisplayDriverShouldTransferBlock(uint16_t bottom)\n{\n    // Only allow block transfer if the display has drawn past the bottom of the requested block (plus a margin of two lines)\n    // A timer is used to estimate how many lines have been drawn by setting the prescaler so the tick rate matches the line draw rate\n    uint16_t lastLineDrawn = LL_TIM_GetCounter(LINE_TIMER);\n    return bottom + 2 < lastLineDrawn || tearingEffectCount > 0;\n}\n')),(0,a.kt)("p",null,"In the above code, the function returns true if the bottom (plus some margin) is smaller than the display line counter or if the ",(0,a.kt)("inlineCode",{parentName:"p"},"tearingEffectCount")," is greater than 0. If ",(0,a.kt)("inlineCode",{parentName:"p"},"tearingEffectCount")," is greater than 0, this means that the display has emitted a TE signal, and is now at the same frame as the block to transfer (but behind in the display Y axis), which means the block must be transferred."),(0,a.kt)(o.Z,{mdxType:"Tip"},"The hooks `void waitUntilTransmitEnd()` and `void waitUntilCanTransferBlock(uint16_t bottom)` can be used to define what happens when display transfers are in progress or the display is not ready to receive a new block. The default behavior is `OSWrappers::taskYield()`"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"tearingEffectCount")," is incremented in the TE interrupt handler and the TouchGFX Engine is signaled to start rendering the next frame:"),(0,a.kt)(l.Z,{mdxType:"CodeHeader"},"TouchGFXHAL.cpp"),(0,a.kt)("pre",null,(0,a.kt)("code",p({parentName:"pre"},{className:"language-cpp",metastring:"{7, 10}","{7,":!0,"10}":!0}),"void HAL_GPIO_EXTI_Rising_Callback(uint16_t GPIO_Pin)\n{\n    if (GPIO_Pin == LCD_TE_Pin)\n    {\n        // Code to handle TE signal. Could be fine-tuning the display line timer frequency\n\n        tearingEffectCount++;\n\n        // VSync has occurred, increment TouchGFX engine vsync counter\n        HAL::getInstance()->vSync();\n        // VSync has occurred, signal TouchGFX engine\n        OSWrappers::signalVSync();\n\n        GPIO::set(GPIO::VSYNC_FREQ);\n        startRenderingImmediately = true;\n    }\n}\n")),(0,a.kt)("p",null,"We reset the ",(0,a.kt)("inlineCode",{parentName:"p"},"tearingEffectCount")," when we start the next frame:"),(0,a.kt)(l.Z,{mdxType:"CodeHeader"},"TouchGFXHAL.cpp"),(0,a.kt)("pre",null,(0,a.kt)("code",p({parentName:"pre"},{className:"language-cpp"}),"bool TouchGFXHAL::beginFrame()\n{\n    tearingEffectCount = 0;\n    return TouchGFXGeneratedHAL::beginFrame();\n}\n")),(0,a.kt)("h4",p({},{id:"reference-implementation-2"}),"Reference implementation"),(0,a.kt)("p",null,"The ",(0,a.kt)("em",{parentName:"p"},"TouchGFX Board Setup")," NUCLEO-H563ZI + RVA35HI includes a reference implementation of partial framebuffer strategy using FMC and adaptive display ",(0,a.kt)("em",{parentName:"p"},"line timer")," configuration:"),(0,a.kt)(r.Z,{imageSource:"/img/development/touchgfx-hal-development/scenarios/stm32h563zi-rva35hi.png",width:"200",mdxType:"Figure"}))}T.isMDXComponent=!0}}]);