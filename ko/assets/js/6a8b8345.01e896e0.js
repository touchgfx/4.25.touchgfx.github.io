"use strict";(self.webpackChunktouchgfx_documentation=self.webpackChunktouchgfx_documentation||[]).push([[1184],{49613:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>f});var r=n(59496);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),c=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=c(e.components);return r.createElement(s.Provider,{value:t},e.children)},u="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),u=c(n),p=a,f=u["".concat(s,".").concat(p)]||u[p]||h[p]||i;return n?r.createElement(f,o(o({ref:t},d),{},{components:n})):r.createElement(f,o({ref:t},d))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=p;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[u]="string"==typeof e?e:a,o[1]=l;for(var c=2;c<i;c++)o[c]=n[c];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}p.displayName="MDXCreateElement"},28128:(e,t,n)=>{n.d(t,{Z:()=>i});var r=n(59496);class a extends r.Component{render(){return r.createElement("div",{className:"code-header"},r.createElement("div",null,r.createElement("h5",null,this.props.children)))}}const i=a},89639:(e,t,n)=>{n.d(t,{Z:()=>i});var r=n(59496),a=n(97395);const i=function(e){const t=e.noShadow||!1,n=e.width,i=e.height,o=(0,a.Z)(e.imageSource);return t?r.createElement("div",{className:"figure noshadow"},r.createElement("a",{href:o,target:"_blank"},r.createElement("img",{width:n,height:i,src:o})),r.createElement("p",null,e.children)):r.createElement("div",{className:"figure"},r.createElement("a",{href:o,target:"_blank"},r.createElement("img",{width:n,height:i,src:o})),r.createElement("p",null,e.children))}},48753:(e,t,n)=>{n.d(t,{Z:()=>l});var r=n(59496),a=n(96151);const i=r.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},r.createElement("path",{fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}));class o extends r.Component{render(){return r.createElement(a.Z,{color:"var(--highlight-color-further-reading)",header:"Further reading",type:"further-reading",icon:i},this.props.children)}}const l=o},96151:(e,t,n)=>{n.d(t,{Z:()=>i});var r=n(59496);class a extends r.Component{render(){const e=`highlight highlight-${this.props.type}`;return r.createElement("div",{className:e},r.createElement("div",{className:"highlight-heading"},r.createElement("h5",null,r.createElement("div",{className:"highlight-icon"},this.props.icon),this.props.header)),r.createElement("div",{className:"highlight-content"},this.props.children))}}const i=a},49018:(e,t,n)=>{n.d(t,{Z:()=>l});var r=n(59496),a=n(96151);const i=r.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},r.createElement("path",{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}));class o extends r.Component{render(){return r.createElement(a.Z,{color:"var(--highlight-color-note)",header:"Note",type:"note",icon:i},this.props.children)}}const l=o},67540:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>f,contentTitle:()=>h,default:()=>v,frontMatter:()=>u,metadata:()=>p,toc:()=>m});n(59496);var r=n(49613),a=n(28128),i=n(48753),o=n(89639),l=n(18399),s=n(49018);function c(){return c=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},c.apply(this,arguments)}function d(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}const u={id:"scenarios-spi",title:"SPI Display Interface"},h=void 0,p={unversionedId:"development/touchgfx-hal-development/scenarios/scenarios-spi",id:"development/touchgfx-hal-development/scenarios/scenarios-spi",title:"SPI Display Interface",description:"This scenario describes how to configure SPI and TouchGFX Generator when using a display with a SPI serial interface and GRAM.",source:"@site/i18n/ko/docusaurus-plugin-content-docs/current/development/touchgfx-hal-development/scenarios/scenarios-spi.mdx",sourceDirName:"development/touchgfx-hal-development/scenarios",slug:"/development/touchgfx-hal-development/scenarios/scenarios-spi",permalink:"/4.25/ko/docs/development/touchgfx-hal-development/scenarios/scenarios-spi",draft:!1,tags:[],version:"current",frontMatter:{id:"scenarios-spi",title:"SPI Display Interface"},sidebar:"docs",previous:{title:"FMC Display Interface",permalink:"/4.25/ko/docs/development/touchgfx-hal-development/scenarios/scenarios-fmc"},next:{title:"MIPI-DSI \uba85\ub839 \ubaa8\ub4dc",permalink:"/4.25/ko/docs/development/touchgfx-hal-development/scenarios/scenarios-dsi-command-mode"}},f={},m=[{value:"Configuration",id:"configuration",level:2},{value:"SPI configuration",id:"fmc-configuration",level:3},{value:"TouchGFX Generator",id:"touchgfx-generator",level:3},{value:"DMA configuration",id:"dma-configuration",level:3},{value:"User Code",id:"user-code",level:2},{value:"Supported Framebuffer Strategies",id:"supported-framebuffer-strategies",level:2},{value:"Single",id:"single",level:3},{value:"Double",id:"double",level:3},{value:"Partial - GRAM display",id:"partial",level:3}],g={toc:m},y="wrapper";function v(e){var{components:t}=e,n=d(e,["components"]);return(0,r.kt)(y,c({},g,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This scenario describes how to configure SPI and ",(0,r.kt)("em",{parentName:"p"},"TouchGFX Generator")," when using a display with a SPI serial interface and GRAM."),(0,r.kt)(s.Z,{mdxType:"Note"},"This scenario assumes that a working display driver has been developed during the Board Bringup phase. The driver must be able to transfer pixels to the display, and to control the memory writing position of the display. Check the datasheet for your display for further details."),(0,r.kt)("h2",c({},{id:"configuration"}),"Configuration"),(0,r.kt)("h3",c({},{id:"fmc-configuration"}),"SPI configuration"),(0,r.kt)("p",null,"Compared to other display interfaces (e.g., FMC), SPI has a lower bandwidth. It is therefore important to optimize the SPI configuration to highest Baud rate to maximize bandwidth. Enable the ",(0,r.kt)("em",{parentName:"p"},"SPI")," from the ",(0,r.kt)("em",{parentName:"p"},"Connectivity")," group in the STM32CubeMX category list. It is recommended to configure a DMA channel to the SPI to minimize CPU load. An example below is for a 64MHz MCU, which caps the SPI Baud at 32MBit/s."),(0,r.kt)(o.Z,{imageSource:"/img/development/touchgfx-hal-development/scenarios/spi-config.png",width:"600",noShadow:!1,mdxType:"Figure"},"FMC Bank Configuration"),(0,r.kt)("p",null,"Be sure to configure the Clock Parameters to align with the display."),(0,r.kt)("h3",c({},{id:"touchgfx-generator"}),"TouchGFX Generator"),(0,r.kt)("p",null,"When using a SPI display interface, the ",(0,r.kt)("em",{parentName:"p"},"Custom")," Display Interface must be selected in the TouchGFX Generator. This means a full HAL cannot be automatically generated, so the developer must implement functionality to configure and transfer pixels from the framebuffer memory to the display manually. All necessary handles to accomplish this are generated by the TouchGFX Generator:"),(0,r.kt)(o.Z,{imageSource:"/img/development/touchgfx-hal-development/scenarios/custom-interface.png",width:"400",noShadow:!1,mdxType:"Figure"},"Display Interface - Custom"),(0,r.kt)("h3",c({},{id:"dma-configuration"}),"DMA configuration"),(0,r.kt)("p",null,"To minimize CPU load, a DMA channel can be configured to transfer pixel data from the framebuffer to the SPI TX address."),(0,r.kt)("h2",c({},{id:"user-code"}),"User Code"),(0,r.kt)("p",null,"Generally, for displays with embedded GRAM, the implementation of the generated TouchGFX HAL handles in ",(0,r.kt)("inlineCode",{parentName:"p"},"TouchGFXHAL.cpp")," should perform the following steps to transfer pixels to the display and synchronize the display with the TouchGFX Engine:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},'Wait for "VSYNC" (sometimes called Tearing Effect (TE) signal) to signal the TouchGFX Engine.'),(0,r.kt)("li",{parentName:"ol"},'Based on the area of the framebuffer to be redrawn, move the "display cursor" and "active window" (the region of the display being updated) to a place in GRAM that matches this area.'),(0,r.kt)("li",{parentName:"ol"},"GRAM\uc5d0 \uc785\ub825\ub418\ub294 \ud53d\uc140 \ub370\uc774\ud130\ub97c \uae30\ub85d\ud560 \uc900\ube44\ub97c \ud569\ub2c8\ub2e4. Depending on the framebuffer strategy and display interface used, this could be swapping framebuffer pointers, signaling TouchGFX Engine, or waiting for previous transfers to complete."),(0,r.kt)("li",{parentName:"ol"},"\ud53d\uc140 \ub370\uc774\ud130\ub97c \uc804\uc1a1\ud569\ub2c8\ub2e4.")),(0,r.kt)("p",null,"Depending on the display used and the framebuffer strategy, the implementation of the above steps will vary."),(0,r.kt)("h2",c({},{id:"supported-framebuffer-strategies"}),"Supported Framebuffer Strategies"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Single"),(0,r.kt)("li",{parentName:"ul"},"Double"),(0,r.kt)("li",{parentName:"ul"},"Partial - GRAM display (Recommended)")),(0,r.kt)(i.Z,{mdxType:"FurtherReading"},"See article ",(0,r.kt)(l.Z,{to:"../../../basic-concepts/framebuffer#framebuffer-strategies",mdxType:"Link"},"Framebuffer Strategies")," for a general introduction to framebuffer strategies in TouchGFX."),(0,r.kt)("p",null,"Because of the limited bandwidth achieved with SPI compared to other display interfaces, it is recommended to use the Partial - GRAM display strategy. This strategy has the advantage of using very little RAM (SPI is commonly used on simple systems with limited RAM) and optimizes the use of the available bandwidth by only initiating transfers to the display containing updated pixels. However, there is a risk of tearing."),(0,r.kt)("p",null,"Using Single buffering with SPI will avoid tearing caused by long rendering. However, the low bandwidth of SPI means that it is generally slower to transfer pixels to the display than the display scanline read the GRAM buffer. Because of this it is important to start transfers on the Falling edge of the TE signal (when the display enters the active area) to avoid tearing. This could look something like this:"),(0,r.kt)(a.Z,{mdxType:"CodeHeader"},"TouchGFXHAL.cpp"),(0,r.kt)("pre",null,(0,r.kt)("code",c({parentName:"pre"},{className:"language-cpp",metastring:"{6,16}","{6,16}":!0}),"void HAL_GPIO_EXTI_Falling_Callback(uint16_t GPIO_Pin)\n{\n    if (GPIO_Pin == LCD_TE_Pin)\n    {\n        // VSync has occurred, increment TouchGFX engine vsync counter\n        HAL::getInstance()->vSync();\n        // VSync has occurred, signal TouchGFX engine\n        OSWrappers::signalVSync();\n        GPIO::clear(GPIO::VSYNC_FREQ);\n\n        if (refreshRequested)\n        {\n            refreshRequested = false;\n            nextSendToDisplayLine = refreshMinLine;\n            maxSendToDisplayLine = refreshMaxLine;\n            sendNextFrameBufferBlockToDisplay();\n        }\n    }\n}\n")),(0,r.kt)(s.Z,{mdxType:"Note"},"If having a slower display transfer bandwidth than the display scanline, transfers must be initiated on the Falling edge of the TE signal to avoid tearing."),(0,r.kt)("p",null,"Using Double buffering with SPI will avoid tearing caused by long rendering. However, if too many pixels are transferred to the display at each frame, the scanline that read the GRAM buffer may collide with the region being transferred, causing tearing due to slow transfer bandwidth. This can be mitigated by only transferring pixels areas that have been updated and not the whole framebuffer. The function ",(0,r.kt)("inlineCode",{parentName:"p"},"TouchGFXHAL::flushFrameBuffer")," can be used to calculate the updated area in each frame to define that minimum area to transfer."),(0,r.kt)("h3",c({},{id:"single"}),"Single"),(0,r.kt)("p",null,"Currently, no ",(0,r.kt)("em",{parentName:"p"},"TouchGFX Board Support")," have a reference implementation for Single buffering with SPI. The setup would be similar to ",(0,r.kt)(l.Z,{to:"scenarios-fmc#single",mdxType:"Link"},"FMC Single buffer")," setup, but using SPI driver functions instead of FMC."),(0,r.kt)("h3",c({},{id:"double"}),"Double"),(0,r.kt)("p",null,"Currently, no ",(0,r.kt)("em",{parentName:"p"},"TouchGFX Board Support")," have a reference implementation for Double buffering with SPI. The setup would be similar to ",(0,r.kt)(l.Z,{to:"scenarios-fmc#double",mdxType:"Link"},"FMC Double buffer")," setup, but using SPI driver functions instead of FMC."),(0,r.kt)("h3",c({},{id:"partial"}),"Partial - GRAM display"),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"TouchGFX Board Setup")," NUCLEO-G071RB + GFX01M2 includes a reference implementation of Partial - GRAM display with SPI. The setup is similar to ",(0,r.kt)(l.Z,{to:"scenarios-fmc#partial",mdxType:"Link"},"FMC Partial buffer")," setup, but using SPI driver functions instead of FMC:"),(0,r.kt)(o.Z,{imageSource:"/img/development/touchgfx-hal-development/scenarios/stm32g071rb-gfx01m2.png",width:"200",mdxType:"Figure"}))}v.isMDXComponent=!0}}]);