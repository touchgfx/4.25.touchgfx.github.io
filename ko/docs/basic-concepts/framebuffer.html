<!doctype html>
<html lang="ko" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-basic-concepts/framebuffer" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.3">
<title data-rh="true">프레임버퍼 | TouchGFX Documentation</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://support.touchgfx.com/4.25/ko/img/meta-image.png"><meta data-rh="true" name="twitter:image" content="https://support.touchgfx.com/4.25/ko/img/meta-image.png"><meta data-rh="true" property="og:url" content="https://support.touchgfx.com/4.25/ko/docs/basic-concepts/framebuffer"><meta data-rh="true" name="docusaurus_locale" content="ko"><meta data-rh="true" name="docsearch:language" content="ko"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="프레임버퍼 | TouchGFX Documentation"><meta data-rh="true" name="description" content="프레임버퍼란 그래픽 엔진에서 디스플레이에 표시할 다음 이미지를 준비할 목적으로 업데이트되는 메모리를 말합니다."><meta data-rh="true" property="og:description" content="프레임버퍼란 그래픽 엔진에서 디스플레이에 표시할 다음 이미지를 준비할 목적으로 업데이트되는 메모리를 말합니다."><link data-rh="true" rel="icon" href="/4.25/ko/img/favicon.png"><link data-rh="true" rel="canonical" href="https://support.touchgfx.com/4.25/ko/docs/basic-concepts/framebuffer"><link data-rh="true" rel="alternate" href="https://support.touchgfx.com/4.25/docs/basic-concepts/framebuffer" hreflang="en"><link data-rh="true" rel="alternate" href="https://support.touchgfx.com/4.25/ko/docs/basic-concepts/framebuffer" hreflang="ko"><link data-rh="true" rel="alternate" href="https://support.touchgfx.com/4.25/ja/docs/basic-concepts/framebuffer" hreflang="ja"><link data-rh="true" rel="alternate" href="https://support.touchgfx.com/4.25/zh-CN/docs/basic-concepts/framebuffer" hreflang="zh-CN"><link data-rh="true" rel="alternate" href="https://support.touchgfx.com/4.25/zh-TW/docs/basic-concepts/framebuffer" hreflang="zh-TW"><link data-rh="true" rel="alternate" href="https://support.touchgfx.com/4.25/docs/basic-concepts/framebuffer" hreflang="x-default"><link data-rh="true" rel="preconnect" href="https://B8LNOI0XWD-dsn.algolia.net" crossorigin="anonymous"><link rel="search" type="application/opensearchdescription+xml" title="TouchGFX Documentation" href="/4.25/ko/opensearch.xml">


<script src="/4.25/ko/js/one-trust.js"></script>
<script src="/4.25/js/fix-location.js"></script><link rel="stylesheet" href="/4.25/ko/assets/css/styles.6e57ba1f.css">
<link rel="preload" href="/4.25/ko/assets/js/runtime~main.71a07306.js" as="script">
<link rel="preload" href="/4.25/ko/assets/js/main.b265f188.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}return t}()||function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><div role="region" aria-label="주요 내용으로 건너뛰기"><a class="skipToContent_xAYN" href="#__docusaurus_skipToContent_fallback">주요 내용으로 건너뛰기</a></div><nav aria-label="메인" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="탐색 모음 활성화/비활성화" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" target="_self" href="/4.25/ko/docs/introduction/welcome"><div class="navbar__logo"><img src="/4.25/ko/img/logo.svg" alt="TouchGFX" class="themedImage_m0dh themedImage--light_OZkp"><img src="/4.25/ko/img/logo.svg" alt="TouchGFX" class="themedImage_m0dh themedImage--dark_ViMM"></div></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/4.25/ko/docs/introduction/welcome">문서</a><a class="navbar__item navbar__link" href="/4.25/ko/docs/api/namespacetouchgfx">API</a><a class="navbar__item navbar__link" sidebarid="academy" href="/4.25/ko/academy/academy-introduction">TouchGFX 아카데미</a><a href="https://community.st.com/s/topic/0TO0X0000003iw6WAA/touchgfx" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Community</a></div><div class="navbar__items navbar__items--right"><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a class="navbar__link" aria-haspopup="true" aria-expanded="false" role="button" href="/4.25/ko/docs/introduction/welcome">4.25</a><ul class="dropdown__menu"><li><a aria-current="page" class="dropdown__link dropdown__link--active" href="/4.25/ko/docs/basic-concepts/framebuffer">4.25</a></li><li><a href="https://support.touchgfx.com/4.25" target="_blank" rel="noopener noreferrer" class="dropdown__link">4.25<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_vrp6"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li><a href="https://support.touchgfx.com/4.24" target="_blank" rel="noopener noreferrer" class="dropdown__link">4.24<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_vrp6"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li><a href="https://support.touchgfx.com/4.23" target="_blank" rel="noopener noreferrer" class="dropdown__link">4.23<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_vrp6"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li><a href="https://support.touchgfx.com/4.22" target="_blank" rel="noopener noreferrer" class="dropdown__link">4.22<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_vrp6"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li><a href="https://support.touchgfx.com/4.21" target="_blank" rel="noopener noreferrer" class="dropdown__link">4.21<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_vrp6"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li><a href="https://support.touchgfx.com/4.20" target="_blank" rel="noopener noreferrer" class="dropdown__link">4.20<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_vrp6"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li><a href="https://support.touchgfx.com/4.19" target="_blank" rel="noopener noreferrer" class="dropdown__link">4.19<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_vrp6"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li><a href="https://support.touchgfx.com/4.18" target="_blank" rel="noopener noreferrer" class="dropdown__link">4.18<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_vrp6"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li><a href="https://support.touchgfx.com/4.17" target="_blank" rel="noopener noreferrer" class="dropdown__link">4.17<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_vrp6"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li><a href="https://support.touchgfx.com/4.16" target="_blank" rel="noopener noreferrer" class="dropdown__link">4.16<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_vrp6"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li><a href="https://support.touchgfx.com/4.15" target="_blank" rel="noopener noreferrer" class="dropdown__link">4.15<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_vrp6"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li><a href="https://support.touchgfx.com/4.14" target="_blank" rel="noopener noreferrer" class="dropdown__link">4.14<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_vrp6"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li><a href="https://support.touchgfx.com/4.13" target="_blank" rel="noopener noreferrer" class="dropdown__link">4.13<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_vrp6"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">한국어</a><ul class="dropdown__menu"><li><a href="/4.25/docs/basic-concepts/framebuffer" target="_self" rel="noopener noreferrer" class="dropdown__link" lang="en">English</a></li><li><a href="/4.25/ko/docs/basic-concepts/framebuffer" target="_self" rel="noopener noreferrer" class="dropdown__link dropdown__link--active" lang="ko">한국어</a></li><li><a href="/4.25/ja/docs/basic-concepts/framebuffer" target="_self" rel="noopener noreferrer" class="dropdown__link" lang="ja">日本語</a></li><li><a href="/4.25/zh-CN/docs/basic-concepts/framebuffer" target="_self" rel="noopener noreferrer" class="dropdown__link" lang="zh-CN">简体中文</a></li><li><a href="/4.25/zh-TW/docs/basic-concepts/framebuffer" target="_self" rel="noopener noreferrer" class="dropdown__link" lang="zh-TW">繁體中文</a></li></ul></div><div class="searchBox_y6an"><button type="button" class="DocSearch DocSearch-Button" aria-label="검색하기"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">검색하기</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_ovZa docsWrapper_a09d"><button aria-label="맨 위로 스크롤하기" class="clean-btn theme-back-to-top-button backToTopButton_PCdr" type="button"></button><div class="docPage_CL8Z"><aside class="theme-doc-sidebar-container docSidebarContainer_ThtD"><div class="sidebarViewport_mAJy"><div class="sidebar_Oq1e"><nav aria-label="문서 사이드바" class="menu thin-scrollbar menu_M44W"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/4.25/ko/docs/category/introduction">Introduction</a><button aria-label="접을 수 있는 사이드바 카테고리 &#x27;Introduction&#x27; 토글" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" href="/4.25/ko/docs/category/basic-concepts">Basic Concepts</a><button aria-label="접을 수 있는 사이드바 카테고리 &#x27;Basic Concepts&#x27; 토글" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/4.25/ko/docs/basic-concepts/embedded-graphics">임베디드 그래픽</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/4.25/ko/docs/basic-concepts/color-formats">색상 형식</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/4.25/ko/docs/basic-concepts/framebuffer">프레임버퍼</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/4.25/ko/docs/basic-concepts/graphics-engine">그래픽 엔진</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/4.25/ko/docs/basic-concepts/rendering">메인 루프</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/4.25/ko/docs/basic-concepts/performance">성능</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/4.25/ko/docs/basic-concepts/operating-system">운영 체제</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/4.25/ko/docs/basic-concepts/memory-usage">메모리 사용량</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/4.25/ko/docs/development/development-introduction">Development</a><button aria-label="접을 수 있는 사이드바 카테고리 &#x27;Development&#x27; 토글" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/4.25/ko/docs/category/miscellaneous-1">Miscellaneous</a><button aria-label="접을 수 있는 사이드바 카테고리 &#x27;Miscellaneous&#x27; 토글" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/4.25/ko/docs/category/resources">Resources</a><button aria-label="접을 수 있는 사이드바 카테고리 &#x27;Resources&#x27; 토글" type="button" class="clean-btn menu__caret"></button></div></li></ul></nav></div></div></aside><main class="docMainContainer_fxxJ"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_QTf6"><div id="doc-version-banner-identifier" class="theme-doc-version-banner alert alert--warning margin-bottom--md" role="alert"><div>더 이상 적극적으로 유지 관리되지 않는 <!-- -->TouchGFX<!-- --> <b>4.25</b> 버전에 대한 문서입니다. </div><div class="margin-top--md">최신 문서는 <b><a href="https://support.touchgfx.com/docs/basic-concepts/framebuffer" target="_blank" rel="noopener noreferrer">최신 버전</a></b>를 참조하십시오.</div></div><div class="docItemContainer_yTh1"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer__o78" aria-label="브레드크럼"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/4.25/ko/docs/category/basic-concepts"><span itemprop="name">Basic Concepts</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">프레임버퍼</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_CArF theme-doc-toc-mobile tocMobile_PMGv"><button type="button" class="clean-btn tocCollapsibleButton_I8Hj">이 페이지에서</button></div><div class="theme-doc-markdown markdown"><header><h1>프레임버퍼</h1></header><p>프레임버퍼란 그래픽 엔진에서 디스플레이에 표시할 다음 이미지를 준비할 목적으로 업데이트되는 메모리를 말합니다.</p><p>프레임버퍼는 일정 크기의 RAM에 인접한 부분입니다.</p><div class="figure noshadow"><a href="/4.25/ko/img/basic-concepts/framebuffer-contiguous-memory.svg" target="_blank"><img src="/4.25/ko/img/basic-concepts/framebuffer-contiguous-memory.svg"></a><p>프레임버퍼 메모리</p></div><p>프레임버퍼에는 연관된 가로와 세로가 있습니다. 이러한 이유로 프레임버퍼는 x,y 좌표로 인덱싱이 가능한 2D 메모리라는 인식이 있습니다.</p><div class="figure noshadow"><a href="/4.25/ko/img/basic-concepts/framebuffer-2d-memory.svg" target="_blank"><img src="/4.25/ko/img/basic-concepts/framebuffer-2d-memory.svg"></a><p>2D 프레임버퍼 메모리</p></div><p>프레임버퍼에는 연관된 색상 형식이 있습니다. 프레임버퍼의 시작 부분은 이러한 색상 형식에 따른 색상을 나타냅니다. 따라서 프레임버퍼의 이러한 각 시작 부분을 픽셀이라고 칭하겠습니다.</p><p>프레임버퍼의 픽셀 메모리 주소를 계산하여 저장된 색상을 업데이트하면 프레임버퍼에서 x, y 위치의 픽셀 색상을 업데이트할 수 있습니다.</p><div class="language-cpp codeBlockContainer_xMD_ theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_JIBA"><pre tabindex="0" class="prism-code language-cpp codeBlock_uX6S thin-scrollbar"><code class="codeBlockLines_ZLum"><span class="token-line" style="color:#bfc7d5"><span class="token keyword" style="font-style:italic">uint32_t</span><span class="token plain"> pixelAddress </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> x </span><span class="token operator" style="color:rgb(137, 221, 255)">+</span><span class="token plain"> y </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain"> WIDTH</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">framebuffer</span><span class="token punctuation" style="color:rgb(199, 146, 234)">[</span><span class="token plain"> pixelAddress </span><span class="token punctuation" style="color:rgb(199, 146, 234)">]</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> newColor</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><br></span></code></pre><div class="buttonGroup__VZb"><button type="button" aria-label="클립보드에 코드 복사하기" title="복사하기" class="clean-btn"><span class="copyButtonIcons_TYFZ" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_dFlr"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_amKQ"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>마찬가지로 프레임버퍼의 픽셀 색상을 가져와서 계산에 사용할 수도 있습니다. 예를 들어 프레임버퍼의 픽셀 색상을 어둡게 할 수 있습니다(<code>darken</code> 함수를 사용할 수 있는 경우).</p><div class="language-cpp codeBlockContainer_xMD_ theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_JIBA"><pre tabindex="0" class="prism-code language-cpp codeBlock_uX6S thin-scrollbar"><code class="codeBlockLines_ZLum"><span class="token-line" style="color:#bfc7d5"><span class="token keyword" style="font-style:italic">uint32_t</span><span class="token plain"> pixelAddress </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> x </span><span class="token operator" style="color:rgb(137, 221, 255)">+</span><span class="token plain"> y </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain"> WIDTH</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">framebuffer</span><span class="token punctuation" style="color:rgb(199, 146, 234)">[</span><span class="token plain"> pixelAddress </span><span class="token punctuation" style="color:rgb(199, 146, 234)">]</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">darken</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain"> framebuffer</span><span class="token punctuation" style="color:rgb(199, 146, 234)">[</span><span class="token plain"> pixelAddress </span><span class="token punctuation" style="color:rgb(199, 146, 234)">]</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><br></span></code></pre><div class="buttonGroup__VZb"><button type="button" aria-label="클립보드에 코드 복사하기" title="복사하기" class="clean-btn"><span class="copyButtonIcons_TYFZ" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_dFlr"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_amKQ"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>프레임버퍼 메모리는 위와 같이 픽셀 단위로 쓰거나 읽는 경우가 많지 않고, Chrom-ART DMA와 같은 시스템 기반 하드웨어 기능을 주로 이용해 쓰거나 읽습니다.</p><h2 class="anchor anchorWithStickyNavbar_k1OW" id="colors">색상<a href="#colors" class="hash-link" aria-label="색상에 대한 다이렉트 링크" title="색상에 대한 다이렉트 링크">​</a></h2><p>TouchGFX에서 프레임버퍼의 픽셀 색상 형식은 다음 중 한 가지입니다.</p><ul><li><strong>그레이스케일</strong> 1, 2 또는 4bpp(Bits per Pixel) 그레이스케일</li><li><strong>하이 또는 트루 컬러</strong> 16, 24 또는 32bpp 색상</li></ul><p>bpp를 많이 사용할수록 프레임버퍼에서 나타낼 수 있는 고유 색상도 늘어납니다. 나아가, bpp를 많이 사용할수록 프레임버퍼의 메모리 소비량도 증가합니다.</p><h2 class="anchor anchorWithStickyNavbar_k1OW" id="display">디스플레이<a href="#display" class="hash-link" aria-label="디스플레이에 대한 다이렉트 링크" title="디스플레이에 대한 다이렉트 링크">​</a></h2><p>프레임버퍼의 내용은 최종적으로 물리적 디스플레이에 전송되어 표시됩니다. 따라서 프레임버퍼와 디스플레이의 픽셀 가로 및 세로가 서로 동일한 경우가 많습니다.</p><div class="figure noshadow"><a href="/4.25/ko/img/basic-concepts/display-and-framebuffer.svg" target="_blank"><img src="/4.25/ko/img/basic-concepts/display-and-framebuffer.svg"></a><p>24bpp 프레임버퍼 내용과 그에 따른 디스플레이 결과</p></div><div class="highlight highlight-further-reading"><div class="highlight-heading"><h5><div class="highlight-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></div>Further reading</h5></div><div class="highlight-content">여러 가지 디스플레이 유형에 대한 자세한 내용은 <a href="/4.25/ko/docs/development/hardware-selection/hardware-components/hardware-selection-display">디스플레이 기술</a> 섹션을 참조하십시오.</div></div><h2 class="anchor anchorWithStickyNavbar_k1OW" id="location-of-framebuffer">프레임버퍼 위치<a href="#location-of-framebuffer" class="hash-link" aria-label="프레임버퍼 위치에 대한 다이렉트 링크" title="프레임버퍼 위치에 대한 다이렉트 링크">​</a></h2><p>마이크로컨트롤러 기반의 그래픽 시스템을 크게 단순화하면 다음과 같습니다.</p><div class="figure noshadow"><a href="/4.25/ko/img/basic-concepts/simplified-graphics-system.webp" target="_blank"><img width="400" src="/4.25/ko/img/basic-concepts/simplified-graphics-system.webp"></a><p>그래픽 시스템 개략도</p></div><p>프레임버퍼는 MCU 내부 또는 외부 RAM에 저장됩니다.</p><div class="figure noshadow"><a href="/4.25/ko/img/basic-concepts/framebuffer-placement.webp" target="_blank"><img width="600" src="/4.25/ko/img/basic-concepts/framebuffer-placement.webp"></a><p>가능한 프레임버퍼 위치</p></div><p>각 위치는 잠재적 장점과 단점이 있습니다.</p><h3 class="anchor anchorWithStickyNavbar_k1OW" id="internal-ram">내부 RAM<a href="#internal-ram" class="hash-link" aria-label="내부 RAM에 대한 다이렉트 링크" title="내부 RAM에 대한 다이렉트 링크">​</a></h3><p>프레임버퍼를 MCU 내부 RAM에 저장하면 프레임버퍼에 대한 읽기/쓰기 액세스 속도를 극대화할 수 있습니다. 따라서 TouchGFX 애플리케이션도 최대한 원활하게 실행됩니다. 반대로 내부 RAM은 다수의 시스템 구성요소에서 사용하여 매우 부족한 리소스이기 때문에 프레임버퍼가 많은 용량을 차지하기는 어려울 수 있습니다.</p><p>하지만 만약 가능하다면 프레임버퍼를 내부 RAM에 저장하여 RAM을 추가할 필요가 없기 때문에 시스템의 전반적인 비용을 줄일 수 있습니다.</p><h3 class="anchor anchorWithStickyNavbar_k1OW" id="external-ram">외부 RAM<a href="#external-ram" class="hash-link" aria-label="외부 RAM에 대한 다이렉트 링크" title="외부 RAM에 대한 다이렉트 링크">​</a></h3><p>시스템에 외부 RAM이 있다면 프레임버퍼를 외부 RAM에 저장하여 내부 RAM을 대체할 수도 있습니다. 외부 RAM에 대한 읽기/쓰기 액세스 속도는 내부 RAM에 비해 대체로 느린 반면, 외부 RAM의 용량은 일반적으로 내부 RAM보다 훨씬 큽니다 따라서 외부 RAM이 유일한 해결책일 때도 있습니다.</p><p>MCU는 캐싱과 같이 외부 RAM에 대한 액세스 속도를 높여주는 기능을 지원하기도 합니다. 자세한 내용은 <a href="/4.25/ko/docs/development/hardware-selection/hardware-components/hardware-selection-mcu">MCU</a> 섹션을 참조하십시오.</p><h3 class="anchor anchorWithStickyNavbar_k1OW" id="display-with-gram">Display with GRAM<a href="#display-with-gram" class="hash-link" aria-label="Display with GRAM에 대한 다이렉트 링크" title="Display with GRAM에 대한 다이렉트 링크">​</a></h3><p>Depending on the type of display in the system there might be memory embedded on the display (often called GRAM). 이러한 메모리에는 디스플레이의 “물리적” 픽셀 내용이 저장됩니다. 픽셀 메모리가 디스플레이에 내장된다는 것은 디스플레이가 작동 중일 때도 MCU가 유휴 상태가 될 수 있다는 것을 의미합니다.</p><p>TouchGFX 프레임버퍼는 디스플레이의 RAM에 저장되지 않는데, 그 이유는 디스플레이의 내부 메모리가 메모리 매핑이 되지 않으며 랜덤 픽셀 읽기 또는 쓰기에 적합하지 않기 때문입니다. 대신에 TouchGFX는 프레임버퍼를 내부 또는 외부 RAM에 저장해두고 필요할 때 이를 디스플레이 RAM으로 전송합니다.</p><h2 class="anchor anchorWithStickyNavbar_k1OW" id="memory-consumption">메모리 사용<a href="#memory-consumption" class="hash-link" aria-label="메모리 사용에 대한 다이렉트 링크" title="메모리 사용에 대한 다이렉트 링크">​</a></h2><p>프레임버퍼의 메모리 소비량은 색상 크기와 픽셀 수에 따라 달라집니다.</p><p>일반적으로 프레임버퍼에서 사용되는 메모리의 크기는 가로 <em> 세로</em> 색 심도(비트) / 8바이트로 계산합니다.</p><table><thead><tr><th align="right">해상도(픽셀)</th><th align="right">색상(bpp)</th><th align="right">계산</th><th align="right">메모리 사용량(바이트)</th></tr></thead><tbody><tr><td align="right">800 x 480</td><td align="right">16bpp</td><td align="right">800 <em> 480 </em> 16 / 8</td><td align="right">768,000B</td></tr><tr><td align="right">480 x 272</td><td align="right">24bpp</td><td align="right">480 <em> 272 </em> 24 / 8</td><td align="right">391,680B</td></tr><tr><td align="right">100 x 100</td><td align="right">8bpp</td><td align="right">100 <em> 100 </em> 8 / 8</td><td align="right">10,000B</td></tr></tbody></table><p>프레임버퍼가 다수일 경우에는 사용되는 메모리의 크기도 그만큼 커집니다. 예를 들어 프레임버퍼를 2개 사용하는 이중 버퍼링 기법을 적용하면 사용되는 메모리 크기도 2배로 늘어납니다.</p><p>반대로 프레임버퍼를 1개 미만으로 사용하는 경우에는 애플리케이션에서 메모리 크기를 명시적으로 할당하고 제어합니다. 따라서 메모리 사용량을 전적으로 맞춤 설정할 수 있지만 너무 적게 사용하면 그래픽의 전반적인 성능이 느려질 수 있습니다.</p><h2 class="anchor anchorWithStickyNavbar_k1OW" id="framebuffer-strategies">Framebuffer Strategies<a href="#framebuffer-strategies" class="hash-link" aria-label="Framebuffer Strategies에 대한 다이렉트 링크" title="Framebuffer Strategies에 대한 다이렉트 링크">​</a></h2><p>Framebuffer strategy is a core feature, that enables you to make the most optimal match between TouchGFX rendering and your existing hardware (MCU, RAM and Display). In case you are selecting new hardware, it is recommended to get familiar with the available framebuffer strategies in relation to your use case. The right choice can help optimize your hardware cost, i.e. assist you in selecting the minimum required hardware in terms of the amount of RAM for framebuffer(s) and the suitable display interface.</p><p>A framebuffer strategy defines how much RAM is used for framebuffers and controls how TouchGFX renders to the RAM. The strategy must match the available RAM and the type of display in the system. TouchGFX offers three different strategies, applicable on display systems with and without GRAM. Below is an overview of the strategies, highlighting their advantages and drawbacks in relation to display systems.</p><h4 class="anchor anchorWithStickyNavbar_k1OW" id="display-without-gram-table">Displays without GRAM<a href="#display-without-gram-table" class="hash-link" aria-label="Displays without GRAM에 대한 다이렉트 링크" title="Displays without GRAM에 대한 다이렉트 링크">​</a></h4><table><thead><tr><th>Strategy</th><th>Advantages</th><th>Drawbacks</th><th>Use Cases</th></tr></thead><tbody><tr><td>Double</td><td>No risk of tearing, optimal time for rendering</td><td>RAM for 2 framebuffers</td><td>High performance UIs</td></tr><tr><td>Single</td><td>Only RAM for 1 framebuffer</td><td>Risk of tearing, suboptimal time for rendering</td><td>High - Moderate performance UIs</td></tr><tr><td>Partial</td><td>Only RAM for less than a framebuffer</td><td>Higher risk of tearing, higher CPU load</td><td>Moderate - Low performance UIs</td></tr></tbody></table><h4 class="anchor anchorWithStickyNavbar_k1OW" id="display-with-gram-table">Displays with GRAM<a href="#display-with-gram-table" class="hash-link" aria-label="Displays with GRAM에 대한 다이렉트 링크" title="Displays with GRAM에 대한 다이렉트 링크">​</a></h4><table><thead><tr><th>Strategy</th><th>Advantages</th><th>Drawbacks</th><th>Use Cases</th></tr></thead><tbody><tr><td>Double</td><td>No risk of tearing, optimal time for rendering</td><td>RAM for 2 framebuffers</td><td>High performance UIs</td></tr><tr><td>Single</td><td>Only RAM for 1 framebuffer, no risk of tearing</td><td>Suboptimal time for rendering</td><td>High - Moderate performance UIs</td></tr><tr><td>Partial</td><td>Only RAM for less than a framebuffer</td><td>Risk of tearing</td><td>Moderate - Low performance UIs</td></tr></tbody></table><h3 class="anchor anchorWithStickyNavbar_k1OW" id="tearing">Tearing<a href="#tearing" class="hash-link" aria-label="Tearing에 대한 다이렉트 링크" title="Tearing에 대한 다이렉트 링크">​</a></h3><p>Tearing is a visual artifact on the display where pixel data from two frames are shown in one screen draw, e.g. the screen has half of an old frame and half of a current one, with a clean horizontal split across (the tear). The location of the tear varies according to timing, it usually jumps all over the place, which can be distracting.</p><h3 class="anchor anchorWithStickyNavbar_k1OW" id="framebuffer-strategy-performance">UI Performance<a href="#framebuffer-strategy-performance" class="hash-link" aria-label="UI Performance에 대한 다이렉트 링크" title="UI Performance에 대한 다이렉트 링크">​</a></h3><p>In the general <a href="/4.25/ko/docs/basic-concepts/performance">Performance</a> article, you will be introduced to aspects of UI performance, which covers how the individual UI components and there structure impacts performance. In the context of framebuffer strategy we think of:</p><ul><li>High performance, as UIs that uses multiple complex UI components/animations, e.g. Texture Mappers, SVGs, screen transitions</li><li>Moderate performance, as UIs that uses few complex UI components/animations</li><li>Low performance, as UIs that uses no complex UI components/animations</li></ul><div class="highlight highlight-note"><div class="highlight-heading"><h5><div class="highlight-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></div>Note</h5></div><div class="highlight-content">The above examples are not definitive. Keep in mind that the UI performance depend on your hardware and UI design.</div></div><h3 class="anchor anchorWithStickyNavbar_k1OW" id="framebuffer-strategies-glossary">Glossary<a href="#framebuffer-strategies-glossary" class="hash-link" aria-label="Glossary에 대한 다이렉트 링크" title="Glossary에 대한 다이렉트 링크">​</a></h3><p>The following terms are used to describe the different framebuffer strategies.</p><ul><li><strong>Display Controller (DC)</strong> - The hardware that reads pixels from memory. Is continuously reading the memory containing pixels. Sometimes referred to as the <em>scanline</em>.</li><li><strong>Display Transfer (DT)</strong> - The hardware responsible of transferring pixels from framebuffer memory to GRAM. Is only initiated by the MCU when required. Sometimes referred to as the <em>transferline</em>.</li><li><strong>Framebuffer Write (W)</strong> - The rendering of pixels to the framebuffer.</li></ul><h3 class="anchor anchorWithStickyNavbar_k1OW" id="display-without-gram-framebuffer-strategies">Displays without GRAM<a href="#display-without-gram-framebuffer-strategies" class="hash-link" aria-label="Displays without GRAM에 대한 다이렉트 링크" title="Displays without GRAM에 대한 다이렉트 링크">​</a></h3><p>The following demonstrates the working concept of framebuffer strategies on displays without GRAM. Common for all strategies are the use of a Display Controller which continuously reads pixel data directly from a framebuffer.</p><h4 class="anchor anchorWithStickyNavbar_k1OW" id="display-without-gram-double-buffering">Double Buffering Strategy<a href="#display-without-gram-double-buffering" class="hash-link" aria-label="Double Buffering Strategy에 대한 다이렉트 링크" title="Double Buffering Strategy에 대한 다이렉트 링크">​</a></h4><p>Having two framebuffers allows rendering of the next frame into one framebuffer while the Display Controller scans the other framebuffer. Render time of the next frame is unrestricted by the Display Controller. Swapping framebuffers is blocked until the next frame is ready, meaning no risk of tearing because the Display Controller just scans the current framebuffer once again. The framebuffers are swapped after the Display Controller has scanned the entire framebuffer and the rendering is complete.</p><div class="figure noshadow"><a href="/4.25/ko/img/basic-concepts/ltdc-double.png" target="_blank"><img width="650" src="/4.25/ko/img/basic-concepts/ltdc-double.png"></a><p>Double Buffering Strategy Concept</p></div><h4 class="anchor anchorWithStickyNavbar_k1OW" id="display-without-gram-single-buffering">Single Buffering Strategy<a href="#display-without-gram-single-buffering" class="hash-link" aria-label="Single Buffering Strategy에 대한 다이렉트 링크" title="Single Buffering Strategy에 대한 다이렉트 링크">​</a></h4><p>Having one framebuffer allows rendering of the next frame into the same framebuffer as the Display Controller scans from. Render time of the next frame is restricted by the Display Controller. The Display Controller scans continuously, so if writing to the framebuffer takes too long, the Display Controller will collide (catch up) with the writing area and tearing will occur. This is caused by rendering complex UI components.</p><div class="figure noshadow"><a href="/4.25/ko/img/basic-concepts/ltdc-single.png" target="_blank"><img width="400" src="/4.25/ko/img/basic-concepts/ltdc-single.png"></a><p>Single Buffering Strategy Concept</p></div><h4 class="anchor anchorWithStickyNavbar_k1OW" id="display-without-gram-partial-buffering">Partial Buffering Strategy<a href="#display-without-gram-partial-buffering" class="hash-link" aria-label="Partial Buffering Strategy에 대한 다이렉트 링크" title="Partial Buffering Strategy에 대한 다이렉트 링크">​</a></h4><p>A single partial framebuffer block is used to emulate a full size framebuffer through a Memory Management Unit (MMU). Therefore this strategy is also known as <em>Emulated Framebuffer Strategy</em>.</p><p>The partial block acts as a sliding window moving down through the emulated framebuffer, with the phase and speed of the Display Controller.</p><p>Having a partial framebuffer block only allows rendering of a small portion of the next frame, because the block is reused multiple times to render the current frame. The reuse of the partial block results in a large number of small rendering operations, which result in higher CPU load. Render time of the next frame is restricted by the Display Controller and the partial block size. The Display Controller scans continuously, so if writing to the partial framebuffer block takes too long for any given region of the emulated framebuffer, the Display Controller will collide (catch up) with the writing area and tearing will occur. This is caused by rendering complex UI components. Compared to the Single Buffering Strategy the risk of tearing is higher because the working area of the Display Controller and framebuffer rendering is much smaller.</p><div class="figure noshadow"><a href="/4.25/ko/img/basic-concepts/ltdc-partial.png" target="_blank"><img width="700" src="/4.25/ko/img/basic-concepts/ltdc-partial.png"></a><p>Partial Buffering Strategy Concept</p></div><div class="highlight highlight-note"><div class="highlight-heading"><h5><div class="highlight-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></div>Note</h5></div><div class="highlight-content">This strategy is only available on MCUs with a <a href="https://www.st.com/resource/en/application_note/an5051-graphic-memory-optimization-with-stm32-chromgrc-stmicroelectronics.pdf" target="_blank" rel="noopener noreferrer">STM32 Chrom-GRC (GFXMMU)</a></div></div><h3 class="anchor anchorWithStickyNavbar_k1OW" id="display-with-gram-framebuffer-strategies">Displays with GRAM<a href="#display-with-gram-framebuffer-strategies" class="hash-link" aria-label="Displays with GRAM에 대한 다이렉트 링크" title="Displays with GRAM에 대한 다이렉트 링크">​</a></h3><p>The following demonstrates the working concept of framebuffer strategies on GRAM displays. Common for all strategies are the use of a Display Interface used for transferring pixel data from a framebuffer to the GRAM on the display.</p><h4 class="anchor anchorWithStickyNavbar_k1OW" id="display-with-gram-double-buffering">Double Buffering Strategy<a href="#display-with-gram-double-buffering" class="hash-link" aria-label="Double Buffering Strategy에 대한 다이렉트 링크" title="Double Buffering Strategy에 대한 다이렉트 링크">​</a></h4><p>Having two framebuffers allows rendering of the next frame into one framebuffer while the pixels are transferred to GRAM from the other. Render time of the next frame is unrestricted by the Display Transfer. Display transfers are only initiated when the next frame is ready, meaning no risk of tearing because the Display Controller just scans what is already in GRAM. The framebuffers are swapped after the display transfer and the rendering is complete.</p><div class="figure noshadow"><a href="/4.25/ko/img/basic-concepts/gram-double.png" target="_blank"><img src="/4.25/ko/img/basic-concepts/gram-double.png"></a><p>Double Buffering Strategy Concept</p></div><h4 class="anchor anchorWithStickyNavbar_k1OW" id="display-with-gram-single-buffering">Single Buffering Strategy<a href="#display-with-gram-single-buffering" class="hash-link" aria-label="Single Buffering Strategy에 대한 다이렉트 링크" title="Single Buffering Strategy에 대한 다이렉트 링크">​</a></h4><p>Having one framebuffer allows rendering of the next frame into the same framebuffer where pixels are transferred to GRAM. Render time of the next frame is restricted by the Display Transfer bandwidth. Display transfers are only initiated when the next frame is ready, meaning no risk of tearing because the Display Controller just scans what is already in GRAM. Rendering of the next frame cannot complete before the corresponding area to update has been transferred to GRAM.</p><div class="figure noshadow"><a href="/4.25/ko/img/basic-concepts/gram-single.png" target="_blank"><img width="700" src="/4.25/ko/img/basic-concepts/gram-single.png"></a><p>Single Buffering Strategy Concept</p></div><h4 class="anchor anchorWithStickyNavbar_k1OW" id="display-with-gram-partial-buffering">Partial Buffering Strategy<a href="#display-with-gram-partial-buffering" class="hash-link" aria-label="Partial Buffering Strategy에 대한 다이렉트 링크" title="Partial Buffering Strategy에 대한 다이렉트 링크">​</a></h4><p>One or more partial framebuffer blocks are used to emulate a full size framebuffer.</p><p>The partial blocks are reused to render all parts of the current frame that needs to be updated. When a block is rendered it can be transferred to GRAM and used for subsequent rendering.</p><p>To minimize the risk of tearing we strive to have the largest margin between GRAM being updated by the Display Transfer and the Display Controller scanline. This is done be having the transferline behind the scanline, which means that we can only render the current frame and not begin rendering the next frame. Render time of the current frame depends on the number of partial blocks defined and the time it takes to transfer each block. This means that we are allowed to render a block that is ahead of the Display Controller scanline if a block is available. If rendering and transferring of all the dirty areas of the current frame takes longer than the Display Controller its scanline can wrap around and catch the transferline, resulting in tearing. This is caused by rendering complex UI components and/or transferring too many pixels.</p><div class="figure noshadow"><a href="/4.25/ko/img/basic-concepts/gram-partial.png" target="_blank"><img width="700" src="/4.25/ko/img/basic-concepts/gram-partial.png"></a><p>Partial Buffering Strategy Concept</p></div><h3 class="anchor anchorWithStickyNavbar_k1OW" id="framebuffer-strategy-getting-started">Getting Started with Framebuffer Strategies<a href="#framebuffer-strategy-getting-started" class="hash-link" aria-label="Getting Started with Framebuffer Strategies에 대한 다이렉트 링크" title="Getting Started with Framebuffer Strategies에 대한 다이렉트 링크">​</a></h3><p>In the following section we will show common hardware setups and point to scenarios on how to use framebuffer strategies on various hardware setups.</p><div class="highlight highlight-further-reading"><div class="highlight-heading"><h5><div class="highlight-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></div>Further reading</h5></div><div class="highlight-content">See article <a href="/4.25/ko/docs/development/touchgfx-hal-development/generator-how-to/touchgfx-al-configuration/display#buffering-strategies">Buffering Strategies &amp; Location</a> on how to configure a framebuffer strategy through the TouchGFX Generator.</div></div><h4 class="anchor anchorWithStickyNavbar_k1OW" id="displays-with-gram-getting-started">Displays with GRAM<a href="#displays-with-gram-getting-started" class="hash-link" aria-label="Displays with GRAM에 대한 다이렉트 링크" title="Displays with GRAM에 대한 다이렉트 링크">​</a></h4><p>This display type has a dedicated RAM buffer with the same size as the display, i.e. a full size framebuffer.</p><div class="figure noshadow"><a href="/4.25/ko/img/basic-concepts/display-with-gram.webp" target="_blank"><img width="700" src="/4.25/ko/img/basic-concepts/display-with-gram.webp"></a><p>Display with GRAM</p></div><p>The interfaces for this type of display are:</p><ul><li>FMC</li><li>SPI</li><li>DSI (Command Mode)</li></ul><p>Scenarios demonstrating the use of these interfaces can be found here:</p><ul><li><a href="/4.25/ko/docs/development/touchgfx-hal-development/scenarios/scenarios-fmc">FMC Display Interface</a></li><li><a href="/4.25/ko/docs/development/touchgfx-hal-development/scenarios/scenarios-spi">SPI Display Interface</a></li><li><a href="/4.25/ko/docs/development/touchgfx-hal-development/scenarios/scenarios-dsi-command-mode">DSI (Command Mode) Display Interface</a></li></ul><h4 class="anchor anchorWithStickyNavbar_k1OW" id="displays-without-gram-getting-started">Displays without GRAM<a href="#displays-without-gram-getting-started" class="hash-link" aria-label="Displays without GRAM에 대한 다이렉트 링크" title="Displays without GRAM에 대한 다이렉트 링크">​</a></h4><p>This display type doesn&#x27;t have a dedicated RAM buffer.</p><div class="figure noshadow"><a href="/4.25/ko/img/basic-concepts/display-without-gram.webp" target="_blank"><img width="600" src="/4.25/ko/img/basic-concepts/display-without-gram.webp"></a><p>Display without GRAM</p></div><p>The interfaces for this type of display are:</p><ul><li>LTDC</li><li>DSI (Video Mode)</li></ul><p>Scenarios demonstrating the use of these interfaces can be found here:</p><ul><li><a href="/4.25/ko/docs/development/touchgfx-hal-development/scenarios/scenarios-ltdc-parallel-rgb">LTDC Display Interface</a></li><li><a href="/4.25/ko/docs/development/touchgfx-hal-development/scenarios/scenarios-dsi-video-mode">MIPI-DSI Video Mode</a></li></ul><div class="highlight highlight-further-reading"><div class="highlight-heading"><h5><div class="highlight-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></div>Further reading</h5></div><div class="highlight-content">The <a href="https://www.st.com/content/ccc/resource/technical/document/application_note/group0/25/ca/f9/b4/ae/fc/4e/1e/DM00287603/files/DM00287603.pdf/jcr:content/translations/en.DM00287603.pdf" target="_blank" rel="noopener noreferrer">STM32 LTDC</a> display controller document has further details on framebuffers.</div></div></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="문서 페이지 탐색하기"><a class="pagination-nav__link pagination-nav__link--prev" href="/4.25/ko/docs/basic-concepts/color-formats"><div class="pagination-nav__sublabel">이전 페이지</div><div class="pagination-nav__label">색상 형식</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/4.25/ko/docs/basic-concepts/graphics-engine"><div class="pagination-nav__sublabel">다음 페이지</div><div class="pagination-nav__label">그래픽 엔진</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_cuXu thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#colors" class="table-of-contents__link toc-highlight">색상</a></li><li><a href="#display" class="table-of-contents__link toc-highlight">디스플레이</a></li><li><a href="#location-of-framebuffer" class="table-of-contents__link toc-highlight">프레임버퍼 위치</a><ul><li><a href="#internal-ram" class="table-of-contents__link toc-highlight">내부 RAM</a></li><li><a href="#external-ram" class="table-of-contents__link toc-highlight">외부 RAM</a></li><li><a href="#display-with-gram" class="table-of-contents__link toc-highlight">Display with GRAM</a></li></ul></li><li><a href="#memory-consumption" class="table-of-contents__link toc-highlight">메모리 사용</a></li><li><a href="#framebuffer-strategies" class="table-of-contents__link toc-highlight">Framebuffer Strategies</a><ul><li><a href="#tearing" class="table-of-contents__link toc-highlight">Tearing</a></li><li><a href="#framebuffer-strategy-performance" class="table-of-contents__link toc-highlight">UI Performance</a></li><li><a href="#framebuffer-strategies-glossary" class="table-of-contents__link toc-highlight">Glossary</a></li><li><a href="#display-without-gram-framebuffer-strategies" class="table-of-contents__link toc-highlight">Displays without GRAM</a></li><li><a href="#display-with-gram-framebuffer-strategies" class="table-of-contents__link toc-highlight">Displays with GRAM</a></li><li><a href="#framebuffer-strategy-getting-started" class="table-of-contents__link toc-highlight">Getting Started with Framebuffer Strategies</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="footer__copyright">All rights reserved © 2024 STMicroelectronics | <a href="https://www.st.com/content/st_com/en/common/terms-of-use.html">이용약관</a> | <a href="https://www.st.com/content/st_com/en/common/privacy-policy.html">개인정보보호정책</a> | <a href="/docs/miscellaneous/cookie-policy">쿠키정책</a> | <a href="https://app-de.onetrust.com/app/#/webform/2b87200d-4023-4588-9df7-ab0cdea1a67e">권리행사</a></div></div></div></footer></div></div>
<script src="/4.25/ko/assets/js/runtime~main.71a07306.js"></script>
<script src="/4.25/ko/assets/js/main.b265f188.js"></script>
</body>
</html>