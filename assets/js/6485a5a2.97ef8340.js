"use strict";(self.webpackChunktouchgfx_documentation=self.webpackChunktouchgfx_documentation||[]).push([[91813],{49613:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>u});var n=a(59496);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),m=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},p=function(e){var t=m(e.components);return n.createElement(l.Provider,{value:t},e.children)},h="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),h=m(a),d=r,u=h["".concat(l,".").concat(d)]||h[d]||c[d]||o;return a?n.createElement(u,s(s({ref:t},p),{},{components:a})):n.createElement(u,s({ref:t},p))}));function u(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=a.length,s=new Array(o);s[0]=d;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[h]="string"==typeof e?e:r,s[1]=i;for(var m=2;m<o;m++)s[m]=a[m];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},28128:(e,t,a)=>{a.d(t,{Z:()=>o});var n=a(59496);class r extends n.Component{render(){return n.createElement("div",{className:"code-header"},n.createElement("div",null,n.createElement("h5",null,this.props.children)))}}const o=r},89639:(e,t,a)=>{a.d(t,{Z:()=>o});var n=a(59496),r=a(7029);const o=function(e){const t=e.noShadow||!1,a=e.width,o=e.height,s=(0,r.Z)(e.imageSource);return t?n.createElement("div",{className:"figure noshadow"},n.createElement("a",{href:s,target:"_blank"},n.createElement("img",{width:a,height:o,src:s})),n.createElement("p",null,e.children)):n.createElement("div",{className:"figure"},n.createElement("a",{href:s,target:"_blank"},n.createElement("img",{width:a,height:o,src:s})),n.createElement("p",null,e.children))}},48753:(e,t,a)=>{a.d(t,{Z:()=>i});var n=a(59496),r=a(96151);const o=n.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},n.createElement("path",{fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}));class s extends n.Component{render(){return n.createElement(r.Z,{color:"var(--highlight-color-further-reading)",header:"Further reading",type:"further-reading",icon:o},this.props.children)}}const i=s},96151:(e,t,a)=>{a.d(t,{Z:()=>o});var n=a(59496);class r extends n.Component{render(){const e=`highlight highlight-${this.props.type}`;return n.createElement("div",{className:e},n.createElement("div",{className:"highlight-heading"},n.createElement("h5",null,n.createElement("div",{className:"highlight-icon"},this.props.icon),this.props.header)),n.createElement("div",{className:"highlight-content"},this.props.children))}}const o=r},31859:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>p,default:()=>g,frontMatter:()=>m,metadata:()=>h,toc:()=>d});a(59496);var n=a(49613),r=a(89639),o=a(48753),s=a(28128);function i(){return i=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var a=arguments[t];for(var n in a)Object.prototype.hasOwnProperty.call(a,n)&&(e[n]=a[n])}return e},i.apply(this,arguments)}function l(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}const m={id:"flash-limited-gui-development",title:"Flash-limited GUI development",slug:"/flash-limited"},p=void 0,h={unversionedId:"development/scenarios/flash-limited-gui-development",id:"development/scenarios/flash-limited-gui-development",title:"Flash-limited GUI development",description:"This article explains how to use TouchGFX to develop graphical user interfaces with low flash memory usage.",source:"@site/docs/development/scenarios/flash-limited-gui-development.mdx",sourceDirName:"development/scenarios",slug:"/flash-limited",permalink:"/4.25/docs/flash-limited",draft:!1,tags:[],version:"current",frontMatter:{id:"flash-limited-gui-development",title:"Flash-limited GUI development",slug:"/flash-limited"},sidebar:"docs",previous:{title:"Lowering Memory Usage with Partial Framebuffer",permalink:"/4.25/docs/development/scenarios/lowering-memory-usage-with-partial-framebuffer"},next:{title:"Using Non-Memory Mapped Flash for Storing Images",permalink:"/4.25/docs/development/scenarios/using-non-memory-mapped-flash"}},c={},d=[{value:"Flash-limited E-bike demo",id:"flash-limited-e-bike-demo",level:2},{value:"When to use which concept",id:"when-to-use-which-concept",level:2},{value:"L8 and compression",id:"L8-and-compression",level:3},{value:"SVG",id:"SVG",level:3},{value:"Vector Fonts",id:"vector-fonts",level:3},{value:"Examples",id:"examples",level:3},{value:"Conclusion",id:"concept-conclusion",level:3},{value:"Using &#39;&#39;smart&#39;&#39; assets",id:"smart-assets",level:2},{value:"Simple assets",id:"simple-assets",level:3},{value:"Using boxes",id:"using-boxes",level:3},{value:"Reusable assets",id:"reusable-assets",level:3},{value:"Improving performance",id:"performance",level:2},{value:"Conclusion",id:"conclusion",level:2}],u={toc:d},f="wrapper";function g(e){var{components:t}=e,a=l(e,["components"]);return(0,n.kt)(f,i({},u,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("p",null,"This article explains how to use TouchGFX to develop graphical user interfaces with low flash memory usage."),(0,n.kt)("p",null,"When generating code with TouchGFX, assets like images, texts and fonts are converted to C++ files,\nwhich are then stored in flash memory during programming\nalong with TouchGFX application code, user code and TouchGFX libraries.\nThis means that large or complex projects with many assets will result in high flash usage."),(0,n.kt)("p",null,"Since memory resources are limited in most applications,\nthere are ways to decrease the amount of flash memory needed.\nTouchGFX has four built-in features,\nwhich can help you decrease the flash memory needed for your application significantly.\nThe four concepts are L8 image format, image compression,\nscalable vector graphics (SVG) and vector fonts."),(0,n.kt)("p",null,"In this article we will now see how to utilize the four concepts\nto limit the flash memory footprint of an application.\nThe measurements were performed using an STM32U5G9J-DK2,\nbut the concepts to save flash can be applied to other hardware platforms as well."),(0,n.kt)(o.Z,{mdxType:"FurtherReading"},(0,n.kt)("p",null,"Read the ",(0,n.kt)("a",i({parentName:"p"},{href:"/4.25/docs/basic-concepts/memory-usage"}),"Memory Usage")," article for more information on memory management.")),(0,n.kt)("h2",i({},{id:"flash-limited-e-bike-demo"}),"Flash-limited E-bike demo"),(0,n.kt)("p",null,"A flash-limited E-bike demo, which demonstrates how to use the four features\nto save flash with TouchGFX can be found in TouchGFX Designer.\nThe demo is a board specific demo for STM32U5G9J-DK2.\nA benefit from using the STM32U5G9J-DK2 is that it has NeoChromVG GPU,\nwhich hardware accelerates vector rendering.\nHowever, especially L8 image format and image compression can be used across all STM32 MCUs."),(0,n.kt)("p",null,"If the demo was implemented with only uncompressed bitmaps\n(without L8, compression, SVG and vector fonts),\nit would take up approximately 10.5 MB of flash memory.\nIn the implementation, where the four concepts to save flash are used,\nthe demo only takes up approximately 800 KB of flash memory.\nAs seen from this, it is possible to save a substantial amount of flash.\nIn the demo, the four concepts combined gives a flash saving of 92%."),(0,n.kt)("h2",i({},{id:"when-to-use-which-concept"}),"When to use which concept"),(0,n.kt)("p",null,"Technical information and guides on how to use the four flash saving concepts with TouchGFX can be found here:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",i({parentName:"li"},{href:"/4.25/docs/development/ui-development/scenarios/using-the-l8-image-format-to-reduce-memory-consumption"}),"L8 Image Format")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",i({parentName:"li"},{href:"/4.25/docs/development/ui-development/touchgfx-engine-features/image-compression"}),"Image Compression")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",i({parentName:"li"},{href:"/4.25/docs/development/ui-development/touchgfx-engine-features/svg"}),"SVG")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",i({parentName:"li"},{href:"/4.25/docs/development/ui-development/touchgfx-engine-features/vector-fonts"}),"Vector Fonts"))),(0,n.kt)("p",null,"The four concepts can all help to decrease the amount of flash memory needed for an application.\nWhen to use which concept depends on the scenario,\nbut some general rules can be applied. We will now go through these."),(0,n.kt)("h3",i({},{id:"L8-and-compression"}),"L8 and compression"),(0,n.kt)("p",null,"When using L8 image format on a bitmap, the bitmap can have a maximum of 256 colors.\nThe rendering of assets in L8 format is hardware accelerated with\n",(0,n.kt)("a",i({parentName:"p"},{href:"/4.25/docs/development/hardware-selection/hardware-components/hardware-selection-mcu#chrom-art"}),"Chrom-ART"),",\nmeaning that the render time for L8 bitmaps are almost the same as for regular bitmaps.\nSometimes it is even faster to render a bitmap in L8 format compared to a regular bitmap,\nsince less data is read from the flash memory.\nL8 can save you more than 70% of flash compared to a regular bitmap with a color depth of 32-bits. "),(0,n.kt)("p",null,"Image compression can help you to save even more flash compared to L8.\nImage compression comes in two formats: L8 compression and RGB compression.\nTo use L8 compression on a bitmap, the bitmap needs to be in L8 format first,\nsince the L8 compression algorithms use the color look-up table.\nAs a result of this, L8 compressed bitmaps are still limited to a maximum of 256 colors.\nSome of the L8 compression algorithms have further limitations on the maximum number of colors.\nL4 is limited to a maximum of 16 colors and L8 RLE is limited to a maximum of 64 colors.\nRGB compression doesn't require the bitmap to be in L8 format and can hence be used on all bitmaps.\nOpposed to rendering of L8 bitmaps, which are hardware accelerated with Chrom-ART,\ncompressed bitmaps (both L8- and RGB compressed) are software rendered and are hence more expensive to render.\nOne further limitation of compressed bitmaps is that they can't be used in scalable or rotatable widgets. "),(0,n.kt)("p",null,"Both L8 image format and image compression are easy to use, if you already have your assets in PNG-format.\nIn general you could always use L8 image format on bitmaps with\nmaximum 256 colors without any significant performance penalty.\nIf you need to save even more flash and have available render time to achieve the required performance,\nyou could use L8 image compression as well.\nIf you want to compress bitmaps that are not compatible with L8 format, you can use RGB compression instead.\nIf you need to use your bitmap in scalable or rotatable widgets,\nyou can't use compressed bitmaps natively.\nThere are of course ways around this, which we will briefly cover later."),(0,n.kt)("h3",i({},{id:"SVG"}),"SVG"),(0,n.kt)("p",null,"Another option to save flash on assets is to have them in SVG-format instead of PNG-format.\nSVGs has no limitation on the number of colors.\nHowever, SVGs are usually more costly to render compared to L8 and compression.\nTherefore, it is recommended to limit the number of concurrent SVGs\nand to keep animations with SVGs to a minimum.\nThe simpler your SVG assets are,\nthe smaller the resulting flash footprint will be and the better performance can be achieved.\nIn line with this, it is recommended to only use one-layer SVGs."),(0,n.kt)("p",null,"To use an asset in an SVG widget, you need to import the asset in SVG-format.\nThe assets can't be converted by TouchGFX."),(0,n.kt)("h3",i({},{id:"vector-fonts"}),"Vector Fonts"),(0,n.kt)("p",null,"As for non-font assets in SVG-format, Vector Fonts are also expensive to render,\nsince it is rendered in the same way as SVGs.\nVector Fonts are generally beneficial to use for large\nfont sizes or if the same font is used in several different sizes.\nIf you have the same font in different sizes and vector representation, it is only needed to store the font once.\nThen, only a scaling factor is needed to represent it in different sizes.\nFor bitmap fonts each of the font sizes needs to be stored separately.\nVector Fonts will often not yield as big a flash saving as image compression and SVG.\nTherefore, it should mainly be used, if it is necessary to limit the flash memory footprint to the absolute minimum. "),(0,n.kt)("h3",i({},{id:"examples"}),"Examples"),(0,n.kt)("p",null,"To provide specific examples of the characteristics of the different concepts,\nmeasurements are performed on two assets from the E-bike demo in regular bitmap, L8, L8 RLE compressed, RGB compressed and SVG-format.\nThe measurements are performed on the STM32U5G9J-DK2 with assets in internal flash.\nThe render time of SVG will be longer for MCUs not having NeoChrom GPU.\nHowever, a faster CPU could also compensate for this. "),(0,n.kt)("p",null,"The asset below has a color depth of 32-bits and is a button with an icon on top. The button is 122 x 112 px and the icon is 72 x 72 px."),(0,n.kt)(r.Z,{imageSource:"/img/development/scenarios/flash-limited-gui-development/button-with-icon.webp",mdxType:"Figure"},"Button with icon from E-bike demo"),(0,n.kt)("p",null,"The following measurements are performed on the asset:"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",i({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"th"},"Format")),(0,n.kt)("th",i({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"th"},"Size")),(0,n.kt)("th",i({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"th"},"Pct.")),(0,n.kt)("th",i({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"th"},"Render time")),(0,n.kt)("th",i({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"th"},"CPU load")))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Bitmap:"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"75.4 KB"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"100%"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"0.414 ms"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"2.4%")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"L8:"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"19.3 KB"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"25.6%"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"0.448 ms"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"2.3%")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"L8 RLE:"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"2.55 KB"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"3.4%"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"1.51 ms"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"9.6%")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"RGB:"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"4.53 KB"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"12.0%"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"1.65 ms"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"10.5%")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"SVG:"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"3.01 KB"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"4.0%"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"1.43 ms"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"4.1%")))),(0,n.kt)("p",null,"As seen from this, L8 RLE has the lowest flash footprint, but takes approximately 1 ms longer to render compared to regular bitmap format."),(0,n.kt)("p",null,"The asset below has a color depth of 32-bits and is a part of the gauge in the dashboard screen in the demo. It is 150 x 436 px."),(0,n.kt)(r.Z,{imageSource:"/img/development/scenarios/flash-limited-gui-development/gauge-part.webp",mdxType:"Figure"},"Part of gauge from E-bike demo"),(0,n.kt)("p",null,"The following measurements are performed on the asset:"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",i({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"th"},"Format")),(0,n.kt)("th",i({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"th"},"Size")),(0,n.kt)("th",i({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"th"},"Pct.")),(0,n.kt)("th",i({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"th"},"Render time")),(0,n.kt)("th",i({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"th"},"CPU load")))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Bitmap:"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"261.6 KB"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"100%"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"1.15 ms"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"1.5%")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"L8:"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"65.6 KB"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"25.1%"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"1.24 ms"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"1.4%")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"L8 RLE:"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"4.66 KB"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"1.78%"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"2.75 ms"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"15.0%")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"RGB:"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"10.5 KB"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"4.01%"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"3.08 ms"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"17.6%")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"SVG:"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"0.686 KB"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"0.27%"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"3.40 ms"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"2.0%")))),(0,n.kt)("p",null,"The asset in SVG-format has the by far lowest flash footprint, but is also the most expensive to render."),(0,n.kt)("h3",i({},{id:"concept-conclusion"}),"Conclusion"),(0,n.kt)("p",null,"As seen above, none of the formats are best for all assets.\nHowever, for flash saving alone, L8 image compression generally has the smallest flash footprint when the asset is relatively small, and\nSVG has the smallest flash footprint when the asset is larger.\nEven though SVG assets can have more than 256 colors,\nit is still recommended to keep SVG assets relatively simple for both flash memory usage and performance considerations.\nL8 image format has the highest flash footprint among L8, image compression and SVG, but L8 has the lowest render time. "),(0,n.kt)("p",null,"Therefore, when developing a flash-limited application, you need to identify the bottleneck and determine what matters most for you application.\nIs it performance or flash memory savings?\nIf it is performance, L8 will be the most efficient approach.\nIt could even be combined with compression for some assets if performance allows it.\nIf it is most important to have the smallest possible flash footprint,\nimage compression and SVG will be the best approach."),(0,n.kt)("h2",i({},{id:"smart-assets"}),"Using ''smart'' assets"),(0,n.kt)("p",null,"Both flash savings and performance can be improved by using ''smart'' assets.\nHere, smart assets both refer to the assets themselves and their usage."),(0,n.kt)("h3",i({},{id:"simple-assets"}),"Simple assets"),(0,n.kt)("p",null,"First of all, the simpler the assets are, the more they can be compressed\nand the simpler the SVG definitions will be as well.\nThis will in the end result in a smaller flash footprint. "),(0,n.kt)("p",null,"As a reference, in the E-bike demo all bitmap assets have a maximum of 64 colors\nand since the assets are also well-suited for L8 RLE, all the bitmap assets are L8 RLE compressed.\nSince L8 RLE is faster to render compared to L8 LZW9, this also gives the best performance. "),(0,n.kt)("p",null,"Additionally, if the design is also simple, you can in some cases use a ",(0,n.kt)("a",i({parentName:"p"},{href:"/4.25/docs/development/ui-development/ui-components/images/tiled-image"}),"Tiled Image")," as well.\nThen you only need to store a part of the image, which can then be repeated."),(0,n.kt)("h3",i({},{id:"using-boxes"}),"Using boxes"),(0,n.kt)("p",null,"Another way of saving flash memory in a smart way is to use the ",(0,n.kt)("a",i({parentName:"p"},{href:"/4.25/docs/development/ui-development/ui-components/shapes/box"}),"Box widget"),".\nUsing boxes has two main benefits:"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},"Firstly, the box will be drawn directly in the framebuffer.\nAs a result of this, no flash memory is needed to store the box.\nThe only flash impact will be from the small amount of code needed to define the box. "),(0,n.kt)("li",{parentName:"ol"},"Secondly, boxes are adaptable and it is possible to change both color and size at runtime.\nIn the flash-limited E-bike demo, boxes have been used for e.g. solid background colors\nto support both light- and dark mode by changing the color of the box.")),(0,n.kt)("h3",i({},{id:"reusable-assets"}),"Reusable assets"),(0,n.kt)("p",null,"Another way to save flash memory is to limit the total number of assets.\nThis can of course be achieved by having a very simple design,\nbut it is sometimes also possible to limit the existing number of assets by reusing the same asset multiple times."),(0,n.kt)("p",null,"In the flash-limited E-bike demo, this approach is, for example, used in the weather screens.\nThe weather icons are the same asset that is scaled to fit all 3 sizes.\nSince it is a scaled asset, SVG format is preferred over compression even though the flash footprint is smaller with RLE.\nHowever, the total flash footprint would be bigger if the asset was stored in RLE format in all 3 sizes. "),(0,n.kt)("p",null,"Additionally, the buttons are also implemented as a reusable asset.\nFor example, the buttons are separated from their icons to allow it to be reused. "),(0,n.kt)("p",null,"Another case where reusability is used in the demo is with the background.\nThere are a total of 5 different background designs in the demo,\nbut by using adaptable assets (boxes and reuseable assets), all the backgrounds are created with just one asset and a box."),(0,n.kt)("h2",i({},{id:"performance"}),"Improving performance"),(0,n.kt)("p",null,"When developing a flash-limited application there is a risk of hurting performance.\nHowever, if spare RAM is available, there are ways to improve the performance of the application.\nBy using ",(0,n.kt)("a",i({parentName:"p"},{href:"/4.25/docs/development/ui-development/touchgfx-engine-features/dynamic-bitmaps"}),"Dynamic Bitmaps")," and\n",(0,n.kt)("a",i({parentName:"p"},{href:"/4.25/docs/development/ui-development/scenarios/achieving-better-performance-with-cacheable-container"}),"Cacheable Containers"),",\nit is possible to draw static snapshots of assets or containers to RAM.\nThen, whenever using the asset or container, the cached version can be used instead.\nThe cached version is just a bitmap in RAM,\nwhich means that the render time is identical to rendering regular bitmaps."),(0,n.kt)("p",null,"In the flash-limited E-bike demo, cachable containers are used to allow\nscrolling of SVG assets and vector fonts, while keeping a good performance."),(0,n.kt)(r.Z,{imageSource:"/img/development/scenarios/flash-limited-gui-development/cacheable-container.webp",width:"500",mdxType:"Figure"},"Weather element as cacheable container"),(0,n.kt)("p",null,"In general vector fonts are cached whenever they are moved or movable on runtime.\nThis ensures a minimum of 30 FPS despite scrolling vector fonts. "),(0,n.kt)("p",null,"Another trick used in the demo is decompression of compressed bitmaps to the bitmap cache.\nBy decompressing the bitmaps to RAM, it is possible to use them in scalable and rotatable widgets.\nWhen a bitmap is decompressed, TouchGFX will always use the decompressed cached version when referring to the bitmap ID.\nAn example from the E-bike demo is seen below.\nThe compressed bitmaps are simply decompressed and after this the bitmaps can be used just as regular bitmaps."),(0,n.kt)(s.Z,{mdxType:"CodeHeader"},"StartView.cpp"),(0,n.kt)("pre",null,(0,n.kt)("code",i({parentName:"pre"},{className:"language-cpp",metastring:"{21-25}","{21-25}":!0}),"StartView::StartView()\n{\n    Bitmap::decompress(BITMAP_MAIN_RIPPLE_LEFT_ID);     // Decompress compressed image to bitmap cache\n    Bitmap::decompress(BITMAP_MAIN_RIPPLE_RIGHT_ID);    // Decompress compressed image to bitmap cache\n}\n\nvoid StartView::setupScreen()\n{\n    leftMainRippleScale.setBitmap(BITMAP_MAIN_RIPPLE_LEFT_ID);      // Set bitmap for Scalable Image\n    rightMainRippleScale.setBitmap(BITMAP_MAIN_RIPPLE_RIGHT_ID);    // Set bitmap for Scalable Image\n    leftMainRippleScale.setWidthHeight(0, 0);       // Set scale of image\n    rightMainRippleScale.setWidthHeight(0, 0);      // Set scale of image\n}\n")),(0,n.kt)("p",null,"As a result of extensive use of dynamic bitmaps, the flash-limited E-bike demo requires a bitmap cache of 922 KB.\nThis means that a lot of spare RAM is required.\nHowever, the demo also takes the flash saving to a quite extreme extent.\nIn a more simple application or an application where performance requirements isn't that important,\nit would be possible to get away with a much smaller bitmap cache. "),(0,n.kt)(o.Z,{mdxType:"FurtherReading"},(0,n.kt)("p",null,(0,n.kt)("a",i({parentName:"p"},{href:"/4.25/docs/development/ui-development/touchgfx-engine-features/dynamic-bitmaps"}),"Dynamic Bitmaps")),(0,n.kt)("p",null,(0,n.kt)("a",i({parentName:"p"},{href:"/4.25/docs/development/ui-development/scenarios/achieving-better-performance-with-cacheable-container"}),"Achieving Better Performance with Cacheable Container")),(0,n.kt)("p",null,(0,n.kt)("a",i({parentName:"p"},{href:"/4.25/docs/development/ui-development/touchgfx-engine-features/image-compression"}),"Decompressing images to the bitmap cache"))),(0,n.kt)("h2",i({},{id:"conclusion"}),"Conclusion"),(0,n.kt)("p",null,"In this article we saw how to limit the flash usage of a TouchGFX application."),(0,n.kt)("p",null,"The 4 flash saving concepts can be used across all STM32 hardware platforms,\nbut keep in mind that SVGs and vector fonts are expensive to render.\nAs a result of this, performance can decrease if no hardware acceleration of\nvector rendering or extra computing power is available."),(0,n.kt)("p",null,"The concepts for flash-limited GUI development can result in a performance penalty,\nbut it is possible to improve the performance by using dynamic bitmaps and cacheable containers."),(0,n.kt)("p",null,"By using the flash saving concepts there is a huge potential for saving flash.\nThe exact amount of flash, the concepts can save, will depend on the specific application,\nbut for the flash-limited E-bike demo, a flash saving of 92% is achieved."))}g.isMDXComponent=!0}}]);