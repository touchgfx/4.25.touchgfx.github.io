"use strict";(self.webpackChunktouchgfx_documentation=self.webpackChunktouchgfx_documentation||[]).push([[8515],{49613:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var i=n(59496);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,i,o=function(e,t){if(null==e)return{};var n,i,o={},a=Object.keys(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=i.createContext({}),h=function(e){var t=i.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},c=function(e){var t=h(e.components);return i.createElement(s.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},d=i.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,s=e.parentName,c=r(e,["components","mdxType","originalType","parentName"]),p=h(n),d=o,m=p["".concat(s,".").concat(d)]||p[d]||u[d]||a;return n?i.createElement(m,l(l({ref:t},c),{},{components:n})):i.createElement(m,l({ref:t},c))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,l=new Array(a);l[0]=d;var r={};for(var s in t)hasOwnProperty.call(t,s)&&(r[s]=t[s]);r.originalType=e,r[p]="string"==typeof e?e:o,l[1]=r;for(var h=2;h<a;h++)l[h]=n[h];return i.createElement.apply(null,l)}return i.createElement.apply(null,n)}d.displayName="MDXCreateElement"},96151:(e,t,n)=>{n.d(t,{Z:()=>a});var i=n(59496);class o extends i.Component{render(){const e=`highlight highlight-${this.props.type}`;return i.createElement("div",{className:e},i.createElement("div",{className:"highlight-heading"},i.createElement("h5",null,i.createElement("div",{className:"highlight-icon"},this.props.icon),this.props.header)),i.createElement("div",{className:"highlight-content"},this.props.children))}}const a=o},49018:(e,t,n)=>{n.d(t,{Z:()=>r});var i=n(59496),o=n(96151);const a=i.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},i.createElement("path",{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}));class l extends i.Component{render(){return i.createElement(o.Z,{color:"var(--highlight-color-note)",header:"Note",type:"note",icon:a},this.props.children)}}const r=l},52956:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>h,default:()=>f,frontMatter:()=>s,metadata:()=>c,toc:()=>u});n(59496);var i=n(49613),o=n(18399),a=n(49018);function l(){return l=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var i in n)Object.prototype.hasOwnProperty.call(n,i)&&(e[i]=n[i])}return e},l.apply(this,arguments)}function r(e,t){if(null==e)return{};var n,i,o=function(e,t){if(null==e)return{};var n,i,o={},a=Object.keys(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}const s={id:"compiling-and-flashing",title:"Compiling & Flashing"},h=void 0,c={unversionedId:"development/ui-development/working-with-touchgfx/compiling-and-flashing",id:"development/ui-development/working-with-touchgfx/compiling-and-flashing",title:"Compiling & Flashing",description:"This section describes how to go from TouchGFX application code to executing program, that is how to compile and flash in a specific setup.",source:"@site/docs/development/ui-development/working-with-touchgfx/compiling-and-flashing.mdx",sourceDirName:"development/ui-development/working-with-touchgfx",slug:"/development/ui-development/working-with-touchgfx/compiling-and-flashing",permalink:"/4.25/docs/development/ui-development/working-with-touchgfx/compiling-and-flashing",draft:!1,tags:[],version:"current",frontMatter:{id:"compiling-and-flashing",title:"Compiling & Flashing"},sidebar:"docs",previous:{title:"Simulator",permalink:"/4.25/docs/development/ui-development/working-with-touchgfx/simulator"},next:{title:"Debugging",permalink:"/4.25/docs/development/ui-development/working-with-touchgfx/debugging"}},p={},u=[{value:"Compiling TouchGFX Applications",id:"compiling-touchgfx-applications",level:2},{value:"Compiling for PC Simulator",id:"compiling-for-pc-simulator",level:3},{value:"GCC",id:"gcc",level:4},{value:"Visual Studio",id:"visual-studio",level:4},{value:"Compiling for Target Hardware",id:"compiling-for-target-hardware",level:3},{value:"Flashing STM32 Evaluation Kits",id:"flashing-stm32-evaluation-kits",level:2},{value:"GCC &amp; TouchGFX Designer",id:"gcc--touchgfx-designer",level:3},{value:"Flashing the internal flash only",id:"flash-internal",level:3},{value:"Linker script",id:"linker-script",level:4},{value:"TouchGFX Designer Configuration",id:"designer-configuration",level:3},{value:"STM32CubeIDE",id:"stm32cubeide",level:3},{value:"IAR",id:"iar",level:3},{value:"Keil",id:"keil",level:3},{value:"Flashing Custom Hardware",id:"flashing-custom-hardware",level:2}],d={toc:u},m="wrapper";function f(e){var{components:t}=e,n=r(e,["components"]);return(0,i.kt)(m,l({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This section describes how to go from TouchGFX application code to executing program, that is how to compile and flash in a specific setup."),(0,i.kt)("h2",l({},{id:"compiling-touchgfx-applications"}),"Compiling TouchGFX Applications"),(0,i.kt)("p",null,"When compiling a TouchGFX application, there are two options; compiling for the PC simulator or compiling for the target hardware."),(0,i.kt)("h3",l({},{id:"compiling-for-pc-simulator"}),"Compiling for PC Simulator"),(0,i.kt)("p",null,"There are two options for compiling projects for the PC Simulator; GCC and Visual Studio. ",(0,i.kt)("br",null),"\nBoth of these options are always available, since they are generated by TouchGFX Designer."),(0,i.kt)("h4",l({},{id:"gcc"}),"GCC"),(0,i.kt)("p",null,"The makefile is located at ",(0,i.kt)("inlineCode",{parentName:"p"},"<touchgfx_application_root_folder>/simulator/gcc/Makefile")),(0,i.kt)("p",null,"TouchGFX includes a MinGW environment, that comes preinstalled with a GCC compiler and GNU Make, making it easy to execute the generated Makefile for the PC simulator."),(0,i.kt)("p",null,"The TouchGFX Environment can be launched either from ",(0,i.kt)("inlineCode",{parentName:"p"},"C:/TouchGFX/4.18.0/env/MinGW/msys/1.0/msys.bat"),' or from the shortcut added to the Windows start menu, named "TouchGFX x.y.z Environment" where x, y and z describe the version number.'),(0,i.kt)("p",null,"After launching the TouchGFX Environment and navigating to the TouchGFX Application root folder, the simple command below can be executed to produce a simulator.exe file."),(0,i.kt)("pre",null,(0,i.kt)("code",l({parentName:"pre"},{}),"make -f simulator/gcc/Makefile\n")),(0,i.kt)("p",null,"The simulator executable can then be launched from the TouchGFX Environment with the following command."),(0,i.kt)("pre",null,(0,i.kt)("code",l({parentName:"pre"},{}),"./build/bin/simulator.exe\n")),(0,i.kt)("p",null,"The PC Simulator can also be compiled and launched from TouchGFX Designer, by using the ",(0,i.kt)("a",l({parentName:"p"},{href:"../designer-user-guide/main-window#run-simulator"}),"Run Simulator")," command."),(0,i.kt)("h4",l({},{id:"visual-studio"}),"Visual Studio"),(0,i.kt)("p",null,"To compile the PC Simulator using Visual Studio, simply open the generated solution file located at ",(0,i.kt)("inlineCode",{parentName:"p"},"<touchgfx_application_root_folder>/simulator/msvs/Application.sln")," using Visual Studio."),(0,i.kt)("p",null,"The PC Simulator can be launched directly from Visual Studio, enabling ",(0,i.kt)("a",l({parentName:"p"},{href:"debugging"}),"code debugging"),"."),(0,i.kt)(a.Z,{mdxType:"Note"},"Before being able to compile with GCC or Visual Studio, Run the ",(0,i.kt)(o.Z,{to:"../designer-user-guide/main-window#generate-code",mdxType:"Link"},"Generate")," command from TouchGFX Designer."),(0,i.kt)("h3",l({},{id:"compiling-for-target-hardware"}),"Compiling for Target Hardware"),(0,i.kt)("p",null,"Compiling projects for STM32 Evaluation Kits is quite simple for ",(0,i.kt)("a",l({parentName:"p"},{href:"../../../introduction/getting-started#application-template--ui-template"}),"TouchGFX Board Setup")," based applications.",(0,i.kt)("br",null)),(0,i.kt)("p",null,"Each TouchGFX Board Setup contains project files for GCC, STM32CubeIDE, IAR and Keil:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"GCC: ",(0,i.kt)("inlineCode",{parentName:"li"},"<project_root_folder>/gcc/MakeFile")),(0,i.kt)("li",{parentName:"ul"},"STM32CubeIDE: ",(0,i.kt)("inlineCode",{parentName:"li"},"<project_root_folder>/STM32CubeIDE/.cproject")),(0,i.kt)("li",{parentName:"ul"},"IAR: ",(0,i.kt)("inlineCode",{parentName:"li"},"<project_root_folder>/EWARM/Project.eww")),(0,i.kt)("li",{parentName:"ul"},"Keil: ",(0,i.kt)("inlineCode",{parentName:"li"},"<project_root_folder>/MDK-ARM/<STM32_evaluation_kit_name>.uvprojx"))),(0,i.kt)("p",null,"The active tool chain is set from STM32CubeMX and is set to STM32CubeIDE by default. ",(0,i.kt)("em",{parentName:"p"},"Please note that all project files are not present at the same time. The generated project file depends on the selected tool chain in STM32CubeMX")),(0,i.kt)("p",null,"TouchGFX includes a MinGW environment, that comes preinstalled with the GNU Embedded tool-chain for Arm and GNU Make, making it easy to execute the included Makefile for the target hardware."),(0,i.kt)("p",null,"The TouchGFX Environment can be launched either from ",(0,i.kt)("inlineCode",{parentName:"p"},"C:/TouchGFX/4.18.0/env/MinGW/msys/1.0/msys.bat"),' or from the shortcut added to the Windows start menu "TouchGFX x.y.z Environment"'),(0,i.kt)("p",null,"After launching the TouchGFX Environment and navigating to the project root folder, the simple command below can be executed to compile the project for the target hardware."),(0,i.kt)("pre",null,(0,i.kt)("code",l({parentName:"pre"},{}),"make -f gcc/Makefile\n")),(0,i.kt)(a.Z,{mdxType:"Note"},"Before being able to compile with GCC, STM32CubeIDE, IAR or Keil, run the ",(0,i.kt)(o.Z,{to:"../designer-user-guide/main-window#generate-code",mdxType:"Link"},"Generate")," command from TouchGFX Designer."),(0,i.kt)("h2",l({},{id:"flashing-stm32-evaluation-kits"}),"Flashing STM32 Evaluation Kits"),(0,i.kt)("p",null,"Flashing projects to STM32 Evaluation Kits is quite simple with projects based on a premade ",(0,i.kt)("a",l({parentName:"p"},{href:"../../../introduction/getting-started#application-template--ui-template"}),"TouchGFX Board Setup"),".",(0,i.kt)("br",null)),(0,i.kt)("p",null,"Each project, when built, produces a binary that can be flashed by\neither ",(0,i.kt)("a",l({parentName:"p"},{href:"https://www.st.com/en/development-tools/stsw-link004.html"}),"ST Link Utility")," or ",(0,i.kt)("a",l({parentName:"p"},{href:"https://www.st.com/en/development-tools/stm32cubeprog.html"}),"STM32CubeProgrammer"),"."),(0,i.kt)("p",null,"Therefore these tools must be installed to proceed with flashing."),(0,i.kt)("p",null,"It is suggested to install these tools to their default location."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"ST Link Utility default install location:",(0,i.kt)("br",null),(0,i.kt)("inlineCode",{parentName:"li"},"C:/Program Files (x86)/STMicroelectronics/STM32 ST-LINK Utility/ST-LINK Utility")),(0,i.kt)("li",{parentName:"ul"},"STM32CubeProgrammer default install location:",(0,i.kt)("br",null),(0,i.kt)("inlineCode",{parentName:"li"},"C:/Program Files/STMicroelectronics/STM32Cube/STM32CubeProgrammer"))),(0,i.kt)(a.Z,{mdxType:"Note"},"The TouchGFX Board Setups do not provide any flash loaders for flashing directly from within IAR, Keil, STM32CubeIDE or other IDEs."),(0,i.kt)("h3",l({},{id:"gcc--touchgfx-designer"}),"GCC & TouchGFX Designer"),(0,i.kt)("p",null,"The Makefile included with an TouchGFX Board Setup located at ",(0,i.kt)("inlineCode",{parentName:"p"},"<project_root_folder>/gcc/MakeFile")," has a built-in flash command, as shown below, that uses either ST Link Utility or STM32CubeProgrammer (depending on the TBS) to flash the STM32 Evaluation Kit."),(0,i.kt)("p",null,"You can start the flashing from the command-line using the same command\nas TouchGFX Designer uses:"),(0,i.kt)("pre",null,(0,i.kt)("code",l({parentName:"pre"},{}),"make -f gcc/Makefile flash\n")),(0,i.kt)("p",null,"You can also use the desktop version of the flash tools to\nflash the boards with the generated .hex files. The .hex file is\nlocated at ",(0,i.kt)("inlineCode",{parentName:"p"},"<project_root_folder>/TouchGFX/build/bin/target.hex")),(0,i.kt)("h3",l({},{id:"flash-internal"}),"Flashing the internal flash only"),(0,i.kt)("p",null,"Many development boards and products use two flashes. The internal\nflash of the micro controller and an external flash. Typically, the\ninternal flash contains the code and small/often used data, whereas\nthe external flash contains large data items like images, videos and\nfonts."),(0,i.kt)("p",null,"In many situations, you need to flash both flashes at the same time as\nthe program in the internal flash contains addresses pointing to the\ndata in the external flash. But in some cases it is possible to flash\nthe internal flash without flashing the external flash, for example\nwhen you have made small modifications to the application code (like\nchanging the color or position of a Box). In this case, all the data in\nthe external flash is unmodified and there is no need to flash it again.\nThis can reduce the flash time considerably if you have a large set of\nimages."),(0,i.kt)("p",null,"However, you need to be sure that the content for the external flash\nhas not changed since you wrote the external flash last time. If it\nhas, and you do not flash it again, you will see strange behavior. In\nthis case: flash both the internal and external flash."),(0,i.kt)("pre",null,(0,i.kt)("code",l({parentName:"pre"},{}),"make -f gcc/Makefile intflash\n")),(0,i.kt)("p",null,"The .hex file for the internal flash is located at:\n",(0,i.kt)("inlineCode",{parentName:"p"},"<project_root_folder>/TouchGFX/build/bin/intflash.hex"),"."),(0,i.kt)("h4",l({},{id:"linker-script"}),"Linker script"),(0,i.kt)("p",null,"The intflash make target first compiles and links the application. It\nthen flashes the ",(0,i.kt)("inlineCode",{parentName:"p"},"intflash.hex")," file. This file is produced after the\nlinking step by removing the ",(0,i.kt)("inlineCode",{parentName:"p"},"ExternalFlashSection"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"TextFlashSection"),",\nand ",(0,i.kt)("inlineCode",{parentName:"p"},"FontFlashSection")," sections from the application ",(0,i.kt)("inlineCode",{parentName:"p"},"elf")," file. This is\ndone using the following command:"),(0,i.kt)("pre",null,(0,i.kt)("code",l({parentName:"pre"},{}),"arm-none-eabi-objcopy -O ihex --remove-section=ExtFlashSection --remove-section=FontFlashSection --remove-section=TextFlashSection target.elf intflash.hex\n")),(0,i.kt)("p",null,"The result of this command is a hex-file containing only the data that\nis located in the internal flash. This will only work if the linker\nscript only puts the three aforementioned sections into the external\nflash. The gcc linker script for the TouchGFX Board Setups typically\nlooks like:"),(0,i.kt)("pre",null,(0,i.kt)("code",l({parentName:"pre"},{}),"...  /* Details skipped */\n\nMEMORY\n{\nRAM (xrw)      : ORIGIN = 0x20000000, LENGTH = 320K\nFLASH (rx)     : ORIGIN = 0x8000000, LENGTH = 1024K\nQUADSPI (r)    : ORIGIN = 0x90000000, LENGTH = 16M\nSDRAM   (xrw)  : ORIGIN = 0xC0000000,  LENGTH = 8M\n}\n\nSECTIONS\n{\n  ... /* Sections for RAM, Flash, SDRAM */\n\n  ExtFlashSection :\n  {\n      *(ExtFlashSection ExtFlashSection.*)\n      *(.gnu.linkonce.r.*)\n      . = ALIGN(0x4);\n  } >QUADSPI\n\n  FontFlashSection :\n  {\n      *(FontFlashSection FontFlashSection.*)\n      *(.gnu.linkonce.r.*)\n      . = ALIGN(0x4);\n  } >QUADSPI\n\n  TextFlashSection :\n  {\n      *(TextFlashSection TextFlashSection.*)\n      *(.gnu.linkonce.r.*)\n      . = ALIGN(0x4);\n  } >QUADSPI\n}\n")),(0,i.kt)("p",null,"The linker script first defines 4 memory regions: ",(0,i.kt)("inlineCode",{parentName:"p"},"RAM"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"FLASH"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"QUADSPI"),",\nand ",(0,i.kt)("inlineCode",{parentName:"p"},"SDRAM"),". The ",(0,i.kt)("inlineCode",{parentName:"p"},"QUADSPI")," region is the external flash. The 3 sections\n",(0,i.kt)("inlineCode",{parentName:"p"},"ExtFlashSection"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"FontFlashSection"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"TextFlashSections")," are linked\ninto the ",(0,i.kt)("inlineCode",{parentName:"p"},"QUADSPI")," region. Nothing else is put into the ",(0,i.kt)("inlineCode",{parentName:"p"},"QUADSPI"),"\nregion. This is the reason that we can produce a hex file for the internal\nflash by removing these 3 section from the ",(0,i.kt)("inlineCode",{parentName:"p"},"target.elf")," file, which\ncontains everything. If the linker script also puts other data into the\nexternal flash, we would need to remove that data also to end up with\nthe internal flash content only."),(0,i.kt)("p",null,"If you build your target ",(0,i.kt)("inlineCode",{parentName:"p"},"elf")," file using other makefiles or compilers,\nyou can reuse the technique above to create a hex file for the\ninternal flash and flash it from TouchGFX Designer or the command-line."),(0,i.kt)("h3",l({},{id:"designer-configuration"}),"TouchGFX Designer Configuration"),(0,i.kt)("p",null,"The TouchGFX Board Setup provides the configuration for TouchGFX Designer to be able to flash projects via the ",(0,i.kt)("a",l({parentName:"p"},{href:"../designer-user-guide/main-window#run-target"}),"Run Target Command"),". The command used by TouchGFX Designer to flash can be seen and overridden in the ",(0,i.kt)("a",l({parentName:"p"},{href:"../designer-user-guide/config-view#build"}),"Build Section")," of the ",(0,i.kt)("a",l({parentName:"p"},{href:"../designer-user-guide/config-view"}),"Config View")," in TouchGFX Designer."),(0,i.kt)("h3",l({},{id:"stm32cubeide"}),"STM32CubeIDE"),(0,i.kt)("p",null,"TouchGFX Board Setups provide support for flashing project compiled with STM32CubeIDE, by using the .elf file output by STM32CubeIDE, with the STM32CubeProgrammer."),(0,i.kt)("p",null,"The .elf file is located at ",(0,i.kt)("inlineCode",{parentName:"p"},"<project_root_folder>/STM32CubeIDE/Debug/<STM32_evaluation_kit_name>.elf")),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"e.g. C:/TouchGFXProjects/MyApplication/STM32CubeIDE/Debug/STM32F746G_DISCO.elf")),(0,i.kt)("h3",l({},{id:"iar"}),"IAR"),(0,i.kt)("p",null,"The TouchGFX Board Setups provide support for flashing project compiled with IAR, by using the .hex file output by IAR, with the STM32CubeProgrammer."),(0,i.kt)("p",null,"The .hex file is located at ",(0,i.kt)("inlineCode",{parentName:"p"},"<project_root_folder>/EWARM/<STM32_evaluation_kit_name>/Exe/<STM32_evaluation_kit_name>.hex")),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"e.g. C:/TouchGFXProjects/MyApplication/EWARM/STM32F469I-DISCO/STM32F469I-DISCO.hex")),(0,i.kt)("h3",l({},{id:"keil"}),"Keil"),(0,i.kt)("p",null,"The TouchGFX Board Setups provide support for flashing project compiled with Keil, by using the .hex file output by Keil, with the STM32CubeProgrammer."),(0,i.kt)("p",null,"The .hex file is located at ",(0,i.kt)("inlineCode",{parentName:"p"},"<project_root_folder>/MDK-ARM/<STM32_evaluation_kit_name>/<STM32_evaluation_kit_name>.hex")),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"e.g. C:/TouchGFXProjects/MyApplication/MDK-ARM/STM32F469I-DISCO/STM32F469I-DISCO.hex")),(0,i.kt)("h2",l({},{id:"flashing-custom-hardware"}),"Flashing Custom Hardware"),(0,i.kt)("p",null,"If instead what needs to be flashed is custom hardware, and not a predefined hardware setup like an STM32 Evaluation Kit, you can still use STM32CubeProgrammer. STM32CubeProgrammer does not necessarily come with a flash loading mechanism for your specific external memory. It is however possible to create a custom flash loader. Read the ",(0,i.kt)("a",l({parentName:"p"},{href:"https://www.st.com/resource/en/user_manual/dm00403500-stm32cubeprogrammer-software-description-stmicroelectronics.pdf"}),"user manual on developing customized loaders for your external memory")," to find more info."))}f.isMDXComponent=!0}}]);