"use strict";(self.webpackChunktouchgfx_documentation=self.webpackChunktouchgfx_documentation||[]).push([[60661],{49613:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>h});var a=n(59496);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var d=a.createContext({}),s=function(e){var t=a.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},m=function(e){var t=s(e.components);return a.createElement(d.Provider,{value:t},e.children)},p="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,d=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),p=s(n),u=i,h=p["".concat(d,".").concat(u)]||p[u]||c[u]||r;return n?a.createElement(h,o(o({ref:t},m),{},{components:n})):a.createElement(h,o({ref:t},m))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=u;var l={};for(var d in t)hasOwnProperty.call(t,d)&&(l[d]=t[d]);l.originalType=e,l[p]="string"==typeof e?e:i,o[1]=l;for(var s=2;s<r;s++)o[s]=n[s];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},89639:(e,t,n)=>{n.d(t,{Z:()=>r});var a=n(59496),i=n(7029);const r=function(e){const t=e.noShadow||!1,n=e.width,r=e.height,o=(0,i.Z)(e.imageSource);return t?a.createElement("div",{className:"figure noshadow"},a.createElement("a",{href:o,target:"_blank"},a.createElement("img",{width:n,height:r,src:o})),a.createElement("p",null,e.children)):a.createElement("div",{className:"figure"},a.createElement("a",{href:o,target:"_blank"},a.createElement("img",{width:n,height:r,src:o})),a.createElement("p",null,e.children))}},48753:(e,t,n)=>{n.d(t,{Z:()=>l});var a=n(59496),i=n(96151);const r=a.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},a.createElement("path",{fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}));class o extends a.Component{render(){return a.createElement(i.Z,{color:"var(--highlight-color-further-reading)",header:"Further reading",type:"further-reading",icon:r},this.props.children)}}const l=o},96151:(e,t,n)=>{n.d(t,{Z:()=>r});var a=n(59496);class i extends a.Component{render(){const e=`highlight highlight-${this.props.type}`;return a.createElement("div",{className:e},a.createElement("div",{className:"highlight-heading"},a.createElement("h5",null,a.createElement("div",{className:"highlight-icon"},this.props.icon),this.props.header)),a.createElement("div",{className:"highlight-content"},this.props.children))}}const r=i},49018:(e,t,n)=>{n.d(t,{Z:()=>l});var a=n(59496),i=n(96151);const r=a.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},a.createElement("path",{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}));class o extends a.Component{render(){return a.createElement(i.Z,{color:"var(--highlight-color-note)",header:"Note",type:"note",icon:r},this.props.children)}}const l=o},84795:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>p,default:()=>k,frontMatter:()=>m,metadata:()=>c,toc:()=>h});n(59496);var a=n(49613),i=n(89639),r=n(49018),o=n(48753),l=n(95375);function d(){return d=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},d.apply(this,arguments)}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}const m={id:"scenarios-dsi-command-mode",title:"MIPI-DSI Command Mode"},p=void 0,c={unversionedId:"development/touchgfx-hal-development/scenarios/scenarios-dsi-command-mode",id:"development/touchgfx-hal-development/scenarios/scenarios-dsi-command-mode",title:"MIPI-DSI Command Mode",description:"This scenario describes how to configure MIPI DSI interface in Command Mode and TouchGFX Generator when using a display with a Display Serial Interface (DSI) and GRAM.",source:"@site/docs/development/touchgfx-hal-development/scenarios/scenarios-dsi-command-mode.mdx",sourceDirName:"development/touchgfx-hal-development/scenarios",slug:"/development/touchgfx-hal-development/scenarios/scenarios-dsi-command-mode",permalink:"/4.25/docs/development/touchgfx-hal-development/scenarios/scenarios-dsi-command-mode",draft:!1,tags:[],version:"current",frontMatter:{id:"scenarios-dsi-command-mode",title:"MIPI-DSI Command Mode"},sidebar:"docs",previous:{title:"SPI Display Interface",permalink:"/4.25/docs/development/touchgfx-hal-development/scenarios/scenarios-spi"},next:{title:"Real Time Operating System",permalink:"/4.25/docs/development/touchgfx-hal-development/scenarios/scenarios-configure-rtos"}},u={},h=[{value:"Configuration",id:"configuration",level:2},{value:"LTDC Configuration",id:"ltdc-configuration",level:3},{value:"DSIHOST Configuration",id:"dsihost-configuration",level:3},{value:"TouchGFX Generator",id:"touchgfx-generator",level:3},{value:"User Code",id:"user-code",level:2},{value:"DSIHOST / LTDC Initialization sequence",id:"dsihost-ltdc-initialization-sequence",level:3},{value:"Updated TouchGFXHAL class for DSI Command Mode",id:"touchgfxhal-class-for-dsi-command-mode",level:3},{value:"Supported Framebuffer Strategies",id:"supported-framebuffer-strategies",level:2},{value:"Single",id:"single",level:3},{value:"Double",id:"double",level:3},{value:"Partial - GRAM display",id:"partial",level:3}],f={toc:h},g="wrapper";function k(e){var{components:t}=e,n=s(e,["components"]);return(0,a.kt)(g,d({},f,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"This scenario describes how to configure MIPI DSI interface in Command Mode and ",(0,a.kt)("em",{parentName:"p"},"TouchGFX Generator")," when using a display with a Display Serial Interface (DSI) and GRAM.\nThe example used in this article will be for 16-bit RGB565 frame buffer format and goes through configurations in STM32CubeMX."),(0,a.kt)(r.Z,{mdxType:"Note"},"This scenario assumes that a working display driver has been developed during the Board Bringup phase. The driver must be able to transfer pixels to the display, and to control the memory writing position of the display. Check the datasheet for your display for further details."),(0,a.kt)("h2",d({},{id:"configuration"}),"Configuration"),(0,a.kt)("h3",d({},{id:"ltdc-configuration"}),"LTDC Configuration"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Mode"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Set ",(0,a.kt)("inlineCode",{parentName:"li"},"Display Type")," to ",(0,a.kt)("em",{parentName:"li"},"RGB565 (16 bits) - DSI Mode")))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Layer Settings"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Set ",(0,a.kt)("inlineCode",{parentName:"li"},"Number of layers")," to ",(0,a.kt)("em",{parentName:"li"},"1 layer")),(0,a.kt)("li",{parentName:"ul"},"Set the screen resolution in ",(0,a.kt)("inlineCode",{parentName:"li"},"Windows Position")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"Frame Buffer Line Length")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"Frame Buffer Number of Lines")),(0,a.kt)("li",{parentName:"ul"},"Set ",(0,a.kt)("inlineCode",{parentName:"li"},"Layer 0 - Pixel Format")," to ",(0,a.kt)("em",{parentName:"li"},"RGB565")),(0,a.kt)("li",{parentName:"ul"},"Set ",(0,a.kt)("inlineCode",{parentName:"li"},"Layer 0 - Alpha constant for blending")," to ",(0,a.kt)("em",{parentName:"li"},"255"),(0,a.kt)(i.Z,{noShadow:!0,imageSource:"/img/development/touchgfx-hal-development/scenarios/dsi-command-mode/ltdc-config1.png",width:"600",mdxType:"Figure"},"LTDC Configuration")))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"NVIC Settings"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Both ",(0,a.kt)("inlineCode",{parentName:"li"},"LTDC global interrupt")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"LTDC global error interrupt")," are not needed, and should be disabled.",(0,a.kt)(i.Z,{noShadow:!0,imageSource:"/img/development/touchgfx-hal-development/scenarios/dsi-command-mode/ltdc-config2.png",width:"600",mdxType:"Figure"},"LTDC NVIC Settings"))))),(0,a.kt)("h3",d({},{id:"dsihost-configuration"}),"DSIHOST Configuration"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Mode"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Set ",(0,a.kt)("inlineCode",{parentName:"li"},"DSIHost")," to ",(0,a.kt)("em",{parentName:"li"},(0,a.kt)("em",{parentName:"em"},"Adapted Command Mode with TE Pin"))))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Display Interface"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Set ",(0,a.kt)("inlineCode",{parentName:"li"},"Color Coding")," to ",(0,a.kt)("em",{parentName:"li"},"RGB565 (16 bits) - DSI mode")),(0,a.kt)("li",{parentName:"ul"},"Set ",(0,a.kt)("inlineCode",{parentName:"li"},"Maximum Command Size")," to a number on the order of the width of the display"),(0,a.kt)("li",{parentName:"ul"},"Set ",(0,a.kt)("inlineCode",{parentName:"li"},"The Refresh of the Display Frame Buffer is Triggered ")," to ",(0,a.kt)("em",{parentName:"li"},"manually by Enabling the LTDC")),(0,a.kt)("li",{parentName:"ul"},"Remaining configurations depends on the selected LCD HW",(0,a.kt)(i.Z,{noShadow:!0,imageSource:"/img/development/touchgfx-hal-development/scenarios/dsi-command-mode/dsihost-config1.png",width:"600",mdxType:"Figure"},"DSIHOST Configuration")))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"NVIC Settings"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Enable ",(0,a.kt)("inlineCode",{parentName:"li"},"DSI global interrupt"),(0,a.kt)(i.Z,{noShadow:!0,imageSource:"/img/development/touchgfx-hal-development/scenarios/dsi-command-mode/dsihost-config2.png",width:"600",mdxType:"Figure"},"DSIHOST NVIC Settings"))))),(0,a.kt)("h3",d({},{id:"touchgfx-generator"}),"TouchGFX Generator"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Mode"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Enable ",(0,a.kt)("em",{parentName:"li"},"Graphics Application")))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"TouchGFX Generator"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Set ",(0,a.kt)("inlineCode",{parentName:"li"},"Display / Interface")," to ",(0,a.kt)("em",{parentName:"li"},"Parallel RGB (LTDC)")," since this is still the controller the application needs to communicate with."),(0,a.kt)("li",{parentName:"ul"},"Set ",(0,a.kt)("inlineCode",{parentName:"li"},"Application Tick Source")," to ",(0,a.kt)("em",{parentName:"li"},"Custom"),(0,a.kt)(i.Z,{noShadow:!0,imageSource:"/img/development/touchgfx-hal-development/scenarios/dsi-command-mode/touchgfx-generator-config.png",width:"600",mdxType:"Figure"},"TouchGFX Generator Configuration"))))),(0,a.kt)("h2",d({},{id:"user-code"}),"User Code"),(0,a.kt)("p",null,"The ",(0,a.kt)("em",{parentName:"p"},"TouchGFX Generator")," can only generate a partial TouchGFX AL that configures the LTDC to transfer pixels through the DSI Host controller from the framebuffer memory to the display and synchronize the display with the TouchGFX Engine.\nHowever, all necessary handles to accomplish this are generated by the TouchGFX Generator."),(0,a.kt)("p",null,"Generally, for displays with embedded GRAM, the implementation of the generated TouchGFX HAL handles in ",(0,a.kt)("inlineCode",{parentName:"p"},"TouchGFXHAL.cpp")," should perform the following steps to transfer pixels to the display and synchronize the display with the TouchGFX Engine:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},'Wait for "VSYNC" (sometimes called Tearing Effect (TE) signal) to signal the TouchGFX Engine.'),(0,a.kt)("li",{parentName:"ol"},'Based on the area of the framebuffer to be redrawn, move the "display cursor" and "active window" (the region of the display being updated) to a place in GRAM that matches this area.'),(0,a.kt)("li",{parentName:"ol"},"Prepare to write incoming pixel data to GRAM. Depending on the framebuffer strategy and display interface used, this could be swapping framebuffer pointers, signaling TouchGFX Engine, or waiting for previous transfers to complete."),(0,a.kt)("li",{parentName:"ol"},"Send pixel data.")),(0,a.kt)("p",null,"Depending on the display used and the framebuffer strategy, the implementation of the above steps will vary."),(0,a.kt)("p",null,"Some of the adjustments that may be needed specifcally for DSI Command Mode interfaces are described below."),(0,a.kt)("h3",d({},{id:"dsihost-ltdc-initialization-sequence"}),"DSIHOST / LTDC Initialization sequence"),(0,a.kt)("p",null,"The call to ",(0,a.kt)("inlineCode",{parentName:"p"},"MX_DSIHOST_DSI_Init()")," must be done before ",(0,a.kt)("inlineCode",{parentName:"p"},"MX_LTDC_Init()"),". This should be handled by STM32CubeMX.\nIf this is not correct, take care to fix the order in a user code section."),(0,a.kt)("p",null,"After calling ",(0,a.kt)("inlineCode",{parentName:"p"},"HAL_DSI_Start()"),", switch DSIHOST clock to the ",(0,a.kt)("inlineCode",{parentName:"p"},"DSIPHY")," source:"),(0,a.kt)("pre",null,(0,a.kt)("code",d({parentName:"pre"},{className:"language-cpp",metastring:"{12}","{12}":!0}),"static void MX_DSIHOST_DSI_Init(void)\n{\n  ...\n  /* Switch to DSI PHY PLL clock */\n  RCC_PeriphCLKInitTypeDef PeriphClkInit;\n  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_DSI;\n  PeriphClkInit.DsiClockSelection    = RCC_DSICLKSOURCE_DSIPHY;\n  HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit);\n  /* USER CODE END DSIHOST_Init 2 */\n  ...\n}\n")),(0,a.kt)("p",null,"User has to add the required initialization code specific to the used LCD controller at the end of the ",(0,a.kt)("inlineCode",{parentName:"p"},"MX_LTDC_Init()")," function.\nThat code will be based on the DSI HAL APIs ",(0,a.kt)("inlineCode",{parentName:"p"},"HAL_DSI_ShortWrite()")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"HAL_DSI_LongWrite()"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",d({parentName:"pre"},{className:"language-cpp"}),"  static void MX_LTDC_Init(void)\n  {\n    ...\n    /* USER CODE BEGIN LTDC_Init 2 */\n    // Specific LCD controller's initialization code\n    ...\n\n    // Exit Sleep Mode\n    if (HAL_DSI_ShortWrite(&hdsi, 0, DSI_DCS_SHORT_PKT_WRITE_P0, DSI_EXIT_SLEEP_MODE, 0x00) != HAL_OK)\n    {\n      Error_Handler();\n    }\n\n    HAL_Delay(120);\n    /* USER CODE END LTDC_Init 2 */\n    ...\n  }\n")),(0,a.kt)("h3",d({},{id:"touchgfxhal-class-for-dsi-command-mode"}),"Updated TouchGFXHAL class for DSI Command Mode"),(0,a.kt)("p",null,"One way to prevent the MIPI DSI display from turning on until the first frame in the application has beem rendered is to guard the function ",(0,a.kt)("inlineCode",{parentName:"p"},"TouchGFXHAL::endFrame")," to keep the display off until first frame is rendered by TouchGFX. The ",(0,a.kt)("inlineCode",{parentName:"p"},"TouchGFXHAL::endFrame()")," could be updated as below, to enable the LCD and its Backlight through a HW Timer configured for PWM output."),(0,a.kt)("pre",null,(0,a.kt)("code",d({parentName:"pre"},{className:"language-cpp",metastring:"{7,9,11}","{7,9,11}":!0}),"void TouchGFXHAL::endFrame()\n{\n    if (!display_on)\n    {\n        display_on = true;\n        /* Enable the LCD, Send Display on DCS command to display */\n        HAL_DSI_ShortWrite(&hdsi, 0, DSI_DCS_SHORT_PKT_WRITE_P1, DSI_SET_DISPLAY_ON, 0x00);\n        /* Start PWM Timer channel */\n        (void)HAL_TIM_PWM_Start(&htim8, TIM_CHANNEL_2);\n        /* Enable Backlight by setting Brightness to 100% */\n        __HAL_TIM_SET_COMPARE(&htim8, TIM_CHANNEL_2, 2U * 100);\n    }\n\n    TouchGFXGeneratedHAL::endFrame();\n}\n")),(0,a.kt)("h2",d({},{id:"supported-framebuffer-strategies"}),"Supported Framebuffer Strategies"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Single"),(0,a.kt)("li",{parentName:"ul"},"Double"),(0,a.kt)("li",{parentName:"ul"},"Partial - GRAM display")),(0,a.kt)(o.Z,{mdxType:"FurtherReading"},"See article ",(0,a.kt)(l.Z,{to:"../../../basic-concepts/framebuffer#framebuffer-strategies",mdxType:"Link"},"Framebuffer Strategies")," for a general introduction to framebuffer strategies in TouchGFX."),(0,a.kt)("p",null,"DSI Command Mode usually has a high enough bandwidth to transfer pixels to GRAM fast than the display scans the pixels. This is very similar to\nto the FMC Parallel display interface. Therefore, the implementation steps for a working TouchGFX AL for DSI Command Mode is very similar to the FMC Parallel display interface."),(0,a.kt)(o.Z,{mdxType:"FurtherReading"},"See article ",(0,a.kt)(l.Z,{to:"scenarios-fmc",mdxType:"Link"},"FMC Display Interface")," for more information about the TouchGFX AL implementation."),(0,a.kt)("h3",d({},{id:"single"}),"Single"),(0,a.kt)("p",null,"Currently, no ",(0,a.kt)("em",{parentName:"p"},"TouchGFX Board Support")," have a reference implementation for Single buffering with DSI Command Mode. The setup would be similar to ",(0,a.kt)(l.Z,{to:"scenarios-fmc#single",mdxType:"Link"},"FMC Single buffer")," setup, but\nusing DSI Command Mode driver functions instead of FMC."),(0,a.kt)("h3",d({},{id:"double"}),"Double"),(0,a.kt)("p",null,"Currently, no ",(0,a.kt)("em",{parentName:"p"},"TouchGFX Board Support")," have a reference implementation for Double buffering with DSI Command Mode. The setup would be similar to ",(0,a.kt)(l.Z,{to:"scenarios-fmc#double",mdxType:"Link"},"FMC Double buffer")," setup, but\nusing DSI Command Mode driver functions instead of FMC."),(0,a.kt)("h3",d({},{id:"partial"}),"Partial - GRAM display"),(0,a.kt)("p",null,"Currently, no ",(0,a.kt)("em",{parentName:"p"},"TouchGFX Board Support")," have a reference implementation for ",(0,a.kt)("em",{parentName:"p"},"Partial - GRAM display")," with DSI Command Mode. The setup would be similar to ",(0,a.kt)(l.Z,{to:"scenarios-fmc#partial",mdxType:"Link"},"FMC Partial - GRAM display")," setup, but\nusing DSI Command Mode driver functions instead of FMC."))}k.isMDXComponent=!0}}]);