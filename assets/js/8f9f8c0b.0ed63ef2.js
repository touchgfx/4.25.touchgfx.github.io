"use strict";(self.webpackChunktouchgfx_documentation=self.webpackChunktouchgfx_documentation||[]).push([[56384],{49613:(e,t,a)=>{a.d(t,{Zo:()=>m,kt:()=>d});var n=a(59496);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=n.createContext({}),p=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},m=function(e){var t=p(e.components);return n.createElement(s.Provider,{value:t},e.children)},h="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},c=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),h=p(a),c=r,d=h["".concat(s,".").concat(c)]||h[c]||u[c]||o;return a?n.createElement(d,i(i({ref:t},m),{},{components:a})):n.createElement(d,i({ref:t},m))}));function d(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=a.length,i=new Array(o);i[0]=c;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[h]="string"==typeof e?e:r,i[1]=l;for(var p=2;p<o;p++)i[p]=a[p];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}c.displayName="MDXCreateElement"},89639:(e,t,a)=>{a.d(t,{Z:()=>o});var n=a(59496),r=a(97395);const o=function(e){const t=e.noShadow||!1,a=e.width,o=e.height,i=(0,r.Z)(e.imageSource);return t?n.createElement("div",{className:"figure noshadow"},n.createElement("a",{href:i,target:"_blank"},n.createElement("img",{width:a,height:o,src:i})),n.createElement("p",null,e.children)):n.createElement("div",{className:"figure"},n.createElement("a",{href:i,target:"_blank"},n.createElement("img",{width:a,height:o,src:i})),n.createElement("p",null,e.children))}},35249:(e,t,a)=>{a.d(t,{Z:()=>o});var n=a(59496),r=a(97395);const o=function(e){const t=(0,r.Z)(e.url);var a;const o=null!==(a=e.width)&&void 0!==a?a:"100%";var i;const l=null!==(i=e.height)&&void 0!==i?i:"100%";return n.createElement("div",{className:"loop-video"},n.createElement("video",{muted:!0,loop:!0,playsInline:!0,autoPlay:!0,width:o,height:l},n.createElement("source",{src:t,type:"video/mp4"}),"Your browser does not support the video tag."),n.createElement("p",null,e.children))}},38033:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>h,contentTitle:()=>p,default:()=>g,frontMatter:()=>s,metadata:()=>m,toc:()=>u});a(59496);var n=a(49613),r=a(89639),o=a(35249);function i(){return i=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var a=arguments[t];for(var n in a)Object.prototype.hasOwnProperty.call(a,n)&&(e[n]=a[n])}return e},i.apply(this,arguments)}function l(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}const s={id:"touchgfx-on-gpu2d",title:"TouchGFX on NeoChrom/NeoChromVG"},p=void 0,m={unversionedId:"development/scenarios/touchgfx-on-gpu2d",id:"development/scenarios/touchgfx-on-gpu2d",title:"TouchGFX on NeoChrom/NeoChromVG",description:"This section discusses how to use TouchGFX on hardware having the NeoChrom GPU",source:"@site/docs/development/scenarios/touchgfx-on-gpu2d.mdx",sourceDirName:"development/scenarios",slug:"/development/scenarios/touchgfx-on-gpu2d",permalink:"/4.25/docs/development/scenarios/touchgfx-on-gpu2d",draft:!1,tags:[],version:"current",frontMatter:{id:"touchgfx-on-gpu2d",title:"TouchGFX on NeoChrom/NeoChromVG"},sidebar:"docs",previous:{title:"TouchGFX on Low Cost Hardware",permalink:"/4.25/docs/development/scenarios/touchgfx-on-lowcost-hardware"},next:{title:"Running graphics on STM32H7R7 & S7",permalink:"/4.25/docs/development/scenarios/running-graphics-on-stm32h7r"}},h={},u=[{value:"NeoChrom and NeoChromVG",id:"neochrom-and-neochromvg",level:3},{value:"NeoChrom Graphical Capabilities",id:"neochrom-graphical-capabilities",level:2},{value:"Vector Graphics",id:"vector-graphics",level:3},{value:"Rendering Time Improvements with NeoChrom.",id:"rendering-time-improvements-with-neochrom",level:2},{value:"Rendering Time Summary",id:"rendering-time-summary",level:3},{value:"Richer User Interfaces",id:"richer-user-interfaces",level:3},{value:"Accelerated Vector Graphics",id:"accelerated-vector-graphics",level:2},{value:"SVG",id:"svg",level:3},{value:"Vector fonts",id:"vector-fonts",level:3},{value:"Creating a project",id:"creating-a-project",level:2},{value:"Framebuffer Formats",id:"framebuffer-formats",level:2},{value:"STM32H7R7/S7 and STM32N6 limitations when using RGB888 framebuffer (24 bpp)",id:"stm32h7r7s7-and-stm32n6-limitations-when-using-rgb888-framebuffer-24-bpp",level:3},{value:"Step-by-step guide to enable 24 bpp framebuffers on STM32H7R7/S7",id:"step-by-step-guide-to-enable-24-bpp-framebuffers-on-stm32h7r7s7",level:4},{value:"STM32U5 limitations when having framebuffer(s) in external RAM",id:"stm32u5-limitations-when-having-framebuffers-in-external-ram",level:3},{value:"NeoChrom Limitations",id:"neochrom-limitations",level:2}],c={toc:u},d="wrapper";function g(e){var{components:t}=e,a=l(e,["components"]);return(0,n.kt)(d,i({},c,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("p",null,"This section discusses how to use TouchGFX on hardware having the NeoChrom GPU\ngraphics accelerator. This graphics accelerator improves the\nperformance significantly for operations like texture mapping, image scaling and rotation. This\nmeans that more advanced UIs can be built while still keeping a high\nframe rate."),(0,n.kt)("p",null,"The NeoChrom graphics accelerator is currently available in STM32U5x7, STM32U5x9,\nSTM32H7R7/S7 and STM32N6 microcontrollers. Development boards are\navailable for all families."),(0,n.kt)(r.Z,{width:"30%",imageSource:"/img/development/scenarios/touchgfx-on-gpu2d/stm32u5a9-dk-bsd-menu.webp",mdxType:"Figure"},"STM32U5A9 Discovery Board"),(0,n.kt)("p",null,"The NeoChrom accelerator is known by the name GPU2D in source code and in STM32CubeMX."),(0,n.kt)("h3",i({},{id:"neochrom-and-neochromvg"}),"NeoChrom and NeoChromVG"),(0,n.kt)("p",null,"The NeoChrom accelerator has been updated with extra capabilities with\nthe introduction of STM32U5G9. The improved accelerator is named\nNeoChromVG. The accelerator contains extended capabilities that\nallows hardware accelerated vector graphics."),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",i({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"th"},"Micro controller")),(0,n.kt)("th",i({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"th"},"Accelerator")))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"STM32U599/A9"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"NeoChrom")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"STM32U5F7/G7"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"NeoChromVG")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"STM32U5F9/G9"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"NeoChromVG")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"STM32H7R7/S7"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"NeoChrom")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"STM32N6"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"NeoChrom")))),(0,n.kt)("h2",i({},{id:"neochrom-graphical-capabilities"}),"NeoChrom Graphical Capabilities"),(0,n.kt)("p",null,"The NeoChrom accelerators are capable of performing basic blitting (drawing images),\nblending, scaling, rotation, and texture mapping. All such operations\nare automatically used by TouchGFX when running on a microcontroller\nwith NeoChrom."),(0,n.kt)("p",null,"Compared to the DMA2D graphics accelerator NeoChrom is capable of accelerating\nmore graphical operations and has a richer feature set:"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",i({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"th"},"Graphic feature")),(0,n.kt)("th",i({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"th"},"DMA2D")),(0,n.kt)("th",i({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"th"},"GPU2D")))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Supported formats (with TouchGFX)"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"ARGB8888, RGB888, RGB565, A8, A4, L8"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"ARGB8888, RGB888, RGB565, A8, A4, A2, A1")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Command list based"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"No"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Yes")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Drawing"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Rectangles"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Rectangles, Pixels, Line, Triangle, Quadrilaterals with  multi-sample anti-aliasing (MSAA)")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Blitting"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Copy, alpha blending, pixel format conversion"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Copy, alpha blending, pixel format conversion, color keying")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Texture Mapping"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"No"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Yes")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Vector Graphics"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"No"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"No*")))),(0,n.kt)("p",null,"*"," Vector Graphics are partially hardware-accelerated with NeoChrom when using TouchGFX. Full hardware acceleration for Vector Graphics is available with NeoChromVG."),(0,n.kt)("p",null,"With these capabilities available even more TouchGFX Widgets are\naccelerated with NeoChrom:"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",i({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"th"},"Widget")),(0,n.kt)("th",i({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"th"},"DMA2D")),(0,n.kt)("th",i({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"th"},"GPU2D")))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Box, BoxWithBorder"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Yes"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Yes")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Image, AnimatedImage, TiledImage, SnapshotWidget"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Yes"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Yes")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Button, ButtonWithIcon, ButtonWithLabel, ToggleButton"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Yes"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Yes")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"RadioButton, RepeatButton"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Yes"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Yes")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"PixelDataWidget"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Yes"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Yes")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"TextArea, TextAreaWithWildcard, Keyboard"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Partly"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Yes")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"ScalableImage"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"No"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Yes")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"TextureMapper, AnimatedTextureMapper"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"No"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Yes")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Circle, Line, Graph, Gauge"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"No*"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"No*")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"SVG"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"No"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"No**")))),(0,n.kt)("p",null,"*"," The drawing/blending of pixels to the framebuffer is done by DMA2D, but the shape calculations are done in software.",(0,n.kt)("br",null),"\n","*","* Hardware accelerated SVG is available with NeoChromVG."),(0,n.kt)("p",null,"The operations that are not hardware accelerated are software rendered\n(implying a higher CPU-load, and lower performance). As the table above\nshows, NeoChrom can accelerate widgets like ScalableImage and\nTextureMapper. This means that we can use those widgets to a greater\nextent while keeping a high performance."),(0,n.kt)("h3",i({},{id:"vector-graphics"}),"Vector Graphics"),(0,n.kt)("p",null,"The new NeoChromVG accelerator can accelerate vector graphics. This\ncapability is used when rendering SVG images with TouchGFX. An extra\nbuffer called the stencil buffer is required by the GPU2D graphics\naccelerator. This buffer has the same dimension as the frame buffer,\nbut only 1 byte pr pixel."),(0,n.kt)("p",null,"Example, if your frame buffer is 480 x 480 in 24bpp, the stencil\nbuffer must be 480 * 480 = 230,400 bytes. It is important to allocate\nthe stencil buffer in fast SRAM for best performance."),(0,n.kt)("p",null,"The stencil buffer is allocated by the TouchGFX Generator. See\n",(0,n.kt)("a",i({parentName:"p"},{href:"../touchgfx-hal-development/generator-how-to/touchgfx-al-configuration/additional-features#vector-rendering"}),"this"),"\nguide."),(0,n.kt)("h2",i({},{id:"rendering-time-improvements-with-neochrom"}),"Rendering Time Improvements with NeoChrom."),(0,n.kt)("p",null,"The following examples illustrate the speed-up provided by NeoChrom over\nDMA2D and software rendering. We have created two projects with the\nDesigner. The first project shows an Image on a Box background. The\nsecond project shows a TextureMapper Widget on a Box background. The\nwidget is redrawn in every frame.  In both cases the bitmap is of size\n128x128, in ARGB8888 format, and stored in the internal flash. The framebuffer is in RGB565 format."),(0,n.kt)(r.Z,{width:"40%",imageSource:"/img/development/scenarios/touchgfx-on-gpu2d/designer-image.webp",mdxType:"Figure"},"The Image project"),(0,n.kt)(r.Z,{width:"40%",imageSource:"/img/development/scenarios/touchgfx-on-gpu2d/designer-texturemapper.webp",mdxType:"Figure"},"The TextureMapper project"),(0,n.kt)("p",null,"Both projects have been executed on a STM32F746 and a STM32U5A9 Discovery board."),(0,n.kt)("p",null,"We have measured the rendering times by connecting a GPIO to a logic analyzer:"),(0,n.kt)(r.Z,{imageSource:"/img/development/scenarios/touchgfx-on-gpu2d/render-time-f746-image.webp",mdxType:"Figure"},"STM32F746 running the Image project"),(0,n.kt)("p",null,"The figure above shows the frame rate and rendering time when running\non the STM32F746. Channel 00 shows the VSYNC signal. We see that the\ndisplay runs with a frame interval of 16.9 ms (A1 to A2) corresponding\nto a frame rate of 59.2 Hz. Channel 01 shows the render time (high\nwhen rendering, B1 to B2). The time to render the Image is thus 1.3\nms. Image rendering is fast on the STM32F746."),(0,n.kt)(r.Z,{imageSource:"/img/development/scenarios/touchgfx-on-gpu2d/render-time-f746-texturemapper.webp",mdxType:"Figure"},"STM32F746 running the TextureMapper project"),(0,n.kt)("p",null,"The figure above is the texture mapper project running on the STM32F746. The\nrendering time of the TextureMapper is 4.5 ms. The TextureMapper\nwidget is much slower than the Image."),(0,n.kt)(r.Z,{imageSource:"/img/development/scenarios/touchgfx-on-gpu2d/render-time-u5a9-image.webp",mdxType:"Figure"},"STM32U5A9 running the Image project"),(0,n.kt)("p",null,"Here is the STM32U5A9 Discovery kit running the Image project. The\nSTM32U5A9 Discovery kit display has a display frame interval of 12.26\nms corresponding to a frame rate of 81.6 Hz. The render time of the\nImage is 0.7 ms. We see that the Image widget is faster than on the STM32F746 kit."),(0,n.kt)(r.Z,{imageSource:"/img/development/scenarios/touchgfx-on-gpu2d/render-time-u5a9-texturemapper.webp",mdxType:"Figure"},"STM32U5A9 running the TextureMapper project"),(0,n.kt)("p",null,"The render time of the TextureMapper is 1.7 ms. The TextureMapper is\nalso faster on STM32U5A9 than on the STM32F746."),(0,n.kt)("h3",i({},{id:"rendering-time-summary"}),"Rendering Time Summary"),(0,n.kt)("p",null,"The table below shows the rendering times:"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",i({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"th"},"Element")),(0,n.kt)("th",i({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"th"},"STM32F746")),(0,n.kt)("th",i({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"th"},"STM32U5A9")),(0,n.kt)("th",i({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"th"},"Speed up")))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Frequency"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"200 MHz"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"160 MHz"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"0.8")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Image"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"1.3 ms"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"0.7 ms"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"~2x")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"TextureMapper"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"4.5 ms"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"1.7 ms"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"~3x")))),(0,n.kt)("p",null,"We see that even with a reduced clock frequency the STM32U5A9 greatly\noutperforms the STM32F746, especially with the TextureMapper."),(0,n.kt)("p",null,"These measurements are taken with the image in internal flash and the\nframebuffer in external SDRAM for STM32F746. The framebuffer is in\ninternal SRAM for the STM32U5A9 (as this will be typical\nscenario). Moving the image to external flash hurts the STM32F746 as\nit uses QSPI flash (4-bit bus), whereas the STM32U5A9 uses a faster\nOSPI flash (8-bit bus)."),(0,n.kt)("p",null,"The STM32F746 Discovery kit can run with a 480x272 RGB565 framebuffer\nin the internal RAM. This improves the performance (Image down to 1.03\nms), but it is not the standard configuration for STM32F746, as it\nuses a very large part of the internal SRAM for the frame buffer,\nleaving little RAM for other application components.\nRunning with a single frame buffers is also not suitable for all\napplications."),(0,n.kt)("h3",i({},{id:"richer-user-interfaces"}),"Richer User Interfaces"),(0,n.kt)("p",null,"The improved rendering performance can be used to create user interfaces with\nmore advanced animations. For example more scaled or rotated\nelements.\nFor the STM32F746, the display refresh time was 16.8 ms. This means that\nthe application must keep the render time below this time to keep a frame\nrate of 60 fps. We can therefore have at most 3.75 texture mappers of\nthat complexity (16.8 ms / 4.48 ms) on the screen, or a single larger\ntexture mapper of size 247 x 247 (the same number of pixels and\napproximately the same rendering time).\nIf we assume the same screen refresh rate, but use the STM32U5A9 CPU,\nwe can have 14.36 texture mappers (16.8 ms / 1.17 ms), or a single\ntexture mapper of size 485 x 485."),(0,n.kt)("p",null,"The following figure shows two applications running on respectively\nthe STM32F746 and the STM32U5A9. The idea is to make a carousel-like\nmenu where elements are scaled up when going to the center and scaled\ndown when going out (here we just use the same texture for all the\nelements)."),(0,n.kt)(r.Z,{imageSource:"/img/development/scenarios/touchgfx-on-gpu2d/comparison-f746-u5a9.webp",mdxType:"Figure"},"STM32F746 (left) with a 480x272 pixels display and STM32U5A9 (right) running the texture mapper based carousel project on a 480x480 display."),(0,n.kt)("p",null,"The STM32F746 is capable of showing three icons, one big icon, scaled up by a\nfactor of 1.9, and two smaller icons. The STM32U5A9 is capable of\nshowing 7 icons. The largest icon is scaled up by factor 2.7."),(0,n.kt)("p",null,"The rendering time of the application with 3 icons on the STM32F746 is\n14.38 ms. The rendering time of the application with 7 icons on the\nSTM32U5A9 is 14.93 ms. Both UIs can thus run in 60 fps, with the\nSTM32U5A9 showing much more content in a higher resolution."),(0,n.kt)("h2",i({},{id:"accelerated-vector-graphics"}),"Accelerated Vector Graphics"),(0,n.kt)("p",null,"The new NeoChromVG accelerator is capable of accelerating vector\ngraphics. This open the possibilities of a new class of applications,\nwhere vector based graphics plays a central role and not bitmaps."),(0,n.kt)("p",null,"One example is a map-application. Maps can be built from bitmaps, but\nthat often requires a very large storage or that specific map sections\nare downloaded in advance."),(0,n.kt)("p",null,"The video below shows a demonstration application running on a\nSTM32U5G9. The application zooms, rotates, and pans a map that is\ndrawn from a vector definition (multiple polygons that are filled with\ndifferent colors and stroked). The video is running full screen on a\n800 x 480 display with 16bpp colors."),(0,n.kt)(o.Z,{width:"40%",height:"40%",url:"/videos/development/scenarios/touchgfx-on-gpu2d/tigermap.mp4",mdxType:"LoopVideo"},"STM32U5G9 showing a moving map."),(0,n.kt)("h3",i({},{id:"svg"}),"SVG"),(0,n.kt)("p",null,"The NeoChromVG accelerator drastically improves the performance of\ndrawing SVG images. TouchGFX automatically leverages the available\nhardware. A simple example will show the improvements. Here is an SVG\nimage that we will draw in size 152x152 pixels on a STM32F746 with\nsoftware rendering, a STM32H7S with NeoChrom, and a STM32U5G9 with\nNeoChromVG:"),(0,n.kt)(r.Z,{imageSource:"/img/development/scenarios/touchgfx-on-gpu2d/svg.png",mdxType:"Figure"},"Simple SVG drawing in size 152 x 152 pixels."),(0,n.kt)("p",null,"The render time of the SVG image is shown in the table below:"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",i({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"th"},"Micro controller")),(0,n.kt)("th",i({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"th"},"Accelerator")),(0,n.kt)("th",i({parentName:"tr"},{align:null}),"Render time /ms"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"STM32F746"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Chrom-ART*"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"4.12")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"STM32U5G9"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"NeoChromVG"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"0.97")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"STM32H7S8"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"NeoChrom"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"2.8")))),(0,n.kt)("p",null,"*"," Chrom-ART does not hardware accelerate vector rendering, so it is rendered entirely in software."),(0,n.kt)("p",null,"Read more about using SVG in TouchGFX here: ",(0,n.kt)("a",i({parentName:"p"},{href:"../ui-development/touchgfx-engine-features/svg"}),"SVG"),"."),(0,n.kt)("h3",i({},{id:"vector-fonts"}),"Vector fonts"),(0,n.kt)("p",null,"The NeoChrom and NeoChromVG also accelerates drawing of vector\nfonts. You can read more about how to use vector fonts in this\narticle:\n",(0,n.kt)("a",i({parentName:"p"},{href:"../ui-development/touchgfx-engine-features/vector-fonts"}),"Vector fonts"),"."),(0,n.kt)("h2",i({},{id:"creating-a-project"}),"Creating a project"),(0,n.kt)("p",null,"CubeMX and the TouchGFX Generator supports the NeoChrom. In STM32CubeMX the\naccelerator is known by its code name GPU2D. The GPU2D accelerator is\nonly available to TouchGFX if GPU2D is enabled in the TouchGFX\nconfiguration in STM32CubeMX.\nIf you use any of the TouchGFX TBS's (template projects) provided with the\nTouchGFX Designer this is already done. If you make your own custom\nproject, make sure to enable the GPU2D Accelerator as shown below:"),(0,n.kt)(r.Z,{imageSource:"/img/development/scenarios/touchgfx-on-gpu2d/cubemx-u5a9-configuration.webp",mdxType:"Figure"},"Enabling GPU2D (NeoChrom GPU) in STM32CubeMX"),(0,n.kt)("p",null,'After enabling GPU2D press "Generate Code" in STM32CubeMX. This regenerates\nthe target configuration code. Now open the project in the TouchGFX\nDesigner and generate code there also (F4).'),(0,n.kt)("p",null,"TouchGFX Designer generates assets (images, fonts, and texts) and simulator\ncode, that matches the target configuration. You are now ready to\ncompile the code."),(0,n.kt)("p",null,"If you are starting a project from TouchGFX Designer there is no need to\nopen STM32CubeMX unless you need to change some hardware settings."),(0,n.kt)("h2",i({},{id:"framebuffer-formats"}),"Framebuffer Formats"),(0,n.kt)("p",null,"The NeoChrom GPU does not natively support all color formats on all MCUs. The supported frambuffer formats can be seen in the table below:"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",i({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"th"},"Micro controller")),(0,n.kt)("th",i({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"th"},"RGB565 (16 bpp)")),(0,n.kt)("th",i({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"th"},"RGB888 (24 bpp)")),(0,n.kt)("th",i({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"th"},"ARGB8888 (32 bpp)")))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"STM32U5x7/x9"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Natively"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Natively"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Natively")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"STM32H7R7/S7"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Natively"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Using GFXMMU*"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Natively")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"STM32N6"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Natively"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Not supported*"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Natively")))),(0,n.kt)("p",null,"*"," These limitations are described in the following chapter."),(0,n.kt)("h3",i({},{id:"stm32h7r7s7-and-stm32n6-limitations-when-using-rgb888-framebuffer-24-bpp"}),"STM32H7R7/S7 and STM32N6 limitations when using RGB888 framebuffer (24 bpp)"),(0,n.kt)("p",null,"The internal bus to the NeoChrom GPU in STM32H7R7/S7 and STM32N657 does not\nsupport 24 bpp. At the moment there is no workaround for STM32N6, but for\nSTM32H7R7/S7 it is possible to use the GFXMMU to achieve 24 bpp framebuffers.\nIn this scenario, the GFXMMU is used to convert 32 bpp rendering to 24 bpp\nframebuffers. This means that TouchGFX runs as if it was a 32 bpp\nframebuffer and then the GFXMMU converts the pixel data when writing\nit to the 24 bpp framebuffer. To see an example of this setup, you can\ndownload the STM32H7S78_24bpp TBS from TouchGFX Designer, which\nuses the GFXMMU setup to enable 24 bpp framebuffer. Be aware that when\nusing this setup it is not possible to have opaque image assets in\nRGB888. Instead you must select ARGB8888 as your opaque image format\nto utilize the full color depth of your 24 bpp framebuffer."),(0,n.kt)("h4",i({},{id:"step-by-step-guide-to-enable-24-bpp-framebuffers-on-stm32h7r7s7"}),"Step-by-step guide to enable 24 bpp framebuffers on STM32H7R7/S7"),(0,n.kt)("p",null,"This guide provides step-by-step instructions on how to convert a project for\nSTM32H7R7/S7 to use 24 bpp framebuffers. It assumes that the steps\nare implemented on an already working project with 16 bpp framebuffers.\nIf the steps are followed on a project with 32 bpp framebuffers, step 6 can be skipped."),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},"Open STM32CubeMX and activate the GFXMMU for the Application context. The GFXMMU is found under the Multimedia tab."),(0,n.kt)("li",{parentName:"ol"},"Enable two packing buffers and select GFXMMU_PACKING_MSB_REMOVE as the packing mode for both. One buffer is needed per framebuffer, so for a single framebuffer setup, only one buffer is needed. ",(0,n.kt)("br",null),"\nNote: If you use ",(0,n.kt)("a",i({parentName:"li"},{href:"../../basic-concepts/framebuffer#display-without-gram-framebuffer-strategies"}),"emulated framebuffer"),", the first buffer is reserved for this. Therefore, you cannot use the first buffer for the 32 bpp to 24 bpp conversion if you are also using emulated framebuffer."),(0,n.kt)("li",{parentName:"ol"},"Set the physical addresses of the buffers enabled above. The physical address is where the 24 bpp framebuffer is placed in RAM."),(0,n.kt)("li",{parentName:"ol"},"Set default alpha to 0xFF."),(0,n.kt)("li",{parentName:"ol"},"Open Layer Settings in the LTDC configuration, which is also found under the Multimedia tab."),(0,n.kt)("li",{parentName:"ol"},"Set Layer 0 - Pixel Format to ARGB8888."),(0,n.kt)("li",{parentName:"ol"},"Set Layer 0 - Color Frame Buffer Start Address to one of the GFXMMU virtual buffers.",(0,n.kt)(r.Z,{imageSource:"/img/development/scenarios/touchgfx-on-gpu2d/h7rs-24bpp-gfxmmu-and-ltdc-config.png",mdxType:"Figure"},"Example of GFXMMU and LTDC configuration for STM32H7S78-DK with 24 bpp framebuffers")),(0,n.kt)("li",{parentName:"ol"},"Open X-CUBE-TOUCHGFX, which is found under Middleware and Software Packs."),(0,n.kt)("li",{parentName:"ol"},"Set Buffer Location to By Address and write GFXMMU_VIRTUAL_BUFFERx_BASE in the start addresses. Replace 'x' with the numbers of the packing buffers selected in step 2."),(0,n.kt)("li",{parentName:"ol"},"Generate code in STM32CubeMX."),(0,n.kt)("li",{parentName:"ol"},"Add the following code to the MX_LTDC_Init function in main.c to override the image format setting for the LTDC:",(0,n.kt)("pre",{parentName:"li"},(0,n.kt)("code",i({parentName:"pre"},{className:"language-cpp"}),"/* USER CODE BEGIN LTDC_Init 2 */\n// Reconfigure pixelformat since TouchGFX project generator does not allow setting different format for LTDC and\n// remaining configuration. This way TouchGFX runs 32BPP mode but the LTDC accesses the real framebuffer in 24BPP\npLayerCfg.PixelFormat = LTDC_PIXEL_FORMAT_RGB888;\nif (HAL_LTDC_ConfigLayer(&hltdc, &pLayerCfg, 0) != HAL_OK)\n{\n  Error_Handler();\n}\n/* USER CODE END LTDC_Init 2 */\n"))),(0,n.kt)("li",{parentName:"ol"},"Open TouchGFXHAL.cpp, which is found in the project directory under TouchGFX/target."),(0,n.kt)("li",{parentName:"ol"},"Add include of HAL file for the MCU if not already present. For STM32H7R7/S7 that would be:",(0,n.kt)("pre",{parentName:"li"},(0,n.kt)("code",i({parentName:"pre"},{className:"language-cpp"}),'#include "stm32h7rsxx_hal.h"\n'))),(0,n.kt)("li",{parentName:"ol"},"Make the handle for the GFXMMU available by adding the line:",(0,n.kt)("pre",{parentName:"li"},(0,n.kt)("code",i({parentName:"pre"},{className:"language-cpp"}),"extern GFXMMU_HandleTypeDef hgfxmmu;\n"))),(0,n.kt)("li",{parentName:"ol"},"Declare a pointer to the virtual framebuffer. For example:",(0,n.kt)("pre",{parentName:"li"},(0,n.kt)("code",i({parentName:"pre"},{className:"language-cpp"}),"static uint16_t* tft = 0;\n"))),(0,n.kt)("li",{parentName:"ol"},"Change the implementation of TouchGFXHAL::setTFTFrameBuffer to give the true framebuffer address to the TFT LTDC controller while TouchGFX framework uses the virtual address through the GFXMMU. Assuming the packing buffers used are buffer 0 and 1, the implementation should be like this:",(0,n.kt)("pre",{parentName:"li"},(0,n.kt)("code",i({parentName:"pre"},{className:"language-cpp"}),"void TouchGFXHAL::setTFTFrameBuffer(uint16_t* address)\n{\n    tft = address;\n    if (tft == (uint16_t*)GFXMMU_VIRTUAL_BUFFER0_BASE)\n    {\n        TouchGFXGeneratedHAL::setTFTFrameBuffer((uint16_t*)hgfxmmu.Init.Buffers.Buf0Address);\n    }\n    else\n    {\n        TouchGFXGeneratedHAL::setTFTFrameBuffer((uint16_t*)hgfxmmu.Init.Buffers.Buf1Address);\n    }\n}\n"))),(0,n.kt)("li",{parentName:"ol"},"Change the implementation of TouchGFXHAL::getTFTFrameBuffer() to",(0,n.kt)("pre",{parentName:"li"},(0,n.kt)("code",i({parentName:"pre"},{className:"language-cpp"}),"uint16_t* TouchGFXHAL::getTFTFrameBuffer() const\n{\n    return tft;\n}\n"))),(0,n.kt)("li",{parentName:"ol"},"Open the project in TouchGFX Designer."),(0,n.kt)("li",{parentName:"ol"},"Go to Config -> Default Image Configuration and select ARGB8888 as the Opaque Image Format."),(0,n.kt)("li",{parentName:"ol"},"Generate code in TouchGFX Designer.")),(0,n.kt)("p",null,"The project will now run with 24 bpp framebuffers, but TouchGFX will still render in 32 bpp.\nAs a result, the performance will naturally be worse compared to 16 bpp and native 24 bpp.\nHowever, since native 24 bpp is not an option on STM32H7R7/S7, this is the best\navailable solution when 24 bpp is required."),(0,n.kt)("h3",i({},{id:"stm32u5-limitations-when-having-framebuffers-in-external-ram"}),"STM32U5 limitations when having framebuffer(s) in external RAM"),(0,n.kt)("p",null,'The NeoChrom accelerator on the STM32U5 MCU family does not integrate\ndedicated write buffers to enable high efficiency when writing to external\nmemories. As a consequence, the NeoChrom accelerator does a lot of "small"\nwrites to the bus where the external memory is connected. This can lead to\nbus contention issues with the diplay controller which reads pixels on the\nsame bus. Therefore, it is recommended to only have framebuffers in internal\nRAM when using the NeoChrom accelerator on STM32U5. If framebuffer must be\nin external RAM, it is recommended to not use the NeoChrom accelerator.\nThe Chrom-ART accelerator can still be used.'),(0,n.kt)("h2",i({},{id:"neochrom-limitations"}),"NeoChrom Limitations"),(0,n.kt)("p",null,"The NeoChrom and NeoChromVG graphics accelerators does not support the\nL8 image formats (L8_RGB565, L8_RGB888, L8_ARGB8888) with TouchGFX. If\nyou use these image formats in a TouchGFX application running on\neither of the micro controllers with NeoChrom/NeoChromVG the images\nwill be drawn using DMA2D. If you use these formats with ScalableImage\nor TextureMapper a software fall-back will be used."),(0,n.kt)("p",null,"It is therefore recommended to not use L8 images with micro controllers\nwith NeoChrom/NeoChromVG accelerators."),(0,n.kt)("p",null,'The NeoChrom graphics accelerator creates suboptimal anti-aliasing on\ngraphics elements drawn with the "Non-zero fill-rule" compared to NeoChromVG.\nThis may happen with SVG files that can specify the fill-rule as "nonzero". A\nwork-around is to use "evenodd" fill-rule, but it is not valid for all\ndrawings.'))}g.isMDXComponent=!0}}]);