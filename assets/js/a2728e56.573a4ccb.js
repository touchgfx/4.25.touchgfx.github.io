"use strict";(self.webpackChunktouchgfx_documentation=self.webpackChunktouchgfx_documentation||[]).push([[30609],{49613:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>f});var o=n(59496);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=o.createContext({}),p=function(e){var t=o.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return o.createElement(s.Provider,{value:t},e.children)},d="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},u=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=p(n),u=r,f=d["".concat(s,".").concat(u)]||d[u]||h[u]||a;return n?o.createElement(f,i(i({ref:t},c),{},{components:n})):o.createElement(f,i({ref:t},c))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,i=new Array(a);i[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[d]="string"==typeof e?e:r,i[1]=l;for(var p=2;p<a;p++)i[p]=n[p];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}u.displayName="MDXCreateElement"},89639:(e,t,n)=>{n.d(t,{Z:()=>a});var o=n(59496),r=n(97395);const a=function(e){const t=e.noShadow||!1,n=e.width,a=e.height,i=(0,r.Z)(e.imageSource);return t?o.createElement("div",{className:"figure noshadow"},o.createElement("a",{href:i,target:"_blank"},o.createElement("img",{width:n,height:a,src:i})),o.createElement("p",null,e.children)):o.createElement("div",{className:"figure"},o.createElement("a",{href:i,target:"_blank"},o.createElement("img",{width:n,height:a,src:i})),o.createElement("p",null,e.children))}},11995:(e,t,n)=>{n.d(t,{Z:()=>a});var o=n(59496);class r extends o.Component{render(){return o.createElement("code",{className:"shortcut"},this.props.children)}}const a=r},50822:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>p,default:()=>m,frontMatter:()=>s,metadata:()=>c,toc:()=>h});n(59496);var o=n(49613),r=n(89639),a=n(11995);function i(){return i=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var o in n)Object.prototype.hasOwnProperty.call(n,o)&&(e[o]=n[o])}return e},i.apply(this,arguments)}function l(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}const s={id:"vector-fonts",title:"Vector Fonts"},p=void 0,c={unversionedId:"development/ui-development/touchgfx-engine-features/vector-fonts",id:"development/ui-development/touchgfx-engine-features/vector-fonts",title:"Vector Fonts",description:"TouchGFX supports using fonts in vector format starting from version",source:"@site/docs/development/ui-development/touchgfx-engine-features/vector-fonts.mdx",sourceDirName:"development/ui-development/touchgfx-engine-features",slug:"/development/ui-development/touchgfx-engine-features/vector-fonts",permalink:"/4.25/docs/development/ui-development/touchgfx-engine-features/vector-fonts",draft:!1,tags:[],version:"current",frontMatter:{id:"vector-fonts",title:"Vector Fonts"},sidebar:"docs",previous:{title:"SVG",permalink:"/4.25/docs/development/ui-development/touchgfx-engine-features/svg"},next:{title:"Image Compression",permalink:"/4.25/docs/development/ui-development/touchgfx-engine-features/image-compression"}},d={},h=[{value:"What are vector fonts",id:"what-are-vector-fonts",level:2},{value:"Example",id:"example",level:3},{value:"Configuration",id:"vector-configuration",level:2},{value:"Using vector fonts",id:"vector-using",level:2},{value:"Typographies",id:"vector-typographies",level:2},{value:"Architecture",id:"vector-architecture",level:2},{value:"Limitations",id:"vector-limitations",level:2},{value:"Winding rules",id:"winding-rules",level:3},{value:"Using FontForge",id:"using-fontforge",level:4},{value:"Storage",id:"vector-storage",level:3},{value:"Thai",id:"thai",level:3}],u={toc:h},f="wrapper";function m(e){var{components:t}=e,n=l(e,["components"]);return(0,o.kt)(f,i({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"TouchGFX supports using fonts in vector format starting from version\n4.23. Fonts stored in vector format can potentially reduce the size of the font data\nas the font data is shared between all sizes of a font. This is\nin contrast to bitmap fonts where every size of a font contains\ndedicated bitmaps of the glyphs in that size."),(0,o.kt)("p",null,"Vector fonts are used on the user interface just like the normal\nbitmap fonts using widgets like TextArea or ButtonWithLabel."),(0,o.kt)("p",null,"To use the vector font format, the vector font functionality must be enabled for the platform in\nSTM32CubeMX."),(0,o.kt)("p",null,"Vector fonts are only supported on 16bpp, 24bpp, or 32bpp frame buffers."),(0,o.kt)("h2",i({},{id:"what-are-vector-fonts"}),"What are vector fonts"),(0,o.kt)("p",null,"Vector fonts are fonts where the individual letters are described by\ncurves and lines. These curves and lines can be scaled up and down to\nproduce glyphs in different sizes. All the fonts we normally use in\nTouchGFX are vector fonts (for example TrueType or OpenType\nfonts). The curves and lines in the font description are converted to\nmany small bitmaps by the TouchGFX Font Converter when TouchGFX\nDesigner generates assets."),(0,o.kt)("p",null,"The conversion of vector fonts to bitmaps is based on the typographies\ndefined in TouchGFX Designer. For example, an application may use two\ntypographies, Large and Small. Large could be based on Verdana in size\n30 and Small could be based on Verdana in size 20. If we assume that the application\nis using the glyphs A-Z and a-z in these typographies we get 52\nglyphs for each typography, but the appplication will contain 104\nbitmaps, as we get two bitmaps for each letter. One bitmap for size 30\nand one for size 20."),(0,o.kt)("p",null,"Vector fonts are different because we keep the vector definition for a\nglyph and do not create a bitmap of the glyph. This vector definition\nis instead included in the target application one time only. The only\nextra data that is needed to produce the two required typographies is\ntwo different scaling factors. One to scale the vector definitions to\nsize 30 and one to scale to size 20."),(0,o.kt)("p",null,"As a result, if we add another typography size to the example application - for\nexample Verdana in size 40 - the flash requirement will only increase\nmarginally."),(0,o.kt)("h3",i({},{id:"example"}),"Example"),(0,o.kt)("p",null,'To give an example, the vector definition for "G" in the Truetype font\nVerdana is 170 bytes.'),(0,o.kt)("p",null,'The size of the bitmap representing the glyph depends on the bpp used\nand the size of the glyph. The table below shows the bitmap size for\n"G" in various glyph sizes in 4bpp:'),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",i({parentName:"tr"},{align:null}),"Font size"),(0,o.kt)("th",i({parentName:"tr"},{align:null}),"G glyph dimension / pixels"),(0,o.kt)("th",i({parentName:"tr"},{align:null}),"Bitmap size / bytes"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",i({parentName:"tr"},{align:null}),"20"),(0,o.kt)("td",i({parentName:"tr"},{align:null}),"14 x 14"),(0,o.kt)("td",i({parentName:"tr"},{align:null}),"98")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",i({parentName:"tr"},{align:null}),"30"),(0,o.kt)("td",i({parentName:"tr"},{align:null}),"21 x 22"),(0,o.kt)("td",i({parentName:"tr"},{align:null}),"242")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",i({parentName:"tr"},{align:null}),"40"),(0,o.kt)("td",i({parentName:"tr"},{align:null}),"27 x 32"),(0,o.kt)("td",i({parentName:"tr"},{align:null}),"448")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",i({parentName:"tr"},{align:null}),"Total"),(0,o.kt)("td",i({parentName:"tr"},{align:null})),(0,o.kt)("td",i({parentName:"tr"},{align:null}),"788")))),(0,o.kt)("p",null,'We see that the bitmap size for font size 20 is smaller than the\nvector definition of "G", but already at size 30 the vector definition\nis smaller than the bitmap size. And if we use three different sizes of Verdana,\nwe use 788 bytes for the bitmaps while the vector definition still only uses 170 bytes. We therefore save 78% of the flash usage.'),(0,o.kt)("p",null,"This storage saving comes with a disadvantage - performance. When we\nneed to draw a glyph, we have to convert the vector definition to\npixels. This is done by scaling and translating the vector definition\nof a glyph and then render it to the framebuffer."),(0,o.kt)("p",null,'A single "G" in Verdana consists of 20 Bezier curves and 6 straight\nline-pieces. These are all converted into an outline, which is finally\ncolored using the selected text color. This process is repeated for\nall the letters in the text and repeated whenever the text is redrawn.'),(0,o.kt)("p",null,"The above process is hardware accelerated on microcontrollers with\nGPU2D (for example STM32U5G9) where it works well. On slow\nmicrocontrollers like STM32G0, without floating point hardware, it would be very demanding for the hardware to perform these operations."),(0,o.kt)("p",null,"In such cases, the rendering time would be better if bitmap fonts are used. It is therefore\nrecommended to use vector fonts where the flash-savings are necessary\nand otherwise use bitmap fonts.",(0,o.kt)("br",{parentName:"p"}),"\n","If a text is animated (scrolled, moved or faded) it is recommended to\nuse bitmap fonts."),(0,o.kt)("h2",i({},{id:"vector-configuration"}),"Configuration"),(0,o.kt)("p",null,"The use of vector fonts requires the additional framework features ",(0,o.kt)("inlineCode",{parentName:"p"},"Vector Rendering")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Vector Fonts"),". These are enabled in\nSTM32CubeMX. See the ",(0,o.kt)("a",i({parentName:"p"},{href:"../../touchgfx-hal-development/generator-how-to/touchgfx-al-configuration/additional-features#vector-rendering"}),"Generator User Guide")," for more information."),(0,o.kt)("p",null,"Typographies are configured in TouchGFX Designer. Here you can\nselect if a typography should use bitmap font format or a vector font format in\nfor the project. The default is bitmap font format."),(0,o.kt)("h2",i({},{id:"vector-using"}),"Using vector fonts"),(0,o.kt)("p",null,"Vector fonts are used exactly as bitmap fonts in TouchGFX. You create\ntexts either as named resources or single use texts. You show the text\nin one of the widgets, for example a TextArea. The differences between vector fonts and bitmap fonts are hidden in\nthe rendering code."),(0,o.kt)("h2",i({},{id:"vector-typographies"}),"Typographies"),(0,o.kt)("p",null,"Vector fonts are generated when a typography in is configured to be vector based in TouchGFX Designer. See the ",(0,o.kt)("a",i({parentName:"p"},{href:"../designer-user-guide/texts-view#typographies"}),"Designer User\nGuide"),"."),(0,o.kt)("p",null,"If multiple typographies uses the same font (e.g. Verdana), the\ntypographies will share the vector definitions in the project, but use\nthem with a different scale factor to produce glyphs of different\nsizes."),(0,o.kt)("p",null,"This also means that the typography attributes ",(0,o.kt)("inlineCode",{parentName:"p"},"Fallback Character"),"\nand ",(0,o.kt)("inlineCode",{parentName:"p"},"Ellipsis Character")," must be the same for the typographies. "),(0,o.kt)("p",null,"The characters used in the typographies (including wildcard\ncharacters) are combined and made available for all the typographies\nin the project using the same font."),(0,o.kt)("h2",i({},{id:"vector-architecture"}),"Architecture"),(0,o.kt)("p",null,"Rendering of vector fonts is based on a new component\n",(0,o.kt)("inlineCode",{parentName:"p"},"VectorFontRenderer"),". This component uses the ",(0,o.kt)("inlineCode",{parentName:"p"},"VectorRenderer"),"\ncomponent to draw the glyphs."),(0,o.kt)("p",null,"In a project that uses vector fonts, these two components must be made\navailable. This is done by STM32CubeMX automatically if these are\nenabled. It must be done manually if you are not using STM32CubeMX."),(0,o.kt)("p",null,"Here is the code generated by STM32CubeMX with the relevant lines\nhighlighted:"),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-cpp",metastring:"{5-5,19-19}","{5-5,19-19}":!0}),"static STM32TouchController tc;\nstatic STM32DMA dma;\nstatic TouchGFXDataReader dataReader;\nstatic LCD16bppSerialFlash display(dataReader);\nstatic VectorFontRendererImpl vectorFontRenderer;\nstatic ApplicationFontProvider fontProvider;\nstatic Texts texts;\nstatic TouchGFXHAL hal(dma, display, tc, 240, 320);\n\nvoid touchgfx_init()\n{\n    Bitmap::registerBitmapDatabase(BitmapDatabase::getInstance(), BitmapDatabase::getInstanceSize());\n    TypedText::registerTexts(&texts);\n    Texts::setLanguage(0);\n\n    hal.setDataReader(&dataReader);\n    fontProvider.setFlashReader(&dataReader);\n\n    display.setVectorFontRenderer(&vectorFontRenderer);\n    ...\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"VectorRenderer")," component must also be provided (from ",(0,o.kt)("inlineCode",{parentName:"p"},"TouchGFXGeneratedHAL.cpp"),"):"),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-cpp"}),"namespace touchgfx\n{\nVectorRenderer* VectorRenderer::getInstance()\n{\n    static CWRVectorRendererRGB565 renderer;\n\n    return &renderer;\n}\n} // namespace touchgfx\n")),(0,o.kt)("p",null,"If you are on a platform with the GPU2D accelerator, you should use ",(0,o.kt)("inlineCode",{parentName:"p"},"CPU2DVectorRenderer")," instead of ",(0,o.kt)("inlineCode",{parentName:"p"},"CWRVectorRendererRGB565"),". This will enable\nhardware acceleration."),(0,o.kt)("h2",i({},{id:"vector-limitations"}),"Limitations"),(0,o.kt)("h3",i({},{id:"winding-rules"}),"Winding rules"),(0,o.kt)("p",null,"Vector font typographies used in TouchGFX applications are required to follow certain rules in order for glyphs to be drawn correctly.\nSpecifically, glyphs with overlapping outlines are sometimes not rendered correctly due to the ",(0,o.kt)("em",{parentName:"p"},"winding rule")," deployed by TouchGFX when drawing vector fonts.\nTo remove overlapping outlines from custom typographies, it is recommended to use the free ",(0,o.kt)("a",i({parentName:"p"},{href:"https://fontforge.org/en-US/downloads/windows/"}),(0,o.kt)("em",{parentName:"a"},"FontForge"))," tool."),(0,o.kt)("h4",i({},{id:"using-fontforge"}),"Using FontForge"),(0,o.kt)("p",null,"Navigate to the FontForge installation folder (usually ",(0,o.kt)("inlineCode",{parentName:"p"},"c:/Program Files (x86)/FontForgeBuilds"),") and launch the ",(0,o.kt)("inlineCode",{parentName:"p"},".exe"),":"),(0,o.kt)(r.Z,{width:"40%",imageSource:"/img/development/ui-development/touchgfx-engine-features/vector-fonts/ff-open-font.png",mdxType:"Figure"},"FontForge launch view."),(0,o.kt)("p",null,"Navigate to the ",(0,o.kt)("inlineCode",{parentName:"p"},"assets/fonts/")," folder of your project, e.g., ",(0,o.kt)("inlineCode",{parentName:"p"},"c:/TouchGFXProjects/MyApplication/TouchGFX/assets/fonts/"),". FontForge will detect all the ",(0,o.kt)("em",{parentName:"p"},"TrueType")," fonts in the application.\nIn this example, the ",(0,o.kt)("em",{parentName:"p"},"Cairo-Bold.ttf")," TrueType font contains overlapping outlines which are not drawn correctly:"),(0,o.kt)(r.Z,{width:"40%",imageSource:"/img/development/ui-development/touchgfx-engine-features/vector-fonts/ff-select-font.png",mdxType:"Figure"},"FontForge open TrueType font view."),(0,o.kt)("p",null,"Clicking ",(0,o.kt)("inlineCode",{parentName:"p"},"OK")," will open the ",(0,o.kt)("em",{parentName:"p"},"font view")," of all the glyphs in the typography:"),(0,o.kt)(r.Z,{width:"80%",imageSource:"/img/development/ui-development/touchgfx-engine-features/vector-fonts/ff-font-view.png",mdxType:"Figure"},"FontForge font view."),(0,o.kt)("p",null,"To remove overlapping contours from glyphs, select all glyphs in the font view with ",(0,o.kt)(a.Z,{mdxType:"Shortcut"},"Ctrl + A"),". Next, with all glyphs selected use shortcut ",(0,o.kt)(a.Z,{mdxType:"Shortcut"},"Ctrl + u")," followed\nby ",(0,o.kt)(a.Z,{mdxType:"Shortcut"},"Ctrl + Shift + O")," to remove overlapping contours from selected glyphs. A blue mark will appear above all glyphs, indicating they have been changed. The effect can be seen by double-clicking on\nindividual glyphs. An example is shown of the ",(0,o.kt)("inlineCode",{parentName:"p"},"$")," glyph from before and after removing overlapping contours below:"),(0,o.kt)(r.Z,{width:"80%",imageSource:"/img/development/ui-development/touchgfx-engine-features/vector-fonts/ff-dollar-glyph-comparison.png",noShadow:!0,mdxType:"Figure"},"$-glyph with overlapping contours (left) and non-overlapping contours (right)."),(0,o.kt)("p",null,"Observe that the outline of the glyph remains unaffected, but contours which were overlapping are merged. To use the non-overlapping typography in a TouchGFX application we use FontForge to export the new font.\nIn the FontForge ",(0,o.kt)("em",{parentName:"p"},"font view"),", use shortcut ",(0,o.kt)(a.Z,{mdxType:"Shortcut"},"Ctrl + Shift + G")," to export the fonts. This opens the ",(0,o.kt)("em",{parentName:"p"},"Generate Fonts"),' view. It is recommended to rename the typography, e.g., with "-no-overlap" as a suffix,\nto avoid overwriting the original font in case of an error. Select ',(0,o.kt)("inlineCode",{parentName:"p"},"TrueType")," as output format. The settings should be set as shown below:"),(0,o.kt)(r.Z,{width:"30%",imageSource:"/img/development/ui-development/touchgfx-engine-features/vector-fonts/ff-generate-fonts.png",mdxType:"Figure"},"FontForge generate font settings."),(0,o.kt)("p",null,"Press ",(0,o.kt)("inlineCode",{parentName:"p"},"Generate")," to export the fonts. Press ",(0,o.kt)("em",{parentName:"p"},"Yes")," if warnings appear. The exported typography will appear next to the original TrueType font in the ",(0,o.kt)("inlineCode",{parentName:"p"},"assets/fonts/")," folder of your project.\nThe original font can be removed from this folder and placed elsewhere on disk, to avoid having multiple typographies of the same name appear in the TouchGFX Designer. Restart TouchGFX Designer\nto make the new font visible in the font selector. If you had generated code in TouchGFX Designer before modifying the font, make sure to remove the ",(0,o.kt)("inlineCode",{parentName:"p"},"generated/fonts/")," folder before\ngenerating code again."),(0,o.kt)("h3",i({},{id:"vector-storage"}),"Storage"),(0,o.kt)("p",null,"Vector font data must be stored in a memory mapped area. This can be\ninternal flash, external QSPI/OSPI flash in memory-mapped mode, RAM,\nor other similar memories."),(0,o.kt)("p",null,"If your platform stores other font data in non-memory-mapped data you\nmust change the linker script to move all vector font data to\ne.g. internal flash. Here is how to do this with ARM gcc:"),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{}),'  /* Constant data into "FLASH" Rom type memory */\n  .FontFlashSection :\n  {\n    . = ALIGN(4);\n    */Vector_*.o(FontFlashSection)         /* Vector font data  */\n    . = ALIGN(4);\n  } >FLASH\n\n  FontFlashSection :\n  {\n    *(FontFlashSection FontFlashSection.*)\n    *(.gnu.linkonce.r.*)\n    . = ALIGN(0x4);\n  } >SPI_FLASH\n')),(0,o.kt)("p",null,"This puts font data from files matching ",(0,o.kt)("inlineCode",{parentName:"p"},"*/Vector_*.o/")," into the ",(0,o.kt)("inlineCode",{parentName:"p"},"FLASH"),"\nregion and other font data into the ",(0,o.kt)("inlineCode",{parentName:"p"},"SPI_FLASH")," region."),(0,o.kt)("p",null,"Vector font data is generated into files like\n",(0,o.kt)("inlineCode",{parentName:"p"},"generated/fonts/src/Vector_Font_Verdana.cpp")," and similar."),(0,o.kt)("h3",i({},{id:"thai"}),"Thai"),(0,o.kt)("p",null,"It is a known issue that Thai does not render correctly with vector\nfonts. The work around is to use a bitmap font for Thai."))}m.isMDXComponent=!0}}]);