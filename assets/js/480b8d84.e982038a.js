"use strict";(self.webpackChunktouchgfx_documentation=self.webpackChunktouchgfx_documentation||[]).push([[5619],{49613:(e,t,r)=>{r.d(t,{Zo:()=>p,kt:()=>u});var a=r(59496);function n(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,a)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){n(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function l(e,t){if(null==e)return{};var r,a,n=function(e,t){if(null==e)return{};var r,a,n={},o=Object.keys(e);for(a=0;a<o.length;a++)r=o[a],t.indexOf(r)>=0||(n[r]=e[r]);return n}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)r=o[a],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}var s=a.createContext({}),c=function(e){var t=a.useContext(s),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},p=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var r=e.components,n=e.mdxType,o=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),m=c(r),h=n,u=m["".concat(s,".").concat(h)]||m[h]||d[h]||o;return r?a.createElement(u,i(i({ref:t},p),{},{components:r})):a.createElement(u,i({ref:t},p))}));function u(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=r.length,i=new Array(o);i[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[m]="string"==typeof e?e:n,i[1]=l;for(var c=2;c<o;c++)i[c]=r[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,r)}h.displayName="MDXCreateElement"},89639:(e,t,r)=>{r.d(t,{Z:()=>o});var a=r(59496),n=r(97395);const o=function(e){const t=e.noShadow||!1,r=e.width,o=e.height,i=(0,n.Z)(e.imageSource);return t?a.createElement("div",{className:"figure noshadow"},a.createElement("a",{href:i,target:"_blank"},a.createElement("img",{width:r,height:o,src:i})),a.createElement("p",null,e.children)):a.createElement("div",{className:"figure"},a.createElement("a",{href:i,target:"_blank"},a.createElement("img",{width:r,height:o,src:i})),a.createElement("p",null,e.children))}},48753:(e,t,r)=>{r.d(t,{Z:()=>l});var a=r(59496),n=r(96151);const o=a.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},a.createElement("path",{fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}));class i extends a.Component{render(){return a.createElement(n.Z,{color:"var(--highlight-color-further-reading)",header:"Further reading",type:"further-reading",icon:o},this.props.children)}}const l=i},96151:(e,t,r)=>{r.d(t,{Z:()=>o});var a=r(59496);class n extends a.Component{render(){const e=`highlight highlight-${this.props.type}`;return a.createElement("div",{className:e},a.createElement("div",{className:"highlight-heading"},a.createElement("h5",null,a.createElement("div",{className:"highlight-icon"},this.props.icon),this.props.header)),a.createElement("div",{className:"highlight-content"},this.props.children))}}const o=n},49018:(e,t,r)=>{r.d(t,{Z:()=>l});var a=r(59496),n=r(96151);const o=a.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},a.createElement("path",{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}));class i extends a.Component{render(){return a.createElement(n.Z,{color:"var(--highlight-color-note)",header:"Note",type:"note",icon:o},this.props.children)}}const l=i},9102:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>h,contentTitle:()=>m,default:()=>k,frontMatter:()=>p,metadata:()=>d,toc:()=>u});r(59496);var a=r(49613),n=r(89639),o=r(48753),i=r(18399),l=r(49018);function s(){return s=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var a in r)Object.prototype.hasOwnProperty.call(r,a)&&(e[a]=r[a])}return e},s.apply(this,arguments)}function c(e,t){if(null==e)return{};var r,a,n=function(e,t){if(null==e)return{};var r,a,n={},o=Object.keys(e);for(a=0;a<o.length;a++)r=o[a],t.indexOf(r)>=0||(n[r]=e[r]);return n}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)r=o[a],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}const p={id:"hardware-selection-mcu",title:"MCU"},m=void 0,d={unversionedId:"development/hardware-selection/hardware-components/hardware-selection-mcu",id:"development/hardware-selection/hardware-components/hardware-selection-mcu",title:"MCU",description:"The microcontroller unit (MCU) is at the core of any embedded solution and there are a wide variety of options in terms of both cost and features.",source:"@site/docs/development/hardware-selection/hardware-components/hardware-selection-mcu.mdx",sourceDirName:"development/hardware-selection/hardware-components",slug:"/development/hardware-selection/hardware-components/hardware-selection-mcu",permalink:"/4.25/docs/development/hardware-selection/hardware-components/hardware-selection-mcu",draft:!1,tags:[],version:"current",frontMatter:{id:"hardware-selection-mcu",title:"MCU"},sidebar:"docs",previous:{title:"Hardware Components",permalink:"/4.25/docs/category/hardware-components"},next:{title:"Display",permalink:"/4.25/docs/development/hardware-selection/hardware-components/hardware-selection-display"}},h={},u=[{value:"Frequency",id:"frequency",level:2},{value:"Graphic Subsystem Frequency",id:"graphic-subsystem-frequency",level:3},{value:"Embedded Hardware Acceleration Features",id:"embedded-hardware-acceleration-features",level:2},{value:"NeoChrom GPU",id:"neochrom",level:3},{value:"Chrom-ART",id:"chrom-art",level:3},{value:"JPEG Hardware Codec",id:"jpeg-hardware-codec",level:3},{value:"Chrom-GRC",id:"chrom-grc",level:3},{value:"Internal Flash",id:"internal-flash",level:2},{value:"Internal RAM",id:"internal-ram",level:2},{value:"LCD Controller",id:"lcd-controller",level:2},{value:"Packages &amp; I/O",id:"packages--io",level:2},{value:"Memory Interfacing",id:"memory-interfacing",level:2},{value:"Flexible Memory Controller &amp; Flexible Static Memory Controller (FMC/FSMC)",id:"flexible-memory-controller--flexible-static-memory-controller-fmcfsmc",level:3},{value:"Serial Memory Interface",id:"serial-memory-interface",level:3},{value:"Cortex\xae-M Cores",id:"cortex-m-cores",level:2},{value:"Cortex\xae-M0+",id:"cortex-m0",level:3},{value:"Cortex\xae-M4",id:"cortex-m4",level:3},{value:"Cortex\xae-M7",id:"cortex-m7",level:3},{value:"Cortex\xae-M33",id:"cortex-m33",level:3},{value:"Cortex\xae-M55",id:"cortex-m55",level:3},{value:"Feature overview",id:"feature-overview",level:3},{value:"Level 1 cache",id:"level-1-cache",level:3},{value:"Dual core",id:"dual-core",level:3},{value:"Bus architecture",id:"bus-architecture",level:2},{value:"Price",id:"price",level:2}],f={toc:u},g="wrapper";function k(e){var{components:t}=e,r=c(e,["components"]);return(0,a.kt)(g,s({},f,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"The microcontroller unit (MCU) is at the core of any embedded solution and there are a wide variety of options in terms of both cost and features."),(0,a.kt)("p",null,"When selecting an MCU for graphics, it is important to consider the supported display interfaces, the MCU package size, and the achievable graphics performance, which depends on two main factors:"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Image composition")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The availability of graphics accelerators integrated in the MCU."),(0,a.kt)("li",{parentName:"ul"},"The availability of cache memory in the system.")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Memory access and bandwidth")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The clock frequency and the subsystem bus frequency."),(0,a.kt)("li",{parentName:"ul"},"The access to the internal flash and RAM memories.")),(0,a.kt)("p",null,"It is also important to consider other aspects of the application, such as e.g. motor control or wireless communication, which run in addition to the graphics. These factors can influence the choice of MCU."),(0,a.kt)("p",null,"This page will explore the various MCU options and the parameters to consider when selecting an STM32 MCU for a GUI-driven application."),(0,a.kt)(n.Z,{imageSource:"/img/development/hardware-selection/mcu/mcu-portfolio-graphics.png",noShadow:!0,width:"600",mdxType:"Figure"},"STM32 MCUs for graphics"),(0,a.kt)("p",null,"For a complete overview of the STM32 MCUs listed above, including information about internal memory and peripherals, see the ",(0,a.kt)("a",s({parentName:"p"},{href:"https://www.st.com/content/st_com/en/stm32-mcu-developer-zone/mcu-portfolio.html"}),"STM32 MCU portfolio"),"."),(0,a.kt)(o.Z,{mdxType:"FurtherReading"},(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The complete STM32 MCU portfolio can be found ",(0,a.kt)("a",s({parentName:"li"},{href:"https://www.st.com/content/st_com/en/stm32-mcu-developer-zone/mcu-portfolio.html"}),"here"),"."),(0,a.kt)("li",{parentName:"ul"},"For a more complete overview of all product lines, including prices etc., ",(0,a.kt)("a",s({parentName:"li"},{href:"https://www.st.com/en/development-tools/st-mcu-finder.html"}),"the ST MCU Finder is available here"),"."))),(0,a.kt)("h2",s({},{id:"frequency"}),"Frequency"),(0,a.kt)("p",null,"The core frequency has a major impact on the performance of a graphical application in terms of screen refresh, fluidity of screens, and animations."),(0,a.kt)("p",null,"It impacts the amount of data that can be transferred from an internal or external memory to the display framebuffer and also the calculations and animations possible."),(0,a.kt)("p",null,"The higher the frequency, the more data it is possible to transfer within a given timeframe and the more complex animations can be made."),(0,a.kt)("p",null,"The core frequency of STM32 MCUs is up to ",(0,a.kt)("strong",{parentName:"p"},"800MHz"),"."),(0,a.kt)(l.Z,{mdxType:"Note"},"The higher the frequency, the greater the power consumption."),(0,a.kt)("h3",s({},{id:"graphic-subsystem-frequency"}),"Graphic Subsystem Frequency"),(0,a.kt)("p",null,"It is important to differentiate the core CPU frequency from the graphic subsystem frequency. The graphic subsystem frequency includes the frequency of the internal busses, the frequency of the graphics accelerator as well as the access speed of the internal and external memories."),(0,a.kt)("p",null,"The graphic subsystem frequency also has a major impact on the overall graphic performance."),(0,a.kt)("p",null,"An example of how to calculate the performance of a graphics subsystem can be found in ",(0,a.kt)("a",s({parentName:"p"},{href:"../../scenarios/running-graphics-from-external-ram"}),"this article"),".\nThe article focuses on framebuffers in external RAM, but the same procedure can be applied to internal RAM as well."),(0,a.kt)("h2",s({},{id:"embedded-hardware-acceleration-features"}),"Embedded Hardware Acceleration Features"),(0,a.kt)("p",null,"Different STM32 MCUs have different built-in hardware acceleration features that help in achieving high performing graphics applications."),(0,a.kt)("h3",s({},{id:"neochrom"}),"NeoChrom GPU"),(0,a.kt)("p",null,"NeoChrom GPU can hardware accelerate some graphical operations such as texture mapping, scaling and vector rendering. It is also known as GPU2D."),(0,a.kt)("p",null,"NeoChrom GPU also comes in a version called NeoChromVG GPU, which can further accelerate vector rendering."),(0,a.kt)("p",null,"For a detailed description of NeoChrom GPU and its capabilities, visit the article about ",(0,a.kt)("a",s({parentName:"p"},{href:"../../scenarios/touchgfx-on-gpu2d"}),"TouchGFX on NeoChrom/NeoChromVG"),"."),(0,a.kt)("h3",s({},{id:"chrom-art"}),"Chrom-ART"),(0,a.kt)("p",null,"Chrom-ART is an advanced DMA that aids in doing graphical operations. It is also known as DMA2D."),(0,a.kt)("p",null,"The Chrom-ART accelerator, integrated in many STM32 platforms, is able to manipulate and transfer images without CPU load. It has the capability to accelerate the majority of the graphic operations, such as color filling, image copying, blending, and pixel format conversions."),(0,a.kt)("p",null,"The Chrom-ART accelerator is able to perform blending of two layers and convert the initial pixel formats to the desired output pixel format and transfer the result to the memory destination in only one operation."),(0,a.kt)("p",null,"The Chrom-ART accelerator also supports color formats with color look up tables (CLUT). This can help with saving memory."),(0,a.kt)("p",null,"Example of an application running on the ",(0,a.kt)("strong",{parentName:"p"},"STM32F469-EVAL")," board where the CPU load is decreased from ",(0,a.kt)("strong",{parentName:"p"},"82%")," to ",(0,a.kt)("strong",{parentName:"p"},"4%")," when the Chrom-ART is enabled:"),(0,a.kt)(n.Z,{imageSource:"/img/development/hardware-selection/mcu/birdeatcoin.webp",mdxType:"Figure"},"Bird-Eat-Coin Chrom-ART example"),(0,a.kt)("p",null,"In addition, the capability to convert from ",(0,a.kt)("strong",{parentName:"p"},"YCbCr")," format to ",(0,a.kt)("strong",{parentName:"p"},"RGB")," format is added with STM32H7 products to the Chrom-ART peripheral.\nThis feature, combined with the JPEG hardware codec can offload the CPU when encoding and decoding JPEG images."),(0,a.kt)(n.Z,{imageSource:"/img/development/hardware-selection/mcu/chrom-art-acceleration.webp",noShadow:!0,width:"500",mdxType:"Figure"},"YCbCr to RGB Hardware performance"),(0,a.kt)("p",null,"The Chrom-ART accelerator, with the features listed above, offers a huge advantage for graphical applications.\nIf available in the chosen MCU, TouchGFX handles all Chrom-ART features and redirects all possible drawing operations to the Chrom-ART peripheral instead of the CPU."),(0,a.kt)("p",null,"The Chrom-ART peripheral is available with high performance STM32 families."),(0,a.kt)(o.Z,{mdxType:"FurtherReading"},(0,a.kt)("li",null,"Refer to AN4943 application note for more information:, ",(0,a.kt)(i.Z,{to:"https://www.st.com/content/ccc/resource/technical/document/application_note/group0/17/82/73/f8/b8/8a/47/c7/DM00338361/files/DM00338361.pdf/jcr:content/translations/en.DM00338361.pdf",mdxType:"Link"},"Chrom-ART Hardware acceleration"),".")),(0,a.kt)("h3",s({},{id:"jpeg-hardware-codec"}),"JPEG Hardware Codec"),(0,a.kt)("p",null,"Some STM32 families provide a hardware JPEG codec to encode and decode images and videos."),(0,a.kt)("p",null,"This feature is important if the UI application needs to play a video file or display JPEG images."),(0,a.kt)("p",null,"JPEG images generally take up less memory. The JPEG hardware codec ensures that the images can be decoded at runtime without CPU overload."),(0,a.kt)("p",null,"Some TouchGFX demos utilizes the JPEG hardware codec, offloading the CPU while playing an MJPEG video."),(0,a.kt)(n.Z,{imageSource:"/img/development/hardware-selection/mcu/jpeg-codec-acceleration.webp",noShadow:!0,width:"500",mdxType:"Figure"},"Hardware JPEG codec performance"),(0,a.kt)(o.Z,{mdxType:"FurtherReading"},(0,a.kt)("li",null,"Refer to AN4996 application note for more information: ",(0,a.kt)(i.Z,{to:"https://www.st.com/content/ccc/resource/technical/document/application_note/group0/a5/9d/22/46/61/6d/4a/ab/DM00356635/files/DM00356635.pdf/jcr:content/translations/en.DM00356635.pdf",mdxType:"Link"},"Hardware JPEG codec"),".")),(0,a.kt)("h3",s({},{id:"chrom-grc"}),"Chrom-GRC"),(0,a.kt)("p",null,"The STM32 Chrom-GRC\u2122 (GFXMMU) is a peripheral in some STM32 microcontrollers that aims to efficiently support the\nemerging trend towards non-rectangular displays."),(0,a.kt)("p",null,"The Chrom-GRC\u2122 peripheral enables applications to reduce the amount of RAM needed for storing the framebuffer when addressing non-rectangular displays."),(0,a.kt)("p",null,"In the case of a round display, the peripheral reduces the memory requirements by ",(0,a.kt)("strong",{parentName:"p"},"20%"),"."),(0,a.kt)("p",null,"The Chrom-GRC\u2122 peripheral is not mandatory when controlling non-square screens, but it is recommended."),(0,a.kt)("p",null,"Chrom-GRC\u2122 is also utilized when using ",(0,a.kt)("a",s({parentName:"p"},{href:"../../../basic-concepts/framebuffer#display-without-gram-partial-buffering"}),"emulated framebuffer"),"."),(0,a.kt)(n.Z,{imageSource:"/img/development/hardware-selection/mcu/stm-32-chrom-grc.webp",noShadow:!0,width:"600",mdxType:"Figure"},"Memory optimization with Chrom-GRC peripheral"),(0,a.kt)(o.Z,{mdxType:"FurtherReading"},(0,a.kt)("li",null,"Refer to AN5051 application note for more information: ",(0,a.kt)(i.Z,{to:"https://www.st.com/content/ccc/resource/technical/document/application_note/group0/74/21/86/42/af/d5/4f/58/DM00407777/files/DM00407777.pdf/jcr:content/translations/en.DM00407777.pdf",mdxType:"Link"},"Graphic memory optimization"),".")),(0,a.kt)("h2",s({},{id:"internal-flash"}),"Internal Flash"),(0,a.kt)("p",null,"A graphical user interface application using bitmap resources needs non-volatile memory to store the data.\nThe execution from and access to internal flash is in some cases up to several times faster than external flash."),(0,a.kt)("p",null,"As the internal flash is limited in size, in many cases it is often used for storing the TouchGFX framework, screen definitions and UI logic while the bitmap data is stored in external flash."),(0,a.kt)("p",null,"The portfolio of STM32 products used for graphic applications is between ",(0,a.kt)("strong",{parentName:"p"},"0 Kbytes")," and up to ",(0,a.kt)("strong",{parentName:"p"},"a few Mbytes")," of internal flash memory."),(0,a.kt)("p",null,"External memory may be required when the amount of bitmap data does not fit within internal flash."),(0,a.kt)(o.Z,{mdxType:"FurtherReading"},"Refer to ",(0,a.kt)(i.Z,{to:"hardware-selection-external-memories",mdxType:"Link"},"External Memories")," for more details."),(0,a.kt)("p",null,"TouchGFX flash memory requirement:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Framework:                       ",(0,a.kt)("strong",{parentName:"li"},"60kbytes")," to ",(0,a.kt)("strong",{parentName:"li"},"100kbytes"),"."),(0,a.kt)("li",{parentName:"ul"},"Screen definition and GUI logic: ",(0,a.kt)("strong",{parentName:"li"},"1kbytes")," to ",(0,a.kt)("strong",{parentName:"li"},"100kbytes"),".")),(0,a.kt)("p",null,"These numbers depend on the framework features used and the size and complexity of the application."),(0,a.kt)("h2",s({},{id:"internal-ram"}),"Internal RAM"),(0,a.kt)("p",null,"Internal RAM can be used for storing the framebuffer(s), when the size of these fit within the available memory. Alternatively one might add external memory to the setup."),(0,a.kt)("p",null,"Calculating the size of a framebuffer depends on the width, height and color depth. For example, a display with HVGA resolution (480x320) and 16 bit colors, the memory needed for one framebuffer is:"),(0,a.kt)("p",null,"Size of 1 framebuffer = ",(0,a.kt)("strong",{parentName:"p"},"480 x 320 x 2")," =  ",(0,a.kt)("strong",{parentName:"p"},"307,200 bytes")),(0,a.kt)("p",null,"The STM32 products used for graphic applications ranges from ",(0,a.kt)("strong",{parentName:"p"},"a few Kbytes")," and ",(0,a.kt)("strong",{parentName:"p"},"a few Mega Bytes")," of internal RAM."),(0,a.kt)(o.Z,{mdxType:"FurtherReading"},"Refer to the ",(0,a.kt)(i.Z,{to:"hardware-selection-external-memories",mdxType:"Link"},"External Memories")," section for more details on framebuffers in external memory."),(0,a.kt)("p",null,"TouchGFX RAM requirement:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Framework:          ",(0,a.kt)("strong",{parentName:"li"},"10Kbytes")," to ",(0,a.kt)("strong",{parentName:"li"},"30Kbytes")),(0,a.kt)("li",{parentName:"ul"},"Widgets:            ",(0,a.kt)("strong",{parentName:"li"},"1Kbytes")," to ",(0,a.kt)("strong",{parentName:"li"},"15Kbytes"))),(0,a.kt)("p",null,"Memory requirements may vary from application to application."),(0,a.kt)("h2",s({},{id:"lcd-controller"}),"LCD Controller"),(0,a.kt)("p",null,"The choice of the MCU also depends on the display interface that will be used and the resolution.\nThe 800x480 resolution for example can only be achieved with an efficient interface in terms of data transfer speed.\nRGB-TFT and MPI-DSI interfaces are often used for higher resolutions, as the bandwidth is in many cases higher than SPI or parallel 8080/6800.\nSmall resolution displays often embed controller and GRAM and so can be connected through simple SPI or 8080/6800 interfaces."),(0,a.kt)("p",null,"High resolution displays (WQVGA and above) often don\u2019t embed controller and GRAM, therefore the controller needs to be at the microcontroller side. On STM32 MCUs embedding RGB-TFT and MIPI DSI interfaces the controller is present."),(0,a.kt)(n.Z,{imageSource:"/img/development/hardware-selection/mcu/display-interfaces.webp",noShadow:!0,width:"700",mdxType:"Figure"},"The picture shows 4 examples of different display interfaces with/without GRAM and display controller."),(0,a.kt)(o.Z,{mdxType:"FurtherReading"},"Refer to the ",(0,a.kt)(i.Z,{to:"hardware-selection-display",mdxType:"Link"},"Display")," section for more information."),(0,a.kt)("h2",s({},{id:"packages--io"}),"Packages & I/O"),(0,a.kt)("p",null,"The number of I/Os needed is dependent on the chosen display and external memories.\nRunning a parallel display with parallel RAM/flash can require a high number of I/Os resulting in a larger package."),(0,a.kt)("h2",s({},{id:"memory-interfacing"}),"Memory Interfacing"),(0,a.kt)("p",null,"When internal flash and RAM in the microcontroller is not sufficient, choosing the right MCU with the most suitable external memory interface becomes important.\nThe STM32 products provide different memory controller peripherals to interface with the NOR, NAND, SRAM, SDRAM, LPSDR SDRAM, and PSRAM memories."),(0,a.kt)("h3",s({},{id:"flexible-memory-controller--flexible-static-memory-controller-fmcfsmc"}),"Flexible Memory Controller & Flexible Static Memory Controller (FMC/FSMC)"),(0,a.kt)("p",null,"In addition to the support of the static RAM, the FMC adds dynamic RAM support (SDRAM) to the FSMC.\nThe flexible memory controller (FMC) with its high external access speed and up to 32 bit data bus, allows for higher throughout from and to external RAM and hence better support of higher resolution.\nThe FMC has an independent chip select for each memory bank.\nThe FMC can control an external flash memory for the data and an external RAM memory for the framebuffer and heap extension for the graphical stack."),(0,a.kt)("h3",s({},{id:"serial-memory-interface"}),"Serial Memory Interface"),(0,a.kt)("p",null,"Depending on the STM32 product, the serial memory interface is embedded and allows interfacing with single, double, quad, octo, and HyperBus\u2122 flash memories alongside QSPI, PSRAM, OPI PSRAM, and Hyper RAM memories.\nThe serial high speed memory interface can control up to ",(0,a.kt)("strong",{parentName:"p"},"256Mbytes")," when in memory mapped mode and ",(0,a.kt)("strong",{parentName:"p"},"4Gbytes")," in indirect mode."),(0,a.kt)("p",null,"Compared to parallel interfaces, the serial memory interface permits the connection of a lower cost external flash memory to small packages and reduces the number of used pins."),(0,a.kt)("p",null,"However, the efficiency is usually lower with serial flash memory compared to parallel flash memory."),(0,a.kt)(o.Z,{mdxType:"FurtherReading"},"Refer to AN4760 application note for more information: ",(0,a.kt)(i.Z,{to:"https://www.st.com/content/ccc/resource/technical/document/application_note/group0/b0/7e/46/a8/5e/c1/48/01/DM00227538/files/DM00227538.pdf/jcr:content/translations/en.DM00227538.pdf",mdxType:"Link"},"Quad-SPI interface on STM32 microcontrollers"),"."),(0,a.kt)("h2",s({},{id:"cortex-m-cores"}),"Cortex\xae-M Cores"),(0,a.kt)("p",null,"STM32 MCUs comes in different ARC Cortex\xae-M architectures. Below are the most used cores for running graphics on STM32."),(0,a.kt)("h3",s({},{id:"cortex-m0"}),"Cortex\xae-M0+"),(0,a.kt)("p",null,"The ",(0,a.kt)("strong",{parentName:"p"},"Cortex\xae-M0+")," is characterized by its simple architecture and low price. It is recommended for smaller static graphic applications, running at lower resolutions."),(0,a.kt)("h3",s({},{id:"cortex-m4"}),"Cortex\xae-M4"),(0,a.kt)("p",null,"The ",(0,a.kt)("strong",{parentName:"p"},"Cortex\xae-M4")," contains more functionalities than the ",(0,a.kt)("strong",{parentName:"p"},"M0+")," and accelerates calculations. It includes a DSP instruction set and a single precision FPU unit. These instructions offload the CPU and increases the speed of calculations."),(0,a.kt)("h3",s({},{id:"cortex-m7"}),"Cortex\xae-M7"),(0,a.kt)("p",null,"The ",(0,a.kt)("strong",{parentName:"p"},"Cortex\xae-M7")," contains a more complex architecture but also a DSP instruction set, and comes with a more efficient FPU unit with double precision and a level1 cache memory with up to ",(0,a.kt)("strong",{parentName:"p"},"16KB")," for data and instructions.\nThe cache memory gives the possibility of having data and instructions close to the calculation unit in order to optimize the fetch time."),(0,a.kt)("h3",s({},{id:"cortex-m33"}),"Cortex\xae-M33"),(0,a.kt)("p",null,"The ",(0,a.kt)("strong",{parentName:"p"},"Cortex\xae-M33")," is a core with advanced security features.\nIt includes TrustZone\xae technology, which allows the MCU to run secure and non-secure applications on the same core.\nIt has a simpler architecture compared to the CM7."),(0,a.kt)("h3",s({},{id:"cortex-m55"}),"Cortex\xae-M55"),(0,a.kt)("p",null,"The ",(0,a.kt)("strong",{parentName:"p"},"Cortex\xae-M55")," is designed for AI and DSP applications and includes Helium technology for vector processing.\nThe CM55 also includes TrustZone\xae technology."),(0,a.kt)("h3",s({},{id:"feature-overview"}),"Feature overview"),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",s({parentName:"tr"},{align:null}),"Feature"),(0,a.kt)("th",s({parentName:"tr"},{align:null}),"Cortex-M0+"),(0,a.kt)("th",s({parentName:"tr"},{align:null}),"Cortex-M4"),(0,a.kt)("th",s({parentName:"tr"},{align:null}),"Cortex-M7"),(0,a.kt)("th",s({parentName:"tr"},{align:null}),"Cortex-M33"),(0,a.kt)("th",s({parentName:"tr"},{align:null}),"Cortex-M55"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",s({parentName:"tr"},{align:null}),"DMIPS/MHz range"),(0,a.kt)("td",s({parentName:"tr"},{align:null}),"0.95-1.36"),(0,a.kt)("td",s({parentName:"tr"},{align:null}),"1.25-1.95"),(0,a.kt)("td",s({parentName:"tr"},{align:null}),"2.14-3.23"),(0,a.kt)("td",s({parentName:"tr"},{align:null}),"1.54"),(0,a.kt)("td",s({parentName:"tr"},{align:null}),"1.69")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",s({parentName:"tr"},{align:null}),"Core Mark\xae/MHz"),(0,a.kt)("td",s({parentName:"tr"},{align:null}),"2.46"),(0,a.kt)("td",s({parentName:"tr"},{align:null}),"3.42"),(0,a.kt)("td",s({parentName:"tr"},{align:null}),"5.01"),(0,a.kt)("td",s({parentName:"tr"},{align:null}),"4.10"),(0,a.kt)("td",s({parentName:"tr"},{align:null}),"4.40")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",s({parentName:"tr"},{align:null}),"Digital Signal Processing (DSP) extension"),(0,a.kt)("td",s({parentName:"tr"},{align:null}),"No"),(0,a.kt)("td",s({parentName:"tr"},{align:null}),"Yes"),(0,a.kt)("td",s({parentName:"tr"},{align:null}),"Yes"),(0,a.kt)("td",s({parentName:"tr"},{align:null}),"Yes"),(0,a.kt)("td",s({parentName:"tr"},{align:null}),"Yes")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",s({parentName:"tr"},{align:null}),"Floating Point Hardware"),(0,a.kt)("td",s({parentName:"tr"},{align:null}),"No"),(0,a.kt)("td",s({parentName:"tr"},{align:null}),"Yes (SP)"),(0,a.kt)("td",s({parentName:"tr"},{align:null}),"Yes (SP, DP)"),(0,a.kt)("td",s({parentName:"tr"},{align:null}),"Yes (SP)"),(0,a.kt)("td",s({parentName:"tr"},{align:null}),"Yes (SP, DP, HP)")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",s({parentName:"tr"},{align:null}),"Built-in-caches"),(0,a.kt)("td",s({parentName:"tr"},{align:null}),"No"),(0,a.kt)("td",s({parentName:"tr"},{align:null}),"No"),(0,a.kt)("td",s({parentName:"tr"},{align:null}),"Yes (option 4-64kB), I-Cache, D-Cache"),(0,a.kt)("td",s({parentName:"tr"},{align:null}),"No"),(0,a.kt)("td",s({parentName:"tr"},{align:null}),"Yes (option 4-64kB), I-Cache, D-Cache")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",s({parentName:"tr"},{align:null}),"Bus Protocol"),(0,a.kt)("td",s({parentName:"tr"},{align:null}),"AHB Lite,Fast I/O"),(0,a.kt)("td",s({parentName:"tr"},{align:null}),"AHB Lite, APB"),(0,a.kt)("td",s({parentName:"tr"},{align:null}),"AXI4, AHB Lite, APB, TCM"),(0,a.kt)("td",s({parentName:"tr"},{align:null}),"AHB, AHB Lite, APB"),(0,a.kt)("td",s({parentName:"tr"},{align:null}),"AXI, AHB, AHB Lite, APB, TCM")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",s({parentName:"tr"},{align:null}),"Dual Core Lock-Step Support"),(0,a.kt)("td",s({parentName:"tr"},{align:null}),"No"),(0,a.kt)("td",s({parentName:"tr"},{align:null}),"No"),(0,a.kt)("td",s({parentName:"tr"},{align:null}),"Yes"),(0,a.kt)("td",s({parentName:"tr"},{align:null}),"No"),(0,a.kt)("td",s({parentName:"tr"},{align:null}),"Yes")))),(0,a.kt)("p",null,"For further reference, check the ",(0,a.kt)("a",s({parentName:"p"},{href:"https://documentation-service.arm.com/static/6267de1c7e121f01fd22d677?token="}),"ARM Cortex-M Processor Comparison Table"),"."),(0,a.kt)("h3",s({},{id:"level-1-cache"}),"Level 1 cache"),(0,a.kt)("p",null,"The STM32H7 and STM32F7 families include up to ",(0,a.kt)("strong",{parentName:"p"},"16 Kbytes")," of L1-Cache both for instructions and data.\nAn L1-Cache stores a set of data or instructions near the CPU, so the CPU does not have to keep fetching the same data that is repeatedly used."),(0,a.kt)(o.Z,{mdxType:"FurtherReading"},"Refer to AN4839 application note for more information: ",(0,a.kt)(i.Z,{to:"https://www.st.com/content/ccc/resource/technical/document/application_note/group0/08/dd/25/9c/4d/83/43/12/DM00272913/files/DM00272913.pdf/jcr:content/translations/en.DM00272913.pdf",mdxType:"Link"},"Level 1 Cache"),"."),(0,a.kt)("h3",s({},{id:"dual-core"}),"Dual core"),(0,a.kt)("p",null,"The STM32H7 series includes the dual-core line:"),(0,a.kt)("p",null,"Arm\xae Cortex\xae-M7 and Cortex\xae-M4 cores can respectively run up to 480 MHz and 240 MHz enabling more processing and application partitioning. Dual-core STM32H7 product lines are available with an embedded SMPS for improved dynamic power efficiency."),(0,a.kt)("p",null,"The second Cortex\xae-M4 can offload heavy calculations to open up the M7 core for the drawing/graphic operations."),(0,a.kt)(l.Z,{mdxType:"Note"},"For dual core MCUs TouchGFX Generator must be enabled for a specific context. Only a single concurrent context is supported. See the ",(0,a.kt)(i.Z,{to:"../../touchgfx-hal-development/generator-how-to/enabling-touchgfx-generator",mdxType:"Link"},"TouchGFX Generator User Guide")," for more information."),(0,a.kt)("h2",s({},{id:"bus-architecture"}),"Bus architecture"),(0,a.kt)("p",null,"The majority of STM32 microcontrollers provide a ",(0,a.kt)("strong",{parentName:"p"},"32-bits multi-AHB")," bus matrix interconnecting all the masters (CPU, DMAs, etc.) and the slaves (flash memory, RAM, FSMC, AHB and APB peripherals). This ensures seamless and efficient operations even when several high-speed peripherals work simultaneously."),(0,a.kt)("p",null,"In addition to multi-AHB interconnect, some STM32 products embed ",(0,a.kt)("strong",{parentName:"p"},"64-bit")," AXI to expand bandwidth. This yields the best compromise between performance and power consumption."),(0,a.kt)("h2",s({},{id:"price"}),"Price"),(0,a.kt)("p",null,"The size of the internal flash, internal RAM, and number of pins available in the package influence the price of the MCU.\nConsidering the requirements of the interface, resolution, performance, etc., the user can ultimately find suitable MCUs and estimate price."),(0,a.kt)(o.Z,{mdxType:"FurtherReading"},(0,a.kt)("li",null,"See ",(0,a.kt)(i.Z,{to:"https://www.st.com/en/microcontrollers-microprocessors/stm32-32-bit-arm-cortex-mcus.html",mdxType:"Link"},"STM32 32-bit Arm Cortex MCUs")," for available STM32 microcontrollers.")))}k.isMDXComponent=!0}}]);