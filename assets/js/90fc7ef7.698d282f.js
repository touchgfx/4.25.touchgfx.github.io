"use strict";(self.webpackChunktouchgfx_documentation=self.webpackChunktouchgfx_documentation||[]).push([[20123],{49613:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>f});var r=a(59496);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},o=Object.keys(e);for(r=0;r<o.length;r++)a=o[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)a=o[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var s=r.createContext({}),h=function(e){var t=r.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},p=function(e){var t=h(e.components);return r.createElement(s.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var a=e.components,n=e.mdxType,o=e.originalType,s=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),c=h(a),u=n,f=c["".concat(s,".").concat(u)]||c[u]||d[u]||o;return a?r.createElement(f,l(l({ref:t},p),{},{components:a})):r.createElement(f,l({ref:t},p))}));function f(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=a.length,l=new Array(o);l[0]=u;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i[c]="string"==typeof e?e:n,l[1]=i;for(var h=2;h<o;h++)l[h]=a[h];return r.createElement.apply(null,l)}return r.createElement.apply(null,a)}u.displayName="MDXCreateElement"},96151:(e,t,a)=>{a.d(t,{Z:()=>o});var r=a(59496);class n extends r.Component{render(){const e=`highlight highlight-${this.props.type}`;return r.createElement("div",{className:e},r.createElement("div",{className:"highlight-heading"},r.createElement("h5",null,r.createElement("div",{className:"highlight-icon"},this.props.icon),this.props.header)),r.createElement("div",{className:"highlight-content"},this.props.children))}}const o=n},49018:(e,t,a)=>{a.d(t,{Z:()=>i});var r=a(59496),n=a(96151);const o=r.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},r.createElement("path",{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}));class l extends r.Component{render(){return r.createElement(n.Z,{color:"var(--highlight-color-note)",header:"Note",type:"note",icon:o},this.props.children)}}const i=l},23482:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>h,default:()=>m,frontMatter:()=>s,metadata:()=>p,toc:()=>d});a(59496);var r=a(49613),n=a(49018),o=a(95375);function l(){return l=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var a=arguments[t];for(var r in a)Object.prototype.hasOwnProperty.call(a,r)&&(e[r]=a[r])}return e},l.apply(this,arguments)}function i(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},o=Object.keys(e);for(r=0;r<o.length;r++)a=o[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)a=o[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}const s={id:"11-flash-loader",title:"11. Flash Loader",sidebar_label:"11. Flash Loader"},h=void 0,p={unversionedId:"development/board-bring-up/how-to/11-flash-loader",id:"development/board-bring-up/how-to/11-flash-loader",title:"11. Flash Loader",description:"Motivation",source:"@site/docs/development/board-bring-up/how-to/11-flash-loader.mdx",sourceDirName:"development/board-bring-up/how-to",slug:"/development/board-bring-up/how-to/11-flash-loader",permalink:"/4.25/docs/development/board-bring-up/how-to/11-flash-loader",draft:!1,tags:[],version:"current",sidebarPosition:11,frontMatter:{id:"11-flash-loader",title:"11. Flash Loader",sidebar_label:"11. Flash Loader"},sidebar:"docs",previous:{title:"10. Physical Buttons",permalink:"/4.25/docs/development/board-bring-up/how-to/10-physical-buttons"},next:{title:"TouchGFX AL Development Introduction",permalink:"/4.25/docs/development/touchgfx-hal-development/touchgfx-al-development-introduction"}},c={},d=[{value:"Motivation",id:"motivation",level:2},{value:"Goal",id:"goal",level:2},{value:"Verification",id:"verification",level:3},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Do",id:"do",level:2},{value:"Flash loader for STM32CubeProgrammer",id:"flash-loader-for-stm32cubeprogrammer",level:3},{value:"Proprietary application-based solution",id:"proprietary-application-based-solution",level:3},{value:"Testing",id:"testing",level:3}],u={toc:d},f="wrapper";function m(e){var{components:t}=e,a=i(e,["components"]);return(0,r.kt)(f,l({},u,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",l({},{id:"motivation"}),"Motivation"),(0,r.kt)("p",null,"In this step we will discuss loading data to the external flash. The\ncompiler will compile the text, fonts, and images in your project and\nproduce a binary or hex file with this data. This data is typically\nput into the external flash. The internal flash is then reserved for\ncode."),(0,r.kt)("p",null,"During development we need a way to write data to the external flash,\nbut this is not necessary during runtime where we only read from the\nflash."),(0,r.kt)("p",null,"Two ways are common for writing data to the external flash:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Write a flashloader for STM32CubeProgrammer"),(0,r.kt)("li",{parentName:"ul"},"Use a proprietary application-based solution")),(0,r.kt)(n.Z,{mdxType:"Note"},"Skip this step if external flash is not present"),(0,r.kt)("h2",l({},{id:"goal"}),"Goal"),(0,r.kt)("p",null,"The goal in this section is to select and develop a mechanism for loading data to\nthe external flash."),(0,r.kt)("h3",l({},{id:"verification"}),"Verification"),(0,r.kt)("p",null,"Here are the verification points for this section:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",l({parentName:"tr"},{align:null}),"Verification Point"),(0,r.kt)("th",l({parentName:"tr"},{align:null}),"Rationale"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",l({parentName:"tr"},{align:null}),"Data can be flashed"),(0,r.kt)("td",l({parentName:"tr"},{align:null}),"External flash can be used for image storage")))),(0,r.kt)("h2",l({},{id:"prerequisites"}),"Prerequisites"),(0,r.kt)("p",null,"The following are the prerequisites for this step:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Information about the flash, typically a datasheet"),(0,r.kt)("li",{parentName:"ul"},"Information about the connections between the MCU and the external flash")),(0,r.kt)("h2",l({},{id:"do"}),"Do"),(0,r.kt)("h3",l({},{id:"flash-loader-for-stm32cubeprogrammer"}),"Flash loader for STM32CubeProgrammer"),(0,r.kt)("p",null,"The ",(0,r.kt)("a",l({parentName:"p"},{href:"https://www.st.com/en/development-tools/stm32cubeprog.html"}),"STM32CubeProgrammer")," comes with flash loaders for the various STM32\nEvaluation kits. The flash loaders are small programs that are loaded\nto the RAM of the MCU and facilitate the programming of the flash."),(0,r.kt)("p",null,"The flash loader consists of two parts:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Configuration of the GPIOs and flash interface that are required to communicate with the flash"),(0,r.kt)("li",{parentName:"ul"},"The flashing algorithm that knows the sequence of commands required to write in the flash")),(0,r.kt)("p",null,"These parts can often be based on an existing flash loader. If you can\nfind a flash loader for the same flash that you are using, take that\nas starting point and modify the GPIO part. If you design your\nhardware by copying the flash circuit from an evaluation kit, then you\ncan use the flash loader for that kit directly. This is the way."),(0,r.kt)("p",null,"The flash loader projects provided with ",(0,r.kt)("em",{parentName:"p"},"STM32CubeProgrammer")," are found\nin the installation folder, typically here:\n",(0,r.kt)("em",{parentName:"p"},"C:\\Program Files\\STMicroelectronics\\STM32Cube\\STM32CubeProgrammer\\bin\\ExternalLoader")),(0,r.kt)("p",null,"Flash loader projects can also be found on github:"),(0,r.kt)(o.Z,{to:"https://github.com/STMicroelectronics/stm32-external-loader",mdxType:"Link"},"STM32 External Flashloaders on GitHub"),(0,r.kt)("h3",l({},{id:"proprietary-application-based-solution"}),"Proprietary application-based solution"),(0,r.kt)("p",null,"Another solution is to include flash loading into the application\nitself. The idea is that you already have the flash configuration\ninside your application (to be able to load from it), and maybe you\nknow how to write a block to the flash from your previous testing. You\nthen just need a way of transferring the new flash data to your\napplication. One way is through a UART. The application receives\nthe data stream, and writes the data to the flash, block by block."),(0,r.kt)("p",null,"The flash cannot be in memory mapped mode while this is running, so\nthe application must typically be put in a special mode."),(0,r.kt)("p",null,"Open source solutions for the transmission of bytes can be found on\nthe Internet. The Y-modem protocol for example provides 16-bit CRC on the data."),(0,r.kt)("h3",l({},{id:"testing"}),"Testing"),(0,r.kt)("p",null,"After the data has been written to the flash, test that it can be read\ncorrectly. Use the small test programs developed in the previous\nsections."),(0,r.kt)("p",null,"It is advised to test the whole flash thoroughly now, to find any bugs\nearly."))}m.isMDXComponent=!0}}]);