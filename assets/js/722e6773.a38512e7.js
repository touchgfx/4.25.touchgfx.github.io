"use strict";(self.webpackChunktouchgfx_documentation=self.webpackChunktouchgfx_documentation||[]).push([[51629],{49613:(e,t,r)=>{r.d(t,{Zo:()=>m,kt:()=>d});var a=r(59496);function n(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function i(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,a)}return r}function l(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?i(Object(r),!0).forEach((function(t){n(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function o(e,t){if(null==e)return{};var r,a,n=function(e,t){if(null==e)return{};var r,a,n={},i=Object.keys(e);for(a=0;a<i.length;a++)r=i[a],t.indexOf(r)>=0||(n[r]=e[r]);return n}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)r=i[a],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}var s=a.createContext({}),f=function(e){var t=a.useContext(s),r=t;return e&&(r="function"==typeof e?e(t):l(l({},t),e)),r},m=function(e){var t=f(e.components);return a.createElement(s.Provider,{value:t},e.children)},h="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var r=e.components,n=e.mdxType,i=e.originalType,s=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),h=f(r),u=n,d=h["".concat(s,".").concat(u)]||h[u]||p[u]||i;return r?a.createElement(d,l(l({ref:t},m),{},{components:r})):a.createElement(d,l({ref:t},m))}));function d(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=r.length,l=new Array(i);l[0]=u;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[h]="string"==typeof e?e:n,l[1]=o;for(var f=2;f<i;f++)l[f]=r[f];return a.createElement.apply(null,l)}return a.createElement.apply(null,r)}u.displayName="MDXCreateElement"},89639:(e,t,r)=>{r.d(t,{Z:()=>i});var a=r(59496),n=r(97395);const i=function(e){const t=e.noShadow||!1,r=e.width,i=e.height,l=(0,n.Z)(e.imageSource);return t?a.createElement("div",{className:"figure noshadow"},a.createElement("a",{href:l,target:"_blank"},a.createElement("img",{width:r,height:i,src:l})),a.createElement("p",null,e.children)):a.createElement("div",{className:"figure"},a.createElement("a",{href:l,target:"_blank"},a.createElement("img",{width:r,height:i,src:l})),a.createElement("p",null,e.children))}},48753:(e,t,r)=>{r.d(t,{Z:()=>o});var a=r(59496),n=r(96151);const i=a.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},a.createElement("path",{fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}));class l extends a.Component{render(){return a.createElement(n.Z,{color:"var(--highlight-color-further-reading)",header:"Further reading",type:"further-reading",icon:i},this.props.children)}}const o=l},96151:(e,t,r)=>{r.d(t,{Z:()=>i});var a=r(59496);class n extends a.Component{render(){const e=`highlight highlight-${this.props.type}`;return a.createElement("div",{className:e},a.createElement("div",{className:"highlight-heading"},a.createElement("h5",null,a.createElement("div",{className:"highlight-icon"},this.props.icon),this.props.header)),a.createElement("div",{className:"highlight-content"},this.props.children))}}const i=n},49018:(e,t,r)=>{r.d(t,{Z:()=>o});var a=r(59496),n=r(96151);const i=a.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},a.createElement("path",{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}));class l extends a.Component{render(){return a.createElement(n.Z,{color:"var(--highlight-color-note)",header:"Note",type:"note",icon:i},this.props.children)}}const o=l},45988:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>u,contentTitle:()=>h,default:()=>b,frontMatter:()=>m,metadata:()=>p,toc:()=>d});r(59496);var a=r(49613),n=r(89639),i=r(48753),l=r(18399),o=r(49018);function s(){return s=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var a in r)Object.prototype.hasOwnProperty.call(r,a)&&(e[a]=r[a])}return e},s.apply(this,arguments)}function f(e,t){if(null==e)return{};var r,a,n=function(e,t){if(null==e)return{};var r,a,n={},i=Object.keys(e);for(a=0;a<i.length;a++)r=i[a],t.indexOf(r)>=0||(n[r]=e[r]);return n}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)r=i[a],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}const m={id:"framebuffer",title:"Framebuffer"},h=void 0,p={unversionedId:"basic-concepts/framebuffer",id:"basic-concepts/framebuffer",title:"Framebuffer",description:"A framebuffer is a piece of memory that is updated by the graphics engine to",source:"@site/docs/basic-concepts/framebuffer.mdx",sourceDirName:"basic-concepts",slug:"/basic-concepts/framebuffer",permalink:"/4.25/docs/basic-concepts/framebuffer",draft:!1,tags:[],version:"current",frontMatter:{id:"framebuffer",title:"Framebuffer"},sidebar:"docs",previous:{title:"Color Formats",permalink:"/4.25/docs/basic-concepts/color-formats"},next:{title:"Graphics Engine",permalink:"/4.25/docs/basic-concepts/graphics-engine"}},u={},d=[{value:"Colors",id:"colors",level:2},{value:"Display",id:"display",level:2},{value:"Location of framebuffer",id:"location-of-framebuffer",level:2},{value:"Internal RAM",id:"internal-ram",level:3},{value:"External RAM",id:"external-ram",level:3},{value:"Display with GRAM",id:"display-with-gram",level:3},{value:"Memory consumption",id:"memory-consumption",level:2},{value:"Framebuffer Strategies",id:"framebuffer-strategies",level:2},{value:"Displays without GRAM",id:"display-without-gram-table",level:4},{value:"Displays with GRAM",id:"display-with-gram-table",level:4},{value:"Tearing",id:"tearing",level:3},{value:"UI Performance",id:"framebuffer-strategy-performance",level:3},{value:"Glossary",id:"framebuffer-strategies-glossary",level:3},{value:"Displays without GRAM",id:"display-without-gram-framebuffer-strategies",level:3},{value:"Double Buffering Strategy",id:"display-without-gram-double-buffering",level:4},{value:"Single Buffering Strategy",id:"display-without-gram-single-buffering",level:4},{value:"Partial Buffering Strategy",id:"display-without-gram-partial-buffering",level:4},{value:"Displays with GRAM",id:"display-with-gram-framebuffer-strategies",level:3},{value:"Double Buffering Strategy",id:"display-with-gram-double-buffering",level:4},{value:"Single Buffering Strategy",id:"display-with-gram-single-buffering",level:4},{value:"Partial Buffering Strategy",id:"display-with-gram-partial-buffering",level:4},{value:"Getting Started with Framebuffer Strategies",id:"framebuffer-strategy-getting-started",level:3},{value:"Displays with GRAM",id:"displays-with-gram-getting-started",level:4},{value:"Displays without GRAM",id:"displays-without-gram-getting-started",level:4}],c={toc:d},g="wrapper";function b(e){var{components:t}=e,r=f(e,["components"]);return(0,a.kt)(g,s({},c,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"A framebuffer is a piece of memory that is updated by the graphics engine to\ncontain the next image to be shown on the display."),(0,a.kt)("p",null,"The framebuffer is a contiguous part of RAM of a given size."),(0,a.kt)(n.Z,{imageSource:"/img/basic-concepts/framebuffer-contiguous-memory.svg",noShadow:"true",mdxType:"Figure"},"Framebuffer memory"),(0,a.kt)("p",null,"A framebuffer has an associated width and height.\nTherefore we typically think of a framebuffer as being a two dimensional part of memory, indexable\nby x, y coordinates."),(0,a.kt)(n.Z,{imageSource:"/img/basic-concepts/framebuffer-2d-memory.svg",noShadow:"true",mdxType:"Figure"},"2D framebuffer memory"),(0,a.kt)("p",null,"A framebuffer has an associated color format.\nEach entry in the framebuffer will be a color in this color format.\nWe will refer to each such entry in the framebuffer as a pixel."),(0,a.kt)("p",null,"We can update the color of a pixel at position x,y in the framebuffer by calculating the memory address\nof the pixel within the framebuffer and updating the stored color."),(0,a.kt)("pre",null,(0,a.kt)("code",s({parentName:"pre"},{className:"language-cpp"}),"uint32_t pixelAddress = x + y * WIDTH;\nframebuffer[ pixelAddress ] = newColor;\n")),(0,a.kt)("p",null,"Similarly we can obtain the color of a pixel in the framebuffer and use this in calculations. For instance darkening the color\nof a pixel in the framebuffer (assuming we have a ",(0,a.kt)("inlineCode",{parentName:"p"},"darken")," function available)."),(0,a.kt)("pre",null,(0,a.kt)("code",s({parentName:"pre"},{className:"language-cpp"}),"uint32_t pixelAddress = x + y * WIDTH;\nframebuffer[ pixelAddress ] = darken( framebuffer[ pixelAddress ] );\n")),(0,a.kt)("p",null,"Often the framebuffer memory is not written and read pixel by pixel as above, but by utilizing the underlying hardware capabilities of the system, e.g. the Chrom-ART DMA."),(0,a.kt)("h2",s({},{id:"colors"}),"Colors"),(0,a.kt)("p",null,"In TouchGFX the pixel color format of a framebuffer can be either:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Grayscale")," 1, 2 or 4 bits per pixel (bpp) grayscale, or"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"High or true color")," 16, 24 or 32 bpp color")),(0,a.kt)("p",null,"The more bits per pixels used the more distinct colors can be represented by the framebuffer, moreover the more bits per pixels used the more memory will be consumed by the framebuffer."),(0,a.kt)("h2",s({},{id:"display"}),"Display"),(0,a.kt)("p",null,"The contents of the framebuffer is what is ultimately transferred to and seen on the physical display.\nTherefore it is very common to have the same pixel width and height of the framebuffer and the display."),(0,a.kt)(n.Z,{imageSource:"/img/basic-concepts/display-and-framebuffer.svg",noShadow:"true",mdxType:"Figure"},"24 bpp framebuffer contents and resulting display"),(0,a.kt)(i.Z,{mdxType:"FurtherReading"},"See the section on ",(0,a.kt)(l.Z,{to:"../development/hardware-selection/hardware-components/hardware-selection-display",mdxType:"Link"},"display technologies")," to learn more on different display types."),(0,a.kt)("h2",s({},{id:"location-of-framebuffer"}),"Location of framebuffer"),(0,a.kt)("p",null,"One oversimplified view of a microcontroller based graphics system is here."),(0,a.kt)(n.Z,{imageSource:"/img/basic-concepts/simplified-graphics-system.webp",noShadow:!0,width:"400",mdxType:"Figure"},"Oversimplified view of graphics system"),(0,a.kt)("p",null,"A framebuffer can be placed either internally in the MCU or in external RAM."),(0,a.kt)(n.Z,{imageSource:"/img/basic-concepts/framebuffer-placement.webp",noShadow:"true",width:"600",mdxType:"Figure"},"Possible locations of framebuffer"),(0,a.kt)("p",null,"Each possible location has potential benefits and drawbacks."),(0,a.kt)("h3",s({},{id:"internal-ram"}),"Internal RAM"),(0,a.kt)("p",null,"Placing the framebuffer in RAM internal to the MCU makes the read and write access to the framebuffer\nas fast as possible. This means that your TouchGFX application will run as smooth as possible.\nConversely, internal RAM is a very scarce resource and one that is used by many\nparts of a system, therefore occupying a large part of this with a framebuffer might be infeasible."),(0,a.kt)("p",null,"If feasible, having a framebuffer in internal RAM, could reduce the overall cost of the system as\nno additional RAM is needed."),(0,a.kt)("h3",s({},{id:"external-ram"}),"External RAM"),(0,a.kt)("p",null,"If the system has external RAM, placing the framebuffer here is an alternative to placing it in internal RAM.\nThe read and write access to external RAM will typically be slower than to the internal RAM,\nbut the amount of external RAM will typically be much larger. Therefore this is sometimes the only viable solution."),(0,a.kt)("p",null,"The MCU might have capabilities, like caching, that makes access to external RAM faster.\nSee the section on ",(0,a.kt)("a",s({parentName:"p"},{href:"../development/hardware-selection/hardware-components/hardware-selection-mcu"}),"MCU")," for details."),(0,a.kt)("h3",s({},{id:"display-with-gram"}),"Display with GRAM"),(0,a.kt)("p",null,'Depending on the type of display in the system there might be memory embedded on the display (often called GRAM).\nThis memory holds the contents of the "physical" pixels of the display.\nHaving this pixel memory in the display implies that the MCU can be idle while the display is still alive.'),(0,a.kt)("p",null,"Placing a TouchGFX framebuffer in the RAM of the display is not possible, as the memory of the display is not memory mapped and is not intended nor suitable for random pixel reads or writes.\nInstead TouchGFX places the framebuffer in internal or external RAM and transfers this to the display RAM when appropriate."),(0,a.kt)("h2",s({},{id:"memory-consumption"}),"Memory consumption"),(0,a.kt)("p",null,"The amount of colors and the number of pixels in the framebuffer determines the memory consumed by the framebuffer."),(0,a.kt)("p",null,"In general the amount of memory used by a framebuffer is\n",(0,a.kt)("strong",{parentName:"p"}," width ","*"," height ","*"," color depth in bits / 8 ")," bytes."),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",s({parentName:"tr"},{align:"right"}),"Resolution (pixels)"),(0,a.kt)("th",s({parentName:"tr"},{align:"right"}),"Colors (bpp)"),(0,a.kt)("th",s({parentName:"tr"},{align:"right"}),"Calculation"),(0,a.kt)("th",s({parentName:"tr"},{align:"right"}),"Memory consumed (byte)"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",s({parentName:"tr"},{align:"right"}),"800x480"),(0,a.kt)("td",s({parentName:"tr"},{align:"right"}),"16 bpp"),(0,a.kt)("td",s({parentName:"tr"},{align:"right"}),"800 ","*"," 480 ","*"," 16 / 8"),(0,a.kt)("td",s({parentName:"tr"},{align:"right"}),"768,000 B")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",s({parentName:"tr"},{align:"right"}),"480x272"),(0,a.kt)("td",s({parentName:"tr"},{align:"right"}),"24 bpp"),(0,a.kt)("td",s({parentName:"tr"},{align:"right"}),"480 ","*"," 272 ","*"," 24 / 8"),(0,a.kt)("td",s({parentName:"tr"},{align:"right"}),"391,680 B")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",s({parentName:"tr"},{align:"right"}),"100x100"),(0,a.kt)("td",s({parentName:"tr"},{align:"right"}),"8 bpp"),(0,a.kt)("td",s({parentName:"tr"},{align:"right"}),"100 ","*"," 100 ","*","  8 / 8"),(0,a.kt)("td",s({parentName:"tr"},{align:"right"}),"10,000 B")))),(0,a.kt)("p",null,"When having more than one framebuffer the amount of memory consumed will be correspondingly larger. For example when having a double buffering scheme, using two framebuffers, will consume twice the amount of memory."),(0,a.kt)("p",null,"When having less than one framebuffer the amount of memory is explicitly allocated and controlled by the application. The memory consumption is therefore completely customizable, but be warned that using too little will harm the overall graphics performance."),(0,a.kt)("h2",s({},{id:"framebuffer-strategies"}),"Framebuffer Strategies"),(0,a.kt)("p",null,"Framebuffer strategy is a core feature, that enables you to make the\nmost optimal match between TouchGFX rendering and your existing\nhardware (MCU, RAM and Display). In case you are selecting new\nhardware, it is recommended to get familiar with the available\nframebuffer strategies in relation to your use case. The right\nchoice can help optimize your hardware cost, i.e. assist you in\nselecting the minimum required hardware in terms of the amount of RAM\nfor framebuffer(s) and the suitable display interface."),(0,a.kt)("p",null,"A framebuffer strategy defines how much RAM is used for framebuffers\nand controls how TouchGFX renders to the RAM. The strategy must match\nthe available RAM and the type of display in the system. TouchGFX\noffers three different strategies, applicable on display systems with\nand without GRAM. Below is an overview of the strategies, highlighting\ntheir advantages and drawbacks in relation to display systems."),(0,a.kt)("h4",s({},{id:"display-without-gram-table"}),"Displays without GRAM"),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",s({parentName:"tr"},{align:null}),"Strategy"),(0,a.kt)("th",s({parentName:"tr"},{align:null}),"Advantages"),(0,a.kt)("th",s({parentName:"tr"},{align:null}),"Drawbacks"),(0,a.kt)("th",s({parentName:"tr"},{align:null}),"Use Cases"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",s({parentName:"tr"},{align:null}),"Double"),(0,a.kt)("td",s({parentName:"tr"},{align:null}),"No risk of tearing, optimal time for rendering"),(0,a.kt)("td",s({parentName:"tr"},{align:null}),"RAM for 2 framebuffers"),(0,a.kt)("td",s({parentName:"tr"},{align:null}),"High performance UIs")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",s({parentName:"tr"},{align:null}),"Single"),(0,a.kt)("td",s({parentName:"tr"},{align:null}),"Only RAM for 1 framebuffer"),(0,a.kt)("td",s({parentName:"tr"},{align:null}),"Risk of tearing, suboptimal time for rendering"),(0,a.kt)("td",s({parentName:"tr"},{align:null}),"High - Moderate performance UIs")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",s({parentName:"tr"},{align:null}),"Partial"),(0,a.kt)("td",s({parentName:"tr"},{align:null}),"Only RAM for less than a framebuffer"),(0,a.kt)("td",s({parentName:"tr"},{align:null}),"Higher risk of tearing, higher CPU load"),(0,a.kt)("td",s({parentName:"tr"},{align:null}),"Moderate - Low performance UIs")))),(0,a.kt)("h4",s({},{id:"display-with-gram-table"}),"Displays with GRAM"),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",s({parentName:"tr"},{align:null}),"Strategy"),(0,a.kt)("th",s({parentName:"tr"},{align:null}),"Advantages"),(0,a.kt)("th",s({parentName:"tr"},{align:null}),"Drawbacks"),(0,a.kt)("th",s({parentName:"tr"},{align:null}),"Use Cases"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",s({parentName:"tr"},{align:null}),"Double"),(0,a.kt)("td",s({parentName:"tr"},{align:null}),"No risk of tearing, optimal time for rendering"),(0,a.kt)("td",s({parentName:"tr"},{align:null}),"RAM for 2 framebuffers"),(0,a.kt)("td",s({parentName:"tr"},{align:null}),"High performance UIs")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",s({parentName:"tr"},{align:null}),"Single"),(0,a.kt)("td",s({parentName:"tr"},{align:null}),"Only RAM for 1 framebuffer, no risk of tearing"),(0,a.kt)("td",s({parentName:"tr"},{align:null}),"Suboptimal time for rendering"),(0,a.kt)("td",s({parentName:"tr"},{align:null}),"High - Moderate performance UIs")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",s({parentName:"tr"},{align:null}),"Partial"),(0,a.kt)("td",s({parentName:"tr"},{align:null}),"Only RAM for less than a framebuffer"),(0,a.kt)("td",s({parentName:"tr"},{align:null}),"Risk of tearing"),(0,a.kt)("td",s({parentName:"tr"},{align:null}),"Moderate - Low performance UIs")))),(0,a.kt)("h3",s({},{id:"tearing"}),"Tearing"),(0,a.kt)("p",null,"Tearing is a visual artifact on the display where pixel data from two\nframes are shown in one screen draw, e.g. the screen has half of an\nold frame and half of a current one, with a clean horizontal split\nacross (the tear). The location of the tear varies according to\ntiming, it usually jumps all over the place, which can be distracting."),(0,a.kt)("h3",s({},{id:"framebuffer-strategy-performance"}),"UI Performance"),(0,a.kt)("p",null,"In the general ",(0,a.kt)("a",s({parentName:"p"},{href:"performance"}),"Performance")," article, you will be\nintroduced to aspects of UI performance, which covers how the\nindividual UI components and there structure impacts performance. In\nthe context of framebuffer strategy we think of:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"High performance, as UIs that uses multiple complex UI components/animations, e.g. Texture Mappers, SVGs, screen transitions"),(0,a.kt)("li",{parentName:"ul"},"Moderate performance, as UIs that uses few complex UI components/animations"),(0,a.kt)("li",{parentName:"ul"},"Low performance, as UIs that uses no complex UI components/animations")),(0,a.kt)(o.Z,{mdxType:"Note"},"The above examples are not definitive. Keep in mind that the UI performance depend on your hardware and UI design."),(0,a.kt)("h3",s({},{id:"framebuffer-strategies-glossary"}),"Glossary"),(0,a.kt)("p",null,"The following terms are used to describe the different framebuffer strategies."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Display Controller (DC)")," - The hardware that reads pixels from memory. Is continuously reading the memory containing pixels. Sometimes referred to as the ",(0,a.kt)("em",{parentName:"li"},"scanline"),"."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Display Transfer (DT)")," - The hardware responsible of transferring pixels from framebuffer memory to GRAM. Is only initiated by the MCU when required. Sometimes referred to as the ",(0,a.kt)("em",{parentName:"li"},"transferline"),"."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Framebuffer Write (W)")," - The rendering of pixels to the framebuffer.")),(0,a.kt)("h3",s({},{id:"display-without-gram-framebuffer-strategies"}),"Displays without GRAM"),(0,a.kt)("p",null,"The following demonstrates the working concept of framebuffer\nstrategies on displays without GRAM. Common for all strategies are the\nuse of a Display Controller which continuously reads pixel data\ndirectly from a framebuffer."),(0,a.kt)("h4",s({},{id:"display-without-gram-double-buffering"}),"Double Buffering Strategy"),(0,a.kt)("p",null,"Having two framebuffers allows rendering of the next frame into one\nframebuffer while the Display Controller scans the other framebuffer.\nRender time of the next frame is unrestricted by the Display\nController. Swapping framebuffers is blocked until the next frame is\nready, meaning no risk of tearing because the Display Controller just\nscans the current framebuffer once again. The framebuffers are swapped\nafter the Display Controller has scanned the entire framebuffer and\nthe rendering is complete."),(0,a.kt)(n.Z,{imageSource:"/img/basic-concepts/ltdc-double.png",noShadow:"true",width:"650",mdxType:"Figure"},"Double Buffering Strategy Concept"),(0,a.kt)("h4",s({},{id:"display-without-gram-single-buffering"}),"Single Buffering Strategy"),(0,a.kt)("p",null,"Having one framebuffer allows rendering of the next frame into the\nsame framebuffer as the Display Controller scans from. Render time of\nthe next frame is restricted by the Display Controller. The Display\nController scans continuously, so if writing to the framebuffer takes\ntoo long, the Display Controller will collide (catch up) with the\nwriting area and tearing will occur. This is caused by rendering\ncomplex UI components."),(0,a.kt)(n.Z,{imageSource:"/img/basic-concepts/ltdc-single.png",noShadow:"true",width:"400",mdxType:"Figure"},"Single Buffering Strategy Concept"),(0,a.kt)("h4",s({},{id:"display-without-gram-partial-buffering"}),"Partial Buffering Strategy"),(0,a.kt)("p",null,"A single partial framebuffer block is used to emulate a full size\nframebuffer through a Memory Management Unit (MMU). Therefore this\nstrategy is also known as ",(0,a.kt)("em",{parentName:"p"},"Emulated Framebuffer Strategy"),"."),(0,a.kt)("p",null,"The partial block acts as a sliding window moving down through the\nemulated framebuffer, with the phase and speed of the Display\nController."),(0,a.kt)("p",null,"Having a partial framebuffer block only allows rendering of a small\nportion of the next frame, because the block is reused multiple times\nto render the current frame. The reuse of the partial block results in\na large number of small rendering operations, which result in higher\nCPU load. Render time of the next frame is restricted by the Display\nController and the partial block size. The Display Controller scans\ncontinuously, so if writing to the partial framebuffer block takes too\nlong for any given region of the emulated framebuffer, the Display\nController will collide (catch up) with the writing area and tearing\nwill occur. This is caused by rendering complex UI components.\nCompared to the Single Buffering Strategy the risk of tearing is\nhigher because the working area of the Display Controller and\nframebuffer rendering is much smaller."),(0,a.kt)(n.Z,{imageSource:"/img/basic-concepts/ltdc-partial.png",noShadow:"true",width:"700",mdxType:"Figure"},"Partial Buffering Strategy Concept"),(0,a.kt)(o.Z,{mdxType:"Note"},"This strategy is only available on MCUs with a ",(0,a.kt)(l.Z,{to:"https://www.st.com/resource/en/application_note/an5051-graphic-memory-optimization-with-stm32-chromgrc-stmicroelectronics.pdf",mdxType:"Link"},"STM32 Chrom-GRC (GFXMMU)")),(0,a.kt)("h3",s({},{id:"display-with-gram-framebuffer-strategies"}),"Displays with GRAM"),(0,a.kt)("p",null,"The following demonstrates the working concept of framebuffer\nstrategies on GRAM displays. Common for all strategies are the use of\na Display Interface used for transferring pixel data from a\nframebuffer to the GRAM on the display."),(0,a.kt)("h4",s({},{id:"display-with-gram-double-buffering"}),"Double Buffering Strategy"),(0,a.kt)("p",null,"Having two framebuffers allows rendering of the next frame into one\nframebuffer while the pixels are transferred to GRAM from the other.\nRender time of the next frame is unrestricted by the Display Transfer.\nDisplay transfers are only initiated when the next frame is ready,\nmeaning no risk of tearing because the Display Controller just scans\nwhat is already in GRAM. The framebuffers are swapped after the\ndisplay transfer and the rendering is complete."),(0,a.kt)(n.Z,{imageSource:"/img/basic-concepts/gram-double.png",noShadow:"true",mdxType:"Figure"},"Double Buffering Strategy Concept"),(0,a.kt)("h4",s({},{id:"display-with-gram-single-buffering"}),"Single Buffering Strategy"),(0,a.kt)("p",null,"Having one framebuffer allows rendering of the next frame into the\nsame framebuffer where pixels are transferred to GRAM. Render time of\nthe next frame is restricted by the Display Transfer bandwidth.\nDisplay transfers are only initiated when the next frame is ready,\nmeaning no risk of tearing because the Display Controller just scans\nwhat is already in GRAM. Rendering of the next frame cannot complete\nbefore the corresponding area to update has been transferred to GRAM."),(0,a.kt)(n.Z,{imageSource:"/img/basic-concepts/gram-single.png",noShadow:"true",width:"700",mdxType:"Figure"},"Single Buffering Strategy Concept"),(0,a.kt)("h4",s({},{id:"display-with-gram-partial-buffering"}),"Partial Buffering Strategy"),(0,a.kt)("p",null,"One or more partial framebuffer blocks are used to emulate a full size\nframebuffer."),(0,a.kt)("p",null,"The partial blocks are reused to render all parts of the current frame\nthat needs to be updated. When a block is rendered it can be\ntransferred to GRAM and used for subsequent rendering."),(0,a.kt)("p",null,"To minimize the risk of tearing we strive to have the largest margin\nbetween GRAM being updated by the Display Transfer and the Display\nController scanline. This is done be having the transferline behind\nthe scanline, which means that we can only render the current frame\nand not begin rendering the next frame. Render time of the current\nframe depends on the number of partial blocks defined and the time it\ntakes to transfer each block. This means that we are allowed to render\na block that is ahead of the Display Controller scanline if a block is\navailable. If rendering and transferring of all the dirty areas of the\ncurrent frame takes longer than the Display Controller its scanline\ncan wrap around and catch the transferline, resulting in tearing. This\nis caused by rendering complex UI components and/or transferring too\nmany pixels."),(0,a.kt)(n.Z,{imageSource:"/img/basic-concepts/gram-partial.png",noShadow:"true",width:"700",mdxType:"Figure"},"Partial Buffering Strategy Concept"),(0,a.kt)("h3",s({},{id:"framebuffer-strategy-getting-started"}),"Getting Started with Framebuffer Strategies"),(0,a.kt)("p",null,"In the following section we will show common hardware setups and\npoint to scenarios on how to use framebuffer strategies on various\nhardware setups."),(0,a.kt)(i.Z,{mdxType:"FurtherReading"},"See article ",(0,a.kt)(l.Z,{to:"../development/touchgfx-hal-development/generator-how-to/touchgfx-al-configuration/display#buffering-strategies",mdxType:"Link"},"Buffering Strategies & Location")," on how to configure a framebuffer strategy through the TouchGFX Generator."),(0,a.kt)("h4",s({},{id:"displays-with-gram-getting-started"}),"Displays with GRAM"),(0,a.kt)("p",null,"This display type has a dedicated RAM buffer with the same size as the\ndisplay, i.e. a full size framebuffer."),(0,a.kt)(n.Z,{imageSource:"/img/basic-concepts/display-with-gram.webp",noShadow:"true",width:"700",mdxType:"Figure"},"Display with GRAM"),(0,a.kt)("p",null,"The interfaces for this type of display are:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"FMC"),(0,a.kt)("li",{parentName:"ul"},"SPI"),(0,a.kt)("li",{parentName:"ul"},"DSI (Command Mode)")),(0,a.kt)("p",null,"Scenarios demonstrating the use of these interfaces can be found here:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",s({parentName:"li"},{href:"../development/touchgfx-hal-development/scenarios/scenarios-fmc"}),"FMC Display Interface")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",s({parentName:"li"},{href:"../development/touchgfx-hal-development/scenarios/scenarios-spi"}),"SPI Display Interface")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",s({parentName:"li"},{href:"../development/touchgfx-hal-development/scenarios/scenarios-dsi-command-mode"}),"DSI (Command Mode) Display Interface"))),(0,a.kt)("h4",s({},{id:"displays-without-gram-getting-started"}),"Displays without GRAM"),(0,a.kt)("p",null,"This display type doesn't have a dedicated RAM buffer."),(0,a.kt)(n.Z,{imageSource:"/img/basic-concepts/display-without-gram.webp",noShadow:"true",width:"600",mdxType:"Figure"},"Display without GRAM"),(0,a.kt)("p",null,"The interfaces for this type of display are:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"LTDC"),(0,a.kt)("li",{parentName:"ul"},"DSI (Video Mode)")),(0,a.kt)("p",null,"Scenarios demonstrating the use of these interfaces can be found here:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",s({parentName:"li"},{href:"../development/touchgfx-hal-development/scenarios/scenarios-ltdc-parallel-rgb"}),"LTDC Display Interface")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",s({parentName:"li"},{href:"../development/touchgfx-hal-development/scenarios/scenarios-dsi-video-mode"}),"MIPI-DSI Video Mode"))),(0,a.kt)(i.Z,{mdxType:"FurtherReading"},"The ",(0,a.kt)(l.Z,{to:"https://www.st.com/content/ccc/resource/technical/document/application_note/group0/25/ca/f9/b4/ae/fc/4e/1e/DM00287603/files/DM00287603.pdf/jcr:content/translations/en.DM00287603.pdf",mdxType:"Link"},"STM32 LTDC")," display controller document has further details on framebuffers."))}b.isMDXComponent=!0}}]);