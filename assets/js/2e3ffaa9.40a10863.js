"use strict";(self.webpackChunktouchgfx_documentation=self.webpackChunktouchgfx_documentation||[]).push([[22028],{49613:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>f});var r=n(59496);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),c=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=c(e.components);return r.createElement(s.Provider,{value:t},e.children)},h="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),h=c(n),p=a,f=h["".concat(s,".").concat(p)]||h[p]||u[p]||i;return n?r.createElement(f,o(o({ref:t},d),{},{components:n})):r.createElement(f,o({ref:t},d))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=p;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[h]="string"==typeof e?e:a,o[1]=l;for(var c=2;c<i;c++)o[c]=n[c];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}p.displayName="MDXCreateElement"},93822:(e,t,n)=>{n.d(t,{Z:()=>l});var r=n(59496),a=n(96151);const i=r.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 16 16"},r.createElement("path",{fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"}));class o extends r.Component{render(){return r.createElement(a.Z,{color:"var(--highlight-color-caution)",header:"Caution",type:"caution",icon:i},this.props.children)}}const l=o},28128:(e,t,n)=>{n.d(t,{Z:()=>i});var r=n(59496);class a extends r.Component{render(){return r.createElement("div",{className:"code-header"},r.createElement("div",null,r.createElement("h5",null,this.props.children)))}}const i=a},89639:(e,t,n)=>{n.d(t,{Z:()=>i});var r=n(59496),a=n(97395);const i=function(e){const t=e.noShadow||!1,n=e.width,i=e.height,o=(0,a.Z)(e.imageSource);return t?r.createElement("div",{className:"figure noshadow"},r.createElement("a",{href:o,target:"_blank"},r.createElement("img",{width:n,height:i,src:o})),r.createElement("p",null,e.children)):r.createElement("div",{className:"figure"},r.createElement("a",{href:o,target:"_blank"},r.createElement("img",{width:n,height:i,src:o})),r.createElement("p",null,e.children))}},48753:(e,t,n)=>{n.d(t,{Z:()=>l});var r=n(59496),a=n(96151);const i=r.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},r.createElement("path",{fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}));class o extends r.Component{render(){return r.createElement(a.Z,{color:"var(--highlight-color-further-reading)",header:"Further reading",type:"further-reading",icon:i},this.props.children)}}const l=o},96151:(e,t,n)=>{n.d(t,{Z:()=>i});var r=n(59496);class a extends r.Component{render(){const e=`highlight highlight-${this.props.type}`;return r.createElement("div",{className:e},r.createElement("div",{className:"highlight-heading"},r.createElement("h5",null,r.createElement("div",{className:"highlight-icon"},this.props.icon),this.props.header)),r.createElement("div",{className:"highlight-content"},this.props.children))}}const i=a},49018:(e,t,n)=>{n.d(t,{Z:()=>l});var r=n(59496),a=n(96151);const i=r.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},r.createElement("path",{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}));class o extends r.Component{render(){return r.createElement(a.Z,{color:"var(--highlight-color-note)",header:"Note",type:"note",icon:i},this.props.children)}}const l=o},95940:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>m,contentTitle:()=>p,default:()=>y,frontMatter:()=>u,metadata:()=>f,toc:()=>g});n(59496);var r=n(49613),a=n(89639),i=n(49018),o=n(93822),l=n(28128),s=n(48753),c=n(18399);function d(){return d=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},d.apply(this,arguments)}function h(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}const u={id:"scenarios-ltdc-parallel-rgb",title:"LTDC Display Interface"},p=void 0,f={unversionedId:"development/touchgfx-hal-development/scenarios/scenarios-ltdc-parallel-rgb",id:"development/touchgfx-hal-development/scenarios/scenarios-ltdc-parallel-rgb",title:"LTDC Display Interface",description:"This scenario describes how to configure the STM32 LTDC display controller and TouchGFX Generator when using a LCD-TFT parallel display interface.",source:"@site/docs/development/touchgfx-hal-development/scenarios/scenarios-ltdc-parallel-rgb.mdx",sourceDirName:"development/touchgfx-hal-development/scenarios",slug:"/development/touchgfx-hal-development/scenarios/scenarios-ltdc-parallel-rgb",permalink:"/4.25/docs/development/touchgfx-hal-development/scenarios/scenarios-ltdc-parallel-rgb",draft:!1,tags:[],version:"current",frontMatter:{id:"scenarios-ltdc-parallel-rgb",title:"LTDC Display Interface"},sidebar:"docs",previous:{title:"Scenarios",permalink:"/4.25/docs/category/scenarios"},next:{title:"MIPI-DSI Video Mode",permalink:"/4.25/docs/development/touchgfx-hal-development/scenarios/scenarios-dsi-video-mode"}},m={},g=[{value:"Configuration",id:"configuration",level:2},{value:"Parameter and Layer Configuration",id:"parameter-and-layer-configuration",level:3},{value:"TouchGFX Driver / VSYNC Signal",id:"touchgfx-driver--vsync-signal",level:3},{value:"LTDC Frame Buffer address configuration",id:"ltdc-frame-buffer-address-configuration",level:3},{value:"GFXMMU configuration",id:"gfxmmu",level:3},{value:"Framebuffer allocation",id:"framebuffer-allocation",level:3},{value:"Buffer Location - By allocation",id:"by-allocation",level:4},{value:"Buffer Location - By address",id:"by-address",level:4},{value:"Supported Framebuffer Strategies",id:"supported-framebuffer-strategies",level:2},{value:"Single",id:"single",level:3},{value:"Reference implementation",id:"reference-implementation",level:4},{value:"Double",id:"double",level:3},{value:"Reference implementation",id:"reference-implementation-1",level:4},{value:"Partial - LTDC driven display",id:"partial",level:3},{value:"Reference implementation",id:"reference-implementation-2",level:4}],b={toc:g},T="wrapper";function y(e){var{components:t}=e,n=h(e,["components"]);return(0,r.kt)(T,d({},b,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This scenario describes how to configure the STM32 LTDC display controller and ",(0,r.kt)("em",{parentName:"p"},"TouchGFX Generator")," when using a LCD-TFT parallel display interface."),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"TouchGFX Generator")," can generate a ",(0,r.kt)("strong",{parentName:"p"},"full TouchGFX AL")," that configures the LTDC to transfer pixels from the framebuffer memory to the display and synchronize the display with the TouchGFX Engine."),(0,r.kt)("h2",d({},{id:"configuration"}),"Configuration"),(0,r.kt)("p",null,"Enable the ",(0,r.kt)("em",{parentName:"p"},"LTDC")," from the ",(0,r.kt)("em",{parentName:"p"},"Multimedia")," group in the STM32CubeMX category list."),(0,r.kt)(a.Z,{noShadow:!0,imageSource:"/img/development/touchgfx-hal-development/touchgfx-generator/ltdc-modes.webp",width:"400",mdxType:"Figure"}),(0,r.kt)("p",null,"Once LTDC is enabled, the ",(0,r.kt)("em",{parentName:"p"},"Parallel RGB (LTDC)")," option becomes available through the ",(0,r.kt)("em",{parentName:"p"},"Display")," section of the TouchGFX Generator."),(0,r.kt)(a.Z,{noShadow:!0,imageSource:"/img/development/touchgfx-hal-development/touchgfx-generator/display-if-options.webp",width:"400",mdxType:"Figure"}),(0,r.kt)("p",null,"After LTDC is enabled through STM32CubeMX, the following parameters must be configured:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Configure LTDC (GPIO and timings) to match connected display specifications"),(0,r.kt)("li",{parentName:"ol"},"Configure LTDC to match desired TouchGFX application specifications.")),(0,r.kt)("p",null,"The TouchGFX Generator can read various configurations from STM32CubeMX and provide a list of warnings, recommendations or errors in the ",(0,r.kt)("em",{parentName:"p"},"Dependencies")," section. The image below shows the list of dependencies present when initially enabling LTDC in STM32CubeMX:"),(0,r.kt)(a.Z,{noShadow:!0,imageSource:"/img/development/touchgfx-hal-development/scenarios/ltdc-dependencies.webp",width:"700",mdxType:"Figure"}),(0,r.kt)(i.Z,{mdxType:"Note"},"LTDC recommendations, warnings and errors will be visible in the TouchGFX Generator interface as soon as LTDC is enabled through STM32CubeMX."),(0,r.kt)("h3",d({},{id:"parameter-and-layer-configuration"}),"Parameter and Layer Configuration"),(0,r.kt)("p",null,"The following parameters must be configured in the LTDC block:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",d({parentName:"tr"},{align:null}),"Dependency"),(0,r.kt)("th",d({parentName:"tr"},{align:null}),"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",d({parentName:"tr"},{align:null}),"Number of layers"),(0,r.kt)("td",d({parentName:"tr"},{align:null}),"TouchGFX is only capable of utilizing a single layer.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",d({parentName:"tr"},{align:null}),"Window position"),(0,r.kt)("td",d({parentName:"tr"},{align:null}),"By default, the Horizontal and Vertical window positions of the LTDC layer are 0. The window Horizontal and Vertical stop must be set equal to the displays dimensions.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",d({parentName:"tr"},{align:null}),"Alpha Constant is 0"),(0,r.kt)("td",d({parentName:"tr"},{align:null}),"By default, the alpha constant of LTDC layers is 0. This should be > 0 and preferably 255 unless there is an intent to have a global alpha at all times in an application.")))),(0,r.kt)("p",null,"The following image shows the LTDC configuration that satisfies the conditions of the warnings, causing the Dependencies group to disappear from the TouchGFX Generator interface."),(0,r.kt)(a.Z,{noShadow:!0,imageSource:"/img/development/touchgfx-hal-development/touchgfx-generator/ltdc-config.webp",width:"300",mdxType:"Figure"}),(0,r.kt)(i.Z,{mdxType:"Note"},"TouchGFX Generator inherits the ",(0,r.kt)("b",null,"Width")," and ",(0,r.kt)("b",null,"Height")," values from the LTDC configuration, if LTDC is enabled and Parallel RGB (LTDC) option is selected in the Display section."),(0,r.kt)("h3",d({},{id:"touchgfx-driver--vsync-signal"}),"TouchGFX Driver / VSYNC Signal"),(0,r.kt)("p",null,"Once ",(0,r.kt)("em",{parentName:"p"},"Parallel RGB (LTDC)")," is selected as Display Interface, developers gain access to the ",(0,r.kt)("em",{parentName:"p"},"LTDC")," Application Tick Driver, which use the LTDC interrupt to drive the TouchGFX Engine main loop. This is the recommended way to drive the TouchGFX Engine main loop when using LTDC."),(0,r.kt)(a.Z,{noShadow:!0,imageSource:"/img/development/touchgfx-hal-development/scenarios/ltdc-application-tick-source.webp",width:"350",mdxType:"Figure"}),(0,r.kt)(i.Z,{mdxType:"Note"},"For the LTDC driver to automatically drive the  TouchGFX application, users must enable the LTDC global interrupt through the LTDC NVIC settings or through Global NVIC settings, and also enable generation of handler code."),(0,r.kt)("p",null,"The following code is a generated LTDC interrupt handler (for single or double framebuffer strategy) that automatically signals and unblocks the TouchGFX Engine main loop when the display is ready."),(0,r.kt)(l.Z,{mdxType:"CodeHeader"},"TouchGFXGeneratedHAL.cpp"),(0,r.kt)("pre",null,(0,r.kt)("code",d({parentName:"pre"},{className:"language-cpp",metastring:"{14-15}","{14-15}":!0}),'extern "C"\n{\n    void HAL_LTDC_LineEventCallback(LTDC_HandleTypeDef* hltdc)\n    {\n        if (!HAL::getInstance())\n        {\n            return;\n        }\n\n        if (LTDC->LIPCR == lcd_int_active_line)\n        {\n            //entering active area\n            HAL_LTDC_ProgramLineEvent(hltdc, lcd_int_porch_line);\n            HAL::getInstance()->vSync();\n            OSWrappers::signalVSync();\n\n            // Swap frame buffers immediately instead of waiting for the task to be scheduled in.\n            // Note: task will also swap when it wakes up, but that operation is guarded and will not have\n            // any effect if already swapped.\n            HAL::getInstance()->swapFrameBuffers();\n            GPIO::set(GPIO::VSYNC_FREQ);\n        }\n        else\n        {\n            //exiting active area\n            HAL_LTDC_ProgramLineEvent(hltdc, lcd_int_active_line);\n\n            // Signal to the framework that display update has finished.\n            HAL::getInstance()->frontPorchEntered();\n            GPIO::clear(GPIO::VSYNC_FREQ);\n        }\n    }\n}\n')),(0,r.kt)("h3",d({},{id:"ltdc-frame-buffer-address-configuration"}),"LTDC Frame Buffer address configuration"),(0,r.kt)("p",null,"The generated TouchGFX HAL will automatically configure the LTDC Layer\nColor Frame Buffer Start Address at runtime, so you should not set a\nvalue in LTDC configuration."),(0,r.kt)("h3",d({},{id:"gfxmmu"}),"GFXMMU configuration"),(0,r.kt)("p",null,"When using ",(0,r.kt)("em",{parentName:"p"},"Partial Buffer - LTDC driven display")," framebuffer strategy, the GFXMMU must be enabled and configured. The GFXMMU is used to map the framebuffer addresses that are read by the LTDC to the addresses of the partial framebuffer block in physical memory."),(0,r.kt)("p",null,"First, enable the GFXMMU in STM32CubeMX under the ",(0,r.kt)("em",{parentName:"p"},"Multimedia")," section, and enable ",(0,r.kt)("em",{parentName:"p"},"Address Translation"),". For 16- and 32-bit framebuffer pixel formats a ",(0,r.kt)("em",{parentName:"p"},"Block Size")," of 16 bytes is recommended. For 24-bit framebuffer pixel formats a ",(0,r.kt)("em",{parentName:"p"},"Block Size")," of 12 bytes is required."),(0,r.kt)(a.Z,{noShadow:!0,imageSource:"/img/development/touchgfx-hal-development/scenarios/gfxmmu-config.png",width:"700",mdxType:"Figure"}),(0,r.kt)(i.Z,{mdxType:"Note"},"Some MCU's (e.g., STM32U5G9) define a ",(0,r.kt)("i",null,"Number of blocks of 16 bytes per line")," parameter with options 256 or 192 instead of ",(0,r.kt)("i",null,"Block Size"),". These correspond to 16 or 12 byte Block Size respectively."),(0,r.kt)(o.Z,{mdxType:"Caution"},"When using the GFXMMU to map addresses, there are limitations to the maximum width and height of the Display being used depending on the framebuffer pixel format and Block Size:",(0,r.kt)("li",null,"32-bit framebuffer pixel format (12-byte / 16-byte): ",(0,r.kt)("b",null,"768x1024px / 1024x1024px")),(0,r.kt)("li",null,"16-bit framebuffer pixel format (12-byte / 16-byte): ",(0,r.kt)("b",null,"1536x1024px / 2048x1024px")),(0,r.kt)("li",null,"24-bit framebuffer pixel format (12-byte): ",(0,r.kt)("b",null,"1024x1024px"))),(0,r.kt)("p",null,"The TouchGFX Generator will automatically generate an address look-up table (LUT) that maps the addresses based on the GFXMMU configurations and LTDC layer settings."),(0,r.kt)("p",null,"After enabling the GFXMMU, the number of partial blocks used (or the number of times the partial framebuffer block fits into the display) can be configured in the TouchGFX Generator."),(0,r.kt)(a.Z,{noShadow:!0,imageSource:"/img/development/touchgfx-hal-development/scenarios/number-of-blocks.png",width:"450",mdxType:"Figure"}),(0,r.kt)("p",null,"This parameter will directly impact the amount of RAM used for the framebuffer block. The number of blocks must be a power-of-2, e.g., 2, 4, and 8, which results in a framebuffer block of size 1/2, 1/4, and 1/8 of total display size respectively."),(0,r.kt)("h3",d({},{id:"framebuffer-allocation"}),"Framebuffer allocation"),(0,r.kt)("p",null,"When using ",(0,r.kt)("em",{parentName:"p"},"Partial Buffer - LTDC driven display")," framebuffer strategy, the semantics of the ",(0,r.kt)(c.Z,{to:"../../../development/touchgfx-hal-development/generator-how-to/touchgfx-al-configuration/display",mdxType:"Link"},"framebuffer allocation strategy")," are different than usual."),(0,r.kt)("p",null,"If choosing ",(0,r.kt)("em",{parentName:"p"},"by allocation"),", the TouchGFX Engine will draw directly into the physical partial framebuffer block, while the LTDC reads through the GFXMMU address LUT."),(0,r.kt)("p",null,"If choosing ",(0,r.kt)("em",{parentName:"p"},"by address"),", only the address of one of the GFXMMU virtual buffers can be specified and the TouchGFX Engine will draw through the virtual buffer of the GFXMMU when rendering, instead of directly into the physical framebuffer block."),(0,r.kt)("h4",d({},{id:"by-allocation"}),"Buffer Location - By allocation"),(0,r.kt)("p",null,"The recommended framebuffer allocation strategy is ",(0,r.kt)("em",{parentName:"p"},"by allocation"),". This allows the TouchGFX Engine to draw directly into the physical partial framebuffer block, while the LTDC reads through the GFXMMU address LUT."),(0,r.kt)("h4",d({},{id:"by-address"}),"Buffer Location - By address"),(0,r.kt)("p",null,"This option is only recommended on some specific platforms with limitations using RGB888 framebuffer format and GPU2D (NeoChrome) to accelerate rendering."),(0,r.kt)("p",null,"Some MCU's using GPU2D (NeoChrome) to accelerate rendering do not support writing to a 24-bit RGB888 framebuffer. In this case, the GFXMMU is used to ",(0,r.kt)("em",{parentName:"p"},"pack")," data that is read/written from a 32-bit ARGB8888 format\nto the RGB888 format of the physical framebuffer block."),(0,r.kt)(s.Z,{mdxType:"FurtherReading"},"MCU's with limitations using RGB888 framebuffer format are mentioned in this ",(0,r.kt)(c.Z,{to:"../../../development/scenarios/touchgfx-on-gpu2d#stm32h7s8-and-stm32n657-limitations-when-using-rgb888-framebuffer-24-bpp",mdxType:"Link"},"article")),(0,r.kt)("p",null,"To enable this, the LTDC Pixel format must be setup to use the ARGB8888 framebuffer format and use one of the virtial buffers of the GFXMMU ",(0,r.kt)("inlineCode",{parentName:"p"},"GFXMMU_VIRTUAL_BUFFERX_BASE")," as the framebuffer address. It is important to use the same GFXMMU buffer address that\nconfigured in the GFXMMU.\nConfigure the GFXMMU to use a ",(0,r.kt)("em",{parentName:"p"},"Block Size")," of 12 bytes, and enable ",(0,r.kt)("em",{parentName:"p"},"Packing")," for the buffer as shown below:"),(0,r.kt)(a.Z,{noShadow:!0,imageSource:"/img/development/touchgfx-hal-development/scenarios/24-bit-gfxmmu.png",width:"500",mdxType:"Figure"}),(0,r.kt)("p",null,"These options will be reflected in the TouchGFX Generator UI:"),(0,r.kt)(a.Z,{noShadow:!0,imageSource:"/img/development/touchgfx-hal-development/scenarios/24-bit-partial-ltdc.png",width:"400",mdxType:"Figure"}),(0,r.kt)("p",null,"The physical 24-bit framebuffer memory region must be defined in the linker script with the correct size (i.e., 3 bytes per pixel) and the start address of this region must be used to configure the physical buffer address of the GFXMMU."),(0,r.kt)(i.Z,{mdxType:"Note"},"This configuration will potentially degrade performance, because the TouchGFX Engine will draw through the virtual buffer of the GFXMMU when rendering, instead of directly into the physical framebuffer block."),(0,r.kt)("h2",d({},{id:"supported-framebuffer-strategies"}),"Supported Framebuffer Strategies"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Single"),(0,r.kt)("li",{parentName:"ul"},"Double"),(0,r.kt)("li",{parentName:"ul"},"Partial - LTDC driven display")),(0,r.kt)(s.Z,{mdxType:"FurtherReading"},"See article ",(0,r.kt)(c.Z,{to:"../../../basic-concepts/framebuffer#framebuffer-strategies",mdxType:"Link"},"Framebuffer Strategies")," for a general introduction to framebuffer strategies in TouchGFX."),(0,r.kt)("h3",d({},{id:"single"}),"Single"),(0,r.kt)("p",null,"Using a LTDC driven display with the single framebuffer strategy, will generate the following code in the HAL to allow the TouchGFX Engine to follow the refresh cycle of the display to optimize the rendering process:"),(0,r.kt)(l.Z,{mdxType:"CodeHeader"},"TouchGFXGeneratedHAL.cpp"),(0,r.kt)("pre",null,(0,r.kt)("code",d({parentName:"pre"},{className:"language-cpp"}),"uint16_t TouchGFXGeneratedHAL::getTFTCurrentLine()\n{\n    // The CPSR register (bits 15:0) specify current line of TFT controller.\n    uint16_t curr = (uint16_t)(LTDC->CPSR & LTDC_CPSR_CYPOS_Msk);\n    uint16_t backPorchY = (uint16_t)(LTDC->BPCR & LTDC_BPCR_AVBP_Msk) + 1;\n\n    // The semantics of the getTFTCurrentLine() function is to return a value\n    // in the range of 0-totalheight. If we are still in back porch area, return 0.\n    return (curr < backPorchY) ? 0 : (curr - backPorchY);\n}\n")),(0,r.kt)("p",null,"In the LTDC interrupt handler, the LTDC framebuffer address will not be swapped and the TouchGFX Engine is allowed to finish rendering the current frame when the display refresh cycle has exited the ",(0,r.kt)("em",{parentName:"p"},"active area"),", which is when the display have read the last line of the framebuffer."),(0,r.kt)("h4",d({},{id:"reference-implementation"}),"Reference implementation"),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"TouchGFX Board Setup")," STM32U5G9J Discovery Kit 2 includes a reference implementation of double framebuffer strategy. Change the framebuffer strategy to single in the TouchGFX Generator and generate code to see an example of using single framebuffer strategy:"),(0,r.kt)(a.Z,{imageSource:"/img/development/touchgfx-hal-development/scenarios/stm32u5g9-dk2.png",width:"200",mdxType:"Figure"}),(0,r.kt)("h3",d({},{id:"double"}),"Double"),(0,r.kt)("p",null,"When using an LTDC driven display with the double framebuffer strategy, the LTDC framebuffer address will be swapped to the other framebuffer in the LTDC interrupt handler.\nThis allows the TouchGFX Engine to render the next frame immediately after swapping the LTDC framebuffer address, while the LTDC is reading the current frame from the other framebuffer."),(0,r.kt)("h4",d({},{id:"reference-implementation-1"}),"Reference implementation"),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"TouchGFX Board Setup")," STM32U5G9J Discovery Kit 2 includes a reference implementation:"),(0,r.kt)(a.Z,{imageSource:"/img/development/touchgfx-hal-development/scenarios/stm32u5g9-dk2.png",width:"200",mdxType:"Figure"}),(0,r.kt)("h3",d({},{id:"partial"}),"Partial - LTDC driven display"),(0,r.kt)("p",null,"Using a LTDC driven display with the Partial framebuffer strategy, is similar to using single framebuffer strategy, but the TouchGFX Engine will only render into the partial framebuffer block.\nBecause the same framebuffer block is reused to render all parts of the display, it is important to efficiently manage the rendering process to avoid tearing and missing hard deadlines.\nTo enable this, the TouchGFX Generator will generate the following code in the HAL to allow the TouchGFX Engine to configure LTDC line interrupts to signal the TouchGFX Engine when to render the next part of the display:"),(0,r.kt)(l.Z,{mdxType:"CodeHeader"},"TouchGFXGeneratedHAL.cpp"),(0,r.kt)("pre",null,(0,r.kt)("code",d({parentName:"pre"},{className:"language-cpp"}),"void TouchGFXGeneratedHAL::waitForLTDCLines(uint16_t numberOfLines)\n{\n    // The CPSR register (bits 15:0) specify current line of TFT controller.\n    uint16_t curr = LTDC->CPSR & LTDC_CPSR_CYPOS_Msk;\n\n    // The AWCR register (10:0) specify the accumulated active height.\n    uint16_t max = (LTDC->AWCR & LTDC_AWCR_AAH_Msk) - 1;\n\n    // Calculate the line at which to configure the interrupt.\n    curr += numberOfLines;\n    if (curr > max)\n    {\n        curr -= max;\n    }\n\n    // Configure line interrupt\n    HAL_LTDC_ProgramLineEvent(&hltdc, curr);\n\n    // Wait for VSync signal, which fires on the line interrupt that we just configured.\n    OSWrappers::waitForVSync();\n}\n")),(0,r.kt)("p",null,"The function ",(0,r.kt)("inlineCode",{parentName:"p"},"TouchGFXGeneratedHAL::waitForLTDCLines(uint16_t)")," is called from the TouchGFX Engine drawing loop. The specific number of line being requested depends on a set of parameters.\nDepending on the ",(0,r.kt)("em",{parentName:"p"},"Number Of Partial Blocks")," that are configured in the TouchGFX Generator, a set of appropriate default values will be assigned to these parameters."),(0,r.kt)("p",null,"Because the framebuffer block is reused to render all parts of the display, the ",(0,r.kt)("em",{parentName:"p"},"VSYNC")," signal which normally signals the LTDC scanline has left the active area, is used to signal the TouchGFX Engine to start rendering the next part of the display:"),(0,r.kt)(l.Z,{mdxType:"CodeHeader"},"TouchGFXGeneratedHAL.cpp"),(0,r.kt)("pre",null,(0,r.kt)("code",d({parentName:"pre"},{className:"language-cpp",metastring:"{5}","{5}":!0}),'extern "C"\n{\n    void HAL_LTDC_LineEventCallback(LTDC_HandleTypeDef* hltdc)\n    {\n        OSWrappers::signalVSync();\n    }\n}\n')),(0,r.kt)("h4",d({},{id:"reference-implementation-2"}),"Reference implementation"),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"TouchGFX Board Setup")," STM32H7S78 DK Partial Framebuffer includes a reference implementation:"),(0,r.kt)(a.Z,{imageSource:"/img/development/touchgfx-hal-development/scenarios/stm32h7s78-dk-partial-fb.png",width:"200",mdxType:"Figure"}))}y.isMDXComponent=!0}}]);