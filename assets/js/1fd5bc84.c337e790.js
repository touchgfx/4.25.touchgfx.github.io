"use strict";(self.webpackChunktouchgfx_documentation=self.webpackChunktouchgfx_documentation||[]).push([[26803],{49613:(e,t,a)=>{a.d(t,{Zo:()=>u,kt:()=>h});var r=a(59496);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},l=Object.keys(e);for(r=0;r<l.length;r++)a=l[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(r=0;r<l.length;r++)a=l[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var s=r.createContext({}),p=function(e){var t=r.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},u=function(e){var t=p(e.components);return r.createElement(s.Provider,{value:t},e.children)},m="mdxType",f={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},c=r.forwardRef((function(e,t){var a=e.components,n=e.mdxType,l=e.originalType,s=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),m=p(a),c=n,h=m["".concat(s,".").concat(c)]||m[c]||f[c]||l;return a?r.createElement(h,i(i({ref:t},u),{},{components:a})):r.createElement(h,i({ref:t},u))}));function h(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var l=a.length,i=new Array(l);i[0]=c;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[m]="string"==typeof e?e:n,i[1]=o;for(var p=2;p<l;p++)i[p]=a[p];return r.createElement.apply(null,i)}return r.createElement.apply(null,a)}c.displayName="MDXCreateElement"},28128:(e,t,a)=>{a.d(t,{Z:()=>l});var r=a(59496);class n extends r.Component{render(){return r.createElement("div",{className:"code-header"},r.createElement("div",null,r.createElement("h5",null,this.props.children)))}}const l=n},89639:(e,t,a)=>{a.d(t,{Z:()=>l});var r=a(59496),n=a(7029);const l=function(e){const t=e.noShadow||!1,a=e.width,l=e.height,i=(0,n.Z)(e.imageSource);return t?r.createElement("div",{className:"figure noshadow"},r.createElement("a",{href:i,target:"_blank"},r.createElement("img",{width:a,height:l,src:i})),r.createElement("p",null,e.children)):r.createElement("div",{className:"figure"},r.createElement("a",{href:i,target:"_blank"},r.createElement("img",{width:a,height:l,src:i})),r.createElement("p",null,e.children))}},48753:(e,t,a)=>{a.d(t,{Z:()=>o});var r=a(59496),n=a(96151);const l=r.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},r.createElement("path",{fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}));class i extends r.Component{render(){return r.createElement(n.Z,{color:"var(--highlight-color-further-reading)",header:"Further reading",type:"further-reading",icon:l},this.props.children)}}const o=i},96151:(e,t,a)=>{a.d(t,{Z:()=>l});var r=a(59496);class n extends r.Component{render(){const e=`highlight highlight-${this.props.type}`;return r.createElement("div",{className:e},r.createElement("div",{className:"highlight-heading"},r.createElement("h5",null,r.createElement("div",{className:"highlight-icon"},this.props.icon),this.props.header)),r.createElement("div",{className:"highlight-content"},this.props.children))}}const l=n},85083:(e,t,a)=>{a.d(t,{Z:()=>l});var r=a(59496);class n extends r.Component{render(){return r.createElement("p",null,r.createElement("div",{className:"videoWrapper"},r.createElement("video",{controls:!0},r.createElement("source",{src:this.props.url,type:"video/mp4"}))))}}const l=n},55271:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>h,contentTitle:()=>f,default:()=>y,frontMatter:()=>m,metadata:()=>c,toc:()=>d});a(59496);var r=a(49613),n=a(89639),l=a(28128),i=a(85083),o=a(48753),s=a(95375);function p(){return p=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var a=arguments[t];for(var r in a)Object.prototype.hasOwnProperty.call(a,r)&&(e[r]=a[r])}return e},p.apply(this,arguments)}function u(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},l=Object.keys(e);for(r=0;r<l.length;r++)a=l[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(r=0;r<l.length;r++)a=l[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}const m={id:"lowering-memory-usage-with-partial-framebuffer",title:"Lowering Memory Usage with Partial Framebuffer"},f=void 0,c={unversionedId:"development/scenarios/lowering-memory-usage-with-partial-framebuffer",id:"development/scenarios/lowering-memory-usage-with-partial-framebuffer",title:"Lowering Memory Usage with Partial Framebuffer",description:"This section explains, by exemplifying with a clock application, how",source:"@site/docs/development/scenarios/lowering-memory-usage-with-partial-framebuffer.mdx",sourceDirName:"development/scenarios",slug:"/development/scenarios/lowering-memory-usage-with-partial-framebuffer",permalink:"/4.25/docs/development/scenarios/lowering-memory-usage-with-partial-framebuffer",draft:!1,tags:[],version:"current",frontMatter:{id:"lowering-memory-usage-with-partial-framebuffer",title:"Lowering Memory Usage with Partial Framebuffer"},sidebar:"docs",previous:{title:"Running graphics from external RAM",permalink:"/4.25/docs/development/scenarios/running-graphics-from-external-ram"},next:{title:"Flash-limited GUI development",permalink:"/4.25/docs/flash-limited"}},h={},d=[{value:"Full-size Frame Buffer Memory",id:"full-size-frame-buffer-memory",level:2},{value:"Partial Frame Buffer Memory",id:"partial-frame-buffer-memory",level:2},{value:"Display Tearing",id:"display-tearing",level:2},{value:"Display Update Example",id:"display-update-example",level:2},{value:"Configuring Partial Frame Buffers",id:"configuring-partial-frame-buffers",level:2},{value:"Transferring Frame Buffers to the Screen",id:"transferring-frame-buffers-to-the-screen",level:2},{value:"Conclusion",id:"conclusion",level:2}],g={toc:d},b="wrapper";function y(e){var{components:t}=e,a=u(e,["components"]);return(0,r.kt)(b,p({},g,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This section explains, by exemplifying with a clock application, how\nto configure and use Partial Frame Buffers with a display with GRAM,\nto lower memory requirements at the expense of some performance."),(0,r.kt)("p",null,"A video of the application running on the STM32L4R9Discovery\nevaluation kit can be seen below"),(0,r.kt)(i.Z,{url:"http://sw-center-st-com.s3-eu-west-1.amazonaws.com/touchgfx/TouchGFX/knowledgebase/Partial%20framebuffer/Partial%20framebuffer.mp4",mdxType:"Video"}),(0,r.kt)("h2",p({},{id:"full-size-frame-buffer-memory"}),"Full-size Frame Buffer Memory"),(0,r.kt)("p",null,"Normally, your frame buffer is a big memory array with enough memory\nto hold all the pixels available on your display.\nIf you are running on a 24-bit display with a resolution of 480 x 272,\na full-size frame buffer holds 480 x 272 x 3 bytes = 391,680 bytes."),(0,r.kt)("p",null,'Some applications may have 2- ("Double buffering") or even 3 frame\nbuffers. The total memory requirement in these cases would then be\n783,360 and 1,175,040 bytes.'),(0,r.kt)("p",null,"TouchGFX writes pixel values to the frame buffer when drawing any part\nof the UI, after all drawing operations have completed, the frame\nbuffer is transferred to the display. Typically, the whole frame\nbuffer is transferred to the display even if only a part of the UI is\nupdated.\nGenerally, the framebuffer can be updated in many small blocks before\nitis transferred."),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Update1, Update 2, Update 3, ..., Update N, Transfer to display")),(0,r.kt)("p",null,"In some cases, particularly in low cost solutions with no external\nRAM, frame buffers are required to be small enough to allow the rest\nof the application to fit in the internal RAM together with the\nframebuffer. This is where partial frame buffers are useful."),(0,r.kt)("h2",p({},{id:"partial-frame-buffer-memory"}),"Partial Frame Buffer Memory"),(0,r.kt)("p",null,"Partial frame buffers allows a TouchGFX application to run on top of a\nfew, less than full-size frame buffers. The number and size of the\nframe buffers are configurable.\nThis technique can lower the memory requirements of an application by\na substantial amount, but comes with some limitations:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Partial frame buffers will only work on displays that have built-in memory. These are typically DSI displays or displays with a parallel bus connection (DBI type A/B, 8080/6800) or SPI-bus connection."),(0,r.kt)("li",{parentName:"ul"},"Potential tearing for complex applications.")),(0,r.kt)("p",null,"Rather than using a frame buffer representing every pixel on the\ndisplay, partial frame buffers typically cover a smaller part.\nIn the clock example used in this article, three frame buffers of\n11,700 bytes each are used. This results in a memory footprint for\nframe buffers of 35,100 bytes."),(0,r.kt)("p",null,"Whenever the application needs to update a part of the UI, TouchGFX\nwill select one of the configured, partial frame buffers, complete its\ndrawing operation in the partial framebuffer, and transfer that part\nto the display. This is repeated for all areas of the UI that need to\nbe rendered - This changes the formula for updating and transferring\ndata to:"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Update1, Transfer1, Update2, Transfer2, Update3, Transfer3, ..., UpdateN, TransferN")),(0,r.kt)("p",null,"In some cases the transfer of one partial frame buffer can run while\nthe update of the next buffer is running."),(0,r.kt)("h2",p({},{id:"display-tearing"}),"Display Tearing"),(0,r.kt)("p",null,"Contrary to using full-size frame buffers, TouchGFX will transfer\nparts of the UI as soon as they are updated, when using partial frame\nbuffers.\nThe display will show the received updates on its glass after at most 16 ms (for\n60 fps displays) because the display needs to be refreshed regularly.\nBecause of this, the first updates to the display can potentially be\nvisible to the user before all updates have been transferred."),(0,r.kt)("p",null,"If the total sequence of draw operations and transfers take a long\ntime to complete ( > 16 ms) it is highly possible that the user will see a\ncombination of the previous frame and some of the new updates. This is\ncalled display tearing and is not desirable.\nFor this reason, partial frame buffers are not suitable for\napplications that make use of complex animations that take a long time\nto render."),(0,r.kt)("h2",p({},{id:"display-update-example"}),"Display Update Example"),(0,r.kt)("p",null,"Before we get into how to configure partial frame buffers in your application let's have a look at a concrete example showing a digital clock with a moving circle arc representing seconds. The green circle arc is moving 6 degrees each second and does a full rotation in a minute. The UI is built from four Widgets as seen in the image below:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",p({parentName:"li"},{href:"../ui-development/ui-components/shapes/line"}),"Line")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",p({parentName:"li"},{href:"../ui-development/ui-components/shapes/circle"}),"Circle")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",p({parentName:"li"},{href:"../ui-development/ui-components/miscellaneous/digital-clock"}),"Digital Clock")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",p({parentName:"li"},{href:"../ui-development/ui-components/shapes/box"}),"Box"))),(0,r.kt)(n.Z,{imageSource:"/img/development/ui-development/scenarios/lowering-memory-usage-with-partial-framebuffer/touchgfx-designer-with-widgets-4.17.webp",mdxType:"Figure"}),(0,r.kt)("p",null,"Here is the code that updates the digital clock and circle arc:"),(0,r.kt)(l.Z,{mdxType:"CodeHeader"},"MainView.cpp"),(0,r.kt)("pre",null,(0,r.kt)("code",p({parentName:"pre"},{className:"language-cpp",metastring:"{21-25}","{21-25}":!0}),"void MainView::handleTickEvent()\n{\n  ticks++;\n  if (ticks == 10)\n  {\n      ticks = 0;\n      secs += 1;\n      if (secs == 60)  //increment minutes\n      {\n        secs = 0;\n        min += 1;\n        if (min == 60) //increment hours\n        {\n          min = 0;\n          hour += 1;\n          if (hour == 24)\n          {\n            hour = 0;\n          }\n        }\n        //Only update digital clock when minutes or hours change\n        digitalClock.setTime24Hour(hour, min, secs);\n      }\n    //Always update seconds\n    circleSeconds.updateArc(secs*6 - 20, secs*6);\n  }\n}\n")),(0,r.kt)("p",null,"The following images shows the areas that are updated in the first few\nseconds when the circle arc approaches the top and digital clock is\nupdated (the grey rectangles). In the first two frames, only the\nseconds are changing (58 and 59 seconds). In the third the seconds\nreaches 60 and the hour and minutes text is updated:"),(0,r.kt)(n.Z,{imageSource:"/img/development/ui-development/scenarios/lowering-memory-usage-with-partial-framebuffer/simulator-updated-areas-1.webp",mdxType:"Figure"}),(0,r.kt)(n.Z,{imageSource:"/img/development/ui-development/scenarios/lowering-memory-usage-with-partial-framebuffer/simulator-updated-areas-2.webp",mdxType:"Figure"}),(0,r.kt)(n.Z,{imageSource:"/img/development/ui-development/scenarios/lowering-memory-usage-with-partial-framebuffer/simulator-updated-areas-3.webp",mdxType:"Figure"}),(0,r.kt)(n.Z,{imageSource:"/img/development/ui-development/scenarios/lowering-memory-usage-with-partial-framebuffer/simulator-updated-areas-4.webp",mdxType:"Figure"}),(0,r.kt)("p",null,"The rectangles updated in the third image above are 154 x 60 pixels,\n20 x 12 pixels, and 33 x 8 pixels. When using standard frame buffers\nthese three rectangles would be drawn into the full frame buffer\n(overwriting the previous pixels), which would afterwards be\ntransferred to the display. When using partial frame buffers, these\nthree rectangles would be drawn into their own little frame buffers\nwhich would then immediately be transferred to the display and shown."),(0,r.kt)("h2",p({},{id:"configuring-partial-frame-buffers"}),"Configuring Partial Frame Buffers"),(0,r.kt)("p",null,"The following steps are required for TouchGFX to use partial frame buffers:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Creating a frame buffer allocator object with a memory buffer"),(0,r.kt)("li",{parentName:"ol"},"Configuring TouchGFX HAL class to use that allocator"),(0,r.kt)("li",{parentName:"ol"},"Write code to transmit the buffers to the display")),(0,r.kt)("p",null,"Steps 1 and 2 are automatically generated by TouchGFX Generator through STM32CubeMX while step 3 is a proprietary driver to transfer pixels to the display."),(0,r.kt)(o.Z,{mdxType:"FurtherReading"},"Read the TouchGFX Generator ",(0,r.kt)(s.Z,{to:"../../development/touchgfx-hal-development/generator-how-to/touchgfx-al-configuration/display##buffering-strategies",mdxType:"Link"},"User Guide")," for information about how to configure partial frame buffers."),(0,r.kt)("p",null,"An example configuration with 3 partial framebuffer block of size 1920bytes\nused to draw the updates areas from the above section is shown below."),(0,r.kt)("p",null,"Lets first see the position and size of the two frame buffers\nallocated to draw the small circle updates (second image above) (assuming 24Bpp):"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",p({parentName:"tr"},{align:null}),(0,r.kt)("strong",{parentName:"th"},"Rectangle")),(0,r.kt)("th",p({parentName:"tr"},{align:null}),(0,r.kt)("strong",{parentName:"th"},"x")),(0,r.kt)("th",p({parentName:"tr"},{align:null}),(0,r.kt)("strong",{parentName:"th"},"y")),(0,r.kt)("th",p({parentName:"tr"},{align:null}),(0,r.kt)("strong",{parentName:"th"},"width")),(0,r.kt)("th",p({parentName:"tr"},{align:null}),(0,r.kt)("strong",{parentName:"th"},"height")),(0,r.kt)("th",p({parentName:"tr"},{align:null}),(0,r.kt)("strong",{parentName:"th"},"Pixels")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",p({parentName:"tr"},{align:null}),"Rectangle 1"),(0,r.kt)("td",p({parentName:"tr"},{align:null}),"112"),(0,r.kt)("td",p({parentName:"tr"},{align:null}),"56"),(0,r.kt)("td",p({parentName:"tr"},{align:null}),"22"),(0,r.kt)("td",p({parentName:"tr"},{align:null}),"14"),(0,r.kt)("td",p({parentName:"tr"},{align:null}),"308 pixels = 924 bytes")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",p({parentName:"tr"},{align:null}),"Rectangle 2"),(0,r.kt)("td",p({parentName:"tr"},{align:null}),"153"),(0,r.kt)("td",p({parentName:"tr"},{align:null}),"42"),(0,r.kt)("td",p({parentName:"tr"},{align:null}),"29"),(0,r.kt)("td",p({parentName:"tr"},{align:null}),"11"),(0,r.kt)("td",p({parentName:"tr"},{align:null}),"319 pixels = 957 bytes")))),(0,r.kt)("p",null,"Both these rectangles are so small, they can fit into the blocks allocated by the frame buffer allocator."),(0,r.kt)("p",null,"In the third image above, we have 3 updated rectangles: The small\nupdates to the circle, and the larger rectangle covering the text:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",p({parentName:"tr"},{align:null}),(0,r.kt)("strong",{parentName:"th"},"Rectangle")),(0,r.kt)("th",p({parentName:"tr"},{align:null}),(0,r.kt)("strong",{parentName:"th"},"x")),(0,r.kt)("th",p({parentName:"tr"},{align:null}),(0,r.kt)("strong",{parentName:"th"},"y")),(0,r.kt)("th",p({parentName:"tr"},{align:null}),(0,r.kt)("strong",{parentName:"th"},"width")),(0,r.kt)("th",p({parentName:"tr"},{align:null}),(0,r.kt)("strong",{parentName:"th"},"height")),(0,r.kt)("th",p({parentName:"tr"},{align:null}),(0,r.kt)("strong",{parentName:"th"},"Pixels")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",p({parentName:"tr"},{align:null}),"Rectangle 1"),(0,r.kt)("td",p({parentName:"tr"},{align:null}),"126"),(0,r.kt)("td",p({parentName:"tr"},{align:null}),"51"),(0,r.kt)("td",p({parentName:"tr"},{align:null}),"20"),(0,r.kt)("td",p({parentName:"tr"},{align:null}),"12"),(0,r.kt)("td",p({parentName:"tr"},{align:null}),"240 pixels = 720 bytes")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",p({parentName:"tr"},{align:null}),"Rectangle 2"),(0,r.kt)("td",p({parentName:"tr"},{align:null}),"165"),(0,r.kt)("td",p({parentName:"tr"},{align:null}),"42"),(0,r.kt)("td",p({parentName:"tr"},{align:null}),"33"),(0,r.kt)("td",p({parentName:"tr"},{align:null}),"8"),(0,r.kt)("td",p({parentName:"tr"},{align:null}),"264 pixels = 792 bytes")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",p({parentName:"tr"},{align:null}),"Rectangle 3"),(0,r.kt)("td",p({parentName:"tr"},{align:null}),"118"),(0,r.kt)("td",p({parentName:"tr"},{align:null}),"165"),(0,r.kt)("td",p({parentName:"tr"},{align:null}),"154"),(0,r.kt)("td",p({parentName:"tr"},{align:null}),"60"),(0,r.kt)("td",p({parentName:"tr"},{align:null}),"9,240 pixels = 27,720 bytes")))),(0,r.kt)("p",null,"Again, the rectangle 1 and 2 are so small, they can fit into the\nblocks allocated by the frame buffer allocator, but frame buffer 3 is\ntoo large.\nThis rectangle is to large and will be split into multiple rectangles\nthat each can fit into the frame buffers (11,700 bytes)."),(0,r.kt)("p",null,"Here the third rectangle to be updated is too big and will not fit into the last third block. In this situation TouchGFX will wait for the first blocks to be transferred and then reuse the blocks."),(0,r.kt)("h2",p({},{id:"transferring-frame-buffers-to-the-screen"}),"Transferring Frame Buffers to the Screen"),(0,r.kt)("p",null,"The implementation of the code to transfer partial framebuffer blocks to\nthe display depends on the display interface use. For examples on how\nthis can be done, see the following articles:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",p({parentName:"li"},{href:"../touchgfx-hal-development/scenarios/scenarios-fmc"}),"FMC Display Interface")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",p({parentName:"li"},{href:"../touchgfx-hal-development/scenarios/scenarios-spi"}),"SPI Display Interface")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",p({parentName:"li"},{href:"../touchgfx-hal-development/scenarios/scenarios-dsi-command-mode"}),"MIPI-DSI Command Mode"))),(0,r.kt)("h2",p({},{id:"conclusion"}),"Conclusion"),(0,r.kt)("p",null,"In this article we saw how the partial frame buffer strategy can help\nlowering the memory requirements for platforms that have displays with\nintegrated frame buffer memory."))}y.isMDXComponent=!0}}]);