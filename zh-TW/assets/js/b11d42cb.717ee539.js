"use strict";(self.webpackChunktouchgfx_documentation=self.webpackChunktouchgfx_documentation||[]).push([[52153],{49613:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var a=n(59496);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),u=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=u(e.components);return a.createElement(s.Provider,{value:t},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,l=e.originalType,s=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),d=u(n),h=i,m=d["".concat(s,".").concat(h)]||d[h]||p[h]||l;return n?a.createElement(m,r(r({ref:t},c),{},{components:n})):a.createElement(m,r({ref:t},c))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var l=n.length,r=new Array(l);r[0]=h;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[d]="string"==typeof e?e:i,r[1]=o;for(var u=2;u<l;u++)r[u]=n[u];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},22586:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/files/touchgfx-tutorial-07-50d3980f90c8b817c6d9461e7ecfd0d2.zip"},74693:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>g,contentTitle:()=>h,default:()=>w,frontMatter:()=>p,metadata:()=>m,toc:()=>k});n(59496);var a=n(49613),i=n(18399),l=n(89639),r=n(12963),o=n(21100),s=n(48753),u=n(28128);function c(){return c=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},c.apply(this,arguments)}function d(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}const p={id:"tutorial-07",title:"Tutorial 7: Creating an Application for TSD knob display"},h=void 0,m={unversionedId:"tutorials/tutorial-07",id:"tutorials/tutorial-07",title:"Tutorial 7: Creating an Application for TSD knob display",description:"In this tutorial, we will create and load an application for the TSD TSS013004A-AD display knob module. This is a graphics entry-level 1.3\u201d round display module based on STM32C091 + 8 MB external flash, running partial framebuffer. The application will have a simple GUI and show how to use the interfaces of the display module (physical controls, ambient light, and UART communication). The MCU platform in the TSD TSS013004A-AD display knob module has the following specifications:",source:"@site/i18n/zh-TW/docusaurus-plugin-content-docs-academy/current/tutorials/tutorial-07.mdx",sourceDirName:"tutorials",slug:"/tutorials/tutorial-07",permalink:"/4.25/zh-TW/academy/tutorials/tutorial-07",draft:!1,tags:[],version:"current",frontMatter:{id:"tutorial-07",title:"Tutorial 7: Creating an Application for TSD knob display"},sidebar:"academy",previous:{title:"\u7b2c\u4e8c\u90e8\u5206\uff1aTextArea\u5916\u89c0\u53ca\u842c\u7528\u5b57\u5143",permalink:"/4.25/zh-TW/academy/tutorials/tutorial-06/tutorial-06-part-2"},next:{title:"\u5982\u4f55\u4f7f\u7528TouchGFX\u5f71\u7247",permalink:"/4.25/zh-TW/academy/how-to/how-to-introduction"}},g={},k=[{value:"Step 1: Starting a TouchGFX Project",id:"step-1-starting-a-touchgfx-project",level:2},{value:"Step 2: Building a Basic GUI",id:"step-2-building-a-basic-gui",level:2},{value:"Step 3: Programming the Application to the Display",id:"step-3-programming-the-application-to-the-display",level:2},{value:"Programming using UART",id:"programming-using-uart",level:3},{value:"Programming using external ST-LINK",id:"programming-using-external-st-link",level:3},{value:"Step 4: Add Interactions to Physical Inputs",id:"step-4-add-interactions-to-physical-inputs",level:2},{value:"Step 5: Control the LED Ambient Light",id:"step-5-control-the-led-ambient-light",level:2},{value:"Step 6: Send Data on UART",id:"step-6-send-data-on-uart",level:2},{value:"Step 7: Receive Data from UART",id:"step-7-receive-data-from-uart",level:2}],b={toc:k},f="wrapper";function w(e){var{components:t}=e,p=d(e,["components"]);return(0,a.kt)(f,c({},b,p,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"In this tutorial, we will create and load an application for the TSD TSS013004A-AD display knob module. This is a graphics entry-level 1.3\u201d round display module based on STM32C091 + 8 MB external flash, running partial framebuffer. The application will have a simple GUI and show how to use the interfaces of the display module (physical controls, ambient light, and UART communication). The MCU platform in the TSD TSS013004A-AD display knob module has the following specifications:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"48 MHz CPU (STM32C091)"),(0,a.kt)("li",{parentName:"ul"},"36 kB internal SRAM"),(0,a.kt)("li",{parentName:"ul"},"256 kB internal flash"),(0,a.kt)("li",{parentName:"ul"},"8 MB external serial flash"),(0,a.kt)("li",{parentName:"ul"},"24 MHz SPI display interface")),(0,a.kt)("p",null,"To follow this tutorial, ",(0,a.kt)(i.Z,{to:"tutorial-01",mdxType:"Link"},"Tutorial 1")," and ",(0,a.kt)(i.Z,{to:"tutorial-02",mdxType:"Link"},"Tutorial 2")," are recommended prerequisites."),(0,a.kt)("h2",c({},{id:"step-1-starting-a-touchgfx-project"}),"Step 1: Starting a TouchGFX Project"),(0,a.kt)("p",null,"In TouchGFX Designer, an application template (TBS) is provided for the display module, which sets up all the basic functionality. Create a new project based on this:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},'Under the "Create" tab, select the board called "TSDHD TSS013-1".'),(0,a.kt)("li",{parentName:"ol"},'Set the "Application Name" to e.g. "KnobApplication".'),(0,a.kt)("li",{parentName:"ol"},'Click "Create".',(0,a.kt)(r.Z,{points:[[5,10],[435,184],[460,285]],imageSource:"/img/academy/tutorials/tutorial-07/create-project.png",mdxType:"FigureWithPoints"},"Creating a project for the display module"))),(0,a.kt)("h2",c({},{id:"step-2-building-a-basic-gui"}),"Step 2: Building a Basic GUI"),(0,a.kt)("p",null,"After creating the project, we have a blank 240 x 240 pixels canvas. In this step, we will design the GUI for our application. It will have a single screen (Screen1) looking like this:"),(0,a.kt)(l.Z,{imageSource:"/img/academy/tutorials/tutorial-07/basic-gui.png",mdxType:"Figure"},"Screenshot of the GUI built in this tutorial"),(0,a.kt)("p",null,"The image assets for this can be downloaded from this ",(0,a.kt)("a",{target:"_blank",href:n(22586).Z},"link"),". Unzip the file to the ",(0,a.kt)("inlineCode",{parentName:"p"},"TouchGFX/assets/images")," folder in your project. To create the GUI, add and configure widgets in TouchGFX Designer according to this table:"),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",c({parentName:"tr"},{align:null}),"Order"),(0,a.kt)("th",c({parentName:"tr"},{align:null}),"Widget"),(0,a.kt)("th",c({parentName:"tr"},{align:null}),"Name"),(0,a.kt)("th",c({parentName:"tr"},{align:null}),"Properties"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",c({parentName:"tr"},{align:null}),"1"),(0,a.kt)("td",c({parentName:"tr"},{align:null}),"Image"),(0,a.kt)("td",c({parentName:"tr"},{align:null}),"backgroundImage"),(0,a.kt)("td",c({parentName:"tr"},{align:null}),(0,a.kt)("ul",null,(0,a.kt)("li",null,"X: 0"),(0,a.kt)("li",null,"Y: 0"),(0,a.kt)("li",null,"Image: meteor_rain.png")))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",c({parentName:"tr"},{align:null}),"2"),(0,a.kt)("td",c({parentName:"tr"},{align:null}),"CircleProgress"),(0,a.kt)("td",c({parentName:"tr"},{align:null}),"valueCircleProgress"),(0,a.kt)("td",c({parentName:"tr"},{align:null}),(0,a.kt)("ul",null,(0,a.kt)("li",null,"X: 25"),(0,a.kt)("li",null,"Y: 25"),(0,a.kt)("li",null,'Preset: "Action Large" (from "Alternate Theme")')))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",c({parentName:"tr"},{align:null}),"3"),(0,a.kt)("td",c({parentName:"tr"},{align:null}),"Image"),(0,a.kt)("td",c({parentName:"tr"},{align:null}),"wifiImage"),(0,a.kt)("td",c({parentName:"tr"},{align:null}),(0,a.kt)("ul",null,(0,a.kt)("li",null,"X: 90"),(0,a.kt)("li",null,"Y: 155"),(0,a.kt)("li",null,"Image: wifi.png")))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",c({parentName:"tr"},{align:null}),"4"),(0,a.kt)("td",c({parentName:"tr"},{align:null}),"Image"),(0,a.kt)("td",c({parentName:"tr"},{align:null}),"alarmImage"),(0,a.kt)("td",c({parentName:"tr"},{align:null}),(0,a.kt)("ul",null,(0,a.kt)("li",null,"X: 120"),(0,a.kt)("li",null,"Y: 155"),(0,a.kt)("li",null,"Image: alarm.png")))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",c({parentName:"tr"},{align:null}),"5"),(0,a.kt)("td",c({parentName:"tr"},{align:null}),"Image"),(0,a.kt)("td",c({parentName:"tr"},{align:null}),"unlockedImage"),(0,a.kt)("td",c({parentName:"tr"},{align:null}),(0,a.kt)("ul",null,(0,a.kt)("li",null,"X: 85"),(0,a.kt)("li",null,"Y: 85"),(0,a.kt)("li",null,"Image: lock_open.png")))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",c({parentName:"tr"},{align:null}),"6"),(0,a.kt)("td",c({parentName:"tr"},{align:null}),"Image"),(0,a.kt)("td",c({parentName:"tr"},{align:null}),"lockedImage"),(0,a.kt)("td",c({parentName:"tr"},{align:null}),(0,a.kt)("ul",null,(0,a.kt)("li",null,"X: 85"),(0,a.kt)("li",null,"Y: 85"),(0,a.kt)("li",null,"Image: lock.png")))))),(0,a.kt)("h2",c({},{id:"step-3-programming-the-application-to-the-display"}),"Step 3: Programming the Application to the Display"),(0,a.kt)("p",null,"Now we will program the preliminary application to the display module to see the GUI on the display. All Discovery Kits and NUCLEO boards made by STMicroelectronics have ST-LINK hardware on board, which is normally used to program applications to these. This third-party display module does not have a built-in ST-LINK. Instead, it can be programmed using the following two alternative methods."),(0,a.kt)("h3",c({},{id:"programming-using-uart"}),"Programming using UART"),(0,a.kt)("p",null,'The display module adapter board has a USB-to-UART chip, which enables communication between the PC and the MCU inside the display module. It is also possible to program the display module this way, utilizing the UART interface of the MCU bootloader. This is the method used by the makefile in this project, when clicking "Run target" in TouchGFX Designer. For the "Run target" script in this project to work, it has the following requirements:'),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Display module is connected to the PC through a data USB cable."),(0,a.kt)("li",{parentName:"ul"},"STM32CubeProgrammer (v2.18.0 or later) is installed in the default location."),(0,a.kt)("li",{parentName:"ul"},"Driver for the USB-to-UART is installed. Can be downloaded here: ",(0,a.kt)(i.Z,{to:"https://www.wch-ic.com/downloads/ch341ser_exe.html",mdxType:"Link"},(0,a.kt)("a",c({parentName:"li"},{href:"https://www.wch-ic.com/downloads/ch341ser_exe.html"}),"https://www.wch-ic.com/downloads/ch341ser_exe.html")),"."),(0,a.kt)("li",{parentName:"ul"},"The nBOOT_SEL option byte in the MCU must be set to FALSE. This is default in the delivered modules.")),(0,a.kt)("p",null,'After clicking "Run target" and waiting for the compilation and programming to complete, the GUI from Designer canvas should be visible on the module display.'),(0,a.kt)(o.Z,{mdxType:"Tip"},'After programming the entire application once, it is now possible to use "Run target - Internal" for the rest of the tutorial. This will save programming time because it only reprograms the application code in internal flash and skips the assets in external flash. This works as long as the assets are unchanged.'),(0,a.kt)(s.Z,{mdxType:"FurtherReading"},"The process of programming the internal and external flash through UART is actually a quite comprehensive task. This is however all handled by the ruby script included in the project: ",(0,a.kt)("b",null,"Loading/Load_OpenBootloader.rb"),". This script does the programming in the following steps:",(0,a.kt)("ol",null,(0,a.kt)("li",null,"Reboot the MCU into the built-in bootloader by pulsing RESET and BOOT0 pin on the MCU."),(0,a.kt)("li",null,"Program a custom bootloader to MCU RAM (based on ST OpenBootloader) and execute it, to be able to program external flash."),(0,a.kt)("li",null,"Program the TouchGFX application to the internal flash of the MCU and the external flash."),(0,a.kt)("li",null,"Reboot the MCU into the TouchGFX application by pulsing RESET pin on the MCU."))),(0,a.kt)("h3",c({},{id:"programming-using-external-st-link"}),"Programming using external ST-LINK"),(0,a.kt)("p",null,"Another way to program the module is by using an external debugger with wire connections to the pins on the display module adapter board. When using an ST-LINK/V2 debugger it needs wire connections like shown in the table below."),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",c({parentName:"tr"},{align:null}),"ST-LINK/V2, 20-pin connector"),(0,a.kt)("th",c({parentName:"tr"},{align:null}),"Knob adapter board"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",c({parentName:"tr"},{align:null}),"1"),(0,a.kt)("td",c({parentName:"tr"},{align:null}),"5V")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",c({parentName:"tr"},{align:null}),"4"),(0,a.kt)("td",c({parentName:"tr"},{align:null}),"GND")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",c({parentName:"tr"},{align:null}),"7"),(0,a.kt)("td",c({parentName:"tr"},{align:null}),"SWD")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",c({parentName:"tr"},{align:null}),"9"),(0,a.kt)("td",c({parentName:"tr"},{align:null}),"SWC")))),(0,a.kt)("p",null,"To be able to also load the external flash using ST-LINK and STM32CubeProgrammer, an External Loader file is provided in the project in ",(0,a.kt)("inlineCode",{parentName:"p"},"Loading/TSDHD-TSS013-1.stldr"),". One advantage of using an ST-LINK is that it besides programming also enables debugging of the running application, e.g. using STM32CubeIDE."),(0,a.kt)("p",null,"An external ST-LINK is not required to follow this tutorial."),(0,a.kt)("h2",c({},{id:"step-4-add-interactions-to-physical-inputs"}),"Step 4: Add Interactions to Physical Inputs"),(0,a.kt)("p",null,"The display knob module has three physical user input mechanisms: turn left, turn right, and press. In this step, we will make the GUI change the value of the CircleProgress when the knob is turned and toggle screen lock on/off when it is pressed."),(0,a.kt)("p",null,"The code in ",(0,a.kt)("inlineCode",{parentName:"p"},"TouchGFX/target/KeySampler.cpp"),' reads the hardware inputs and maps them to different key IDs. These can be used to trigger "Hardware button" interactions in TouchGFX Designer as shown below.'),(0,a.kt)(l.Z,{imageSource:"/img/academy/tutorials/tutorial-07/physical-interactions.png",mdxType:"Figure"},"How to use hardware buttons as inputs in ToucHGFX Designer"),(0,a.kt)("p",null,"Add one interaction for each of the inputs according to the table below."),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",c({parentName:"tr"},{align:null}),"Interaction"),(0,a.kt)("th",c({parentName:"tr"},{align:null}),"Properties"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",c({parentName:"tr"},{align:null}),"Knob_Turn_Left"),(0,a.kt)("td",c({parentName:"tr"},{align:null}),(0,a.kt)("ul",null,(0,a.kt)("li",null,"Trigger: Hardware button is clicked"),(0,a.kt)("li",null,"Button key: 52"),(0,a.kt)("li",null,"Action: Call new virtual function"),(0,a.kt)("li",null,"Function Name: decrementValue")))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",c({parentName:"tr"},{align:null}),"Knob_Turn_Right"),(0,a.kt)("td",c({parentName:"tr"},{align:null}),(0,a.kt)("ul",null,(0,a.kt)("li",null,"Trigger: Hardware button is clicked"),(0,a.kt)("li",null,"Button key: 54"),(0,a.kt)("li",null,"Action: Call new virtual function"),(0,a.kt)("li",null,"Function Name: incrementValue")))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",c({parentName:"tr"},{align:null}),"Knob_Press"),(0,a.kt)("td",c({parentName:"tr"},{align:null}),(0,a.kt)("ul",null,(0,a.kt)("li",null,"Trigger: Hardware button is clicked"),(0,a.kt)("li",null,"Button key: 53"),(0,a.kt)("li",null,"Action: Call new virtual function"),(0,a.kt)("li",null,"Function Name: toggleLock")))))),(0,a.kt)("p",null,"After adding the interactions and generating code in TouchGFX Designer, code that calls the specified virtual functions is now generated in ",(0,a.kt)("inlineCode",{parentName:"p"},"TouchGFX/generated/gui_generated/src/screen1_screen/Screen1ViewBase.cpp"),". To implement our desired functionality we therefore need to add them (and a helper function) to our user code screen class header file:"),(0,a.kt)(u.Z,{mdxType:"CodeHeader"},"TouchGFX/gui/include/gui/screen1_screen/Screen1View.hpp"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-cpp"}),"public:\n...\n    virtual void toggleLock();\n    virtual void decrementValue();\n    virtual void incrementValue();\n    void changeValue(int change);\n")),(0,a.kt)("p",null,"And implement them in our user code screen class source file:"),(0,a.kt)(u.Z,{mdxType:"CodeHeader"},"TouchGFX/gui/src/screen1_screen/Screen1View.cpp"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-cpp"}),"void Screen1View::toggleLock()\n{\n    lockedImage.setVisible(!lockedImage.isVisible());\n    lockedImage.invalidate();\n}\n\nvoid Screen1View::decrementValue()\n{\n    if (!lockedImage.isVisible())\n    {\n        changeValue(-5);\n    }\n}\n\nvoid Screen1View::incrementValue()\n{\n    if (!lockedImage.isVisible())\n    {\n        changeValue(5);\n    }\n}\n\nvoid Screen1View::changeValue(int change)\n{\n    const int newValue = valueCircleProgress.getValue() + change;\n    valueCircleProgress.updateValue(newValue, 0);\n}\n")),(0,a.kt)("p",null,"The display module can now be programmed with the updated application. You can now press the knob to unlock the GUI and afterwards turn the knob to change the value of the CircleProgress."),(0,a.kt)(o.Z,{mdxType:"Tip"},"The chosen key IDs (52, 53 and 54) might seem arbitrary, but they are chosen because they correspond to the ASCII values for '4', '5' and '6'. This makes it possible to simulate the hardware inputs when running the simulator in TouchGFX Designer, as it converts keyboard presses to hardware button key triggers. It is thereby possible to control the GUI running in Simulator using keyboard keys 4, 5 and 6. Find more information about how to use the Simulator ",(0,a.kt)(i.Z,{to:"../../docs/development/ui-development/working-with-touchgfx/simulator",mdxType:"Link"},"here"),"."),(0,a.kt)("h2",c({},{id:"step-5-control-the-led-ambient-light"}),"Step 5: Control the LED Ambient Light"),(0,a.kt)("p",null,"The display knob module has a ring of red, green and blue LEDs which can be turned on for ambient light around it. Each color channel is controlled with a PWM capable output from the MCU. In the application template we are using, a function for controlling this light is implemented in ",(0,a.kt)("inlineCode",{parentName:"p"},"Core/Inc/knob_interface.cpp")," and avilable through ",(0,a.kt)("inlineCode",{parentName:"p"},"Core/Src/knob_interface.hpp"),":"),(0,a.kt)(u.Z,{mdxType:"CodeHeader"},"Core/Src/knob_interface.hpp"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-cpp",metastring:"{}","{}":!0}),"public:\n...\nvoid knobSetAmbientLightRGB(uint8_t red, uint8_t green, uint8_t blue);\n...\n")),(0,a.kt)("p",null,"In this demo, we will control the color of the light based on the value of the CircleProgress. We will do this such that the light is blue when the value is zero and gradually turning red through purple as the value increases. This can be done by adding the following code to Screen1View:"),(0,a.kt)(u.Z,{mdxType:"CodeHeader"},"TouchGFX/gui/src/screen1_screen/Screen1View.cpp"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-cpp",metastring:"{2-4,9,17-25}","{2-4,9,17-25}":!0}),'#include <gui/screen1_screen/Screen1View.hpp>\n#ifndef SIMULATOR\n#include "knob_interface.hpp"\n#endif\n\nvoid Screen1View::setupScreen()\n{\n    Screen1ViewBase::setupScreen();\n    changeValue(0); // Ensure that the system state is synchronized at start-up\n}\n\nvoid Screen1View::changeValue(int change)\n{\n    const int newValue = valueCircleProgress.getValue() + change;\n    valueCircleProgress.updateValue(newValue, 0);\n\n#ifndef SIMULATOR\n    const int value = valueCircleProgress.getValue(); // Always inside the range set in TouchGFX Designer (0-100)\n\n    //Update ambient light\n    const uint8_t red = (value * 255) / 100;\n    const uint8_t green = 0;\n    const uint8_t blue = 255 - red;\n    knobSetAmbientLightRGB(red, green, blue);\n#endif\n}\n')),(0,a.kt)("p",null,"When running the application on the display module, it will now activate the ambient light and change the color when the knob is unlocked and turned."),(0,a.kt)(o.Z,{mdxType:"Tip"},"The ",(0,a.kt)("b",null,"#ifndef SIMULATOR")," compile switch can be used to exclude hardware specific code when running the Simulator in TouchGFX Designer."),(0,a.kt)("h2",c({},{id:"step-6-send-data-on-uart"}),"Step 6: Send Data on UART"),(0,a.kt)("p",null,"The knob display module has a UART communication interface and 6 GPIOs (PA0-5) externally available through the connector cable. In this step, we will make the application transmit an ASCII string on the UART every time the value of the CircleProgress is updated. The UART interface is configured in the template project for the display module and available through ",(0,a.kt)("inlineCode",{parentName:"p"},"Core/Src/knob_interface.hpp"),":"),(0,a.kt)(u.Z,{mdxType:"CodeHeader"},"Core/Src/knob_interface.hpp"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-cpp",metastring:"{}","{}":!0}),"public:\n...\nvoid knobUartSendByte(uint8_t data);\nvoid knobUartSendBytes(uint8_t* data, uint16_t size);\nvoid knobUartSendString(uint8_t* data);\n...\n")),(0,a.kt)("p",null,"Here, we will use the ",(0,a.kt)("inlineCode",{parentName:"p"},"knobUartSendByte")," function multiple times to transmit the different ASCII characters of a string representing the value:"),(0,a.kt)(u.Z,{mdxType:"CodeHeader"},"TouchGFX/gui/src/screen1_screen/Screen1View.cpp"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-cpp",metastring:"{15-20}","{15-20}":!0}),"void Screen1View::changeValue(int change)\n{\n    const int newValue = valueCircleProgress.getValue() + change;\n    valueCircleProgress.updateValue(newValue, 0);\n\n#ifndef SIMULATOR\n    const int value = valueCircleProgress.getValue(); // Always inside the range set in TouchGFX Designer (0-100)\n\n    //Update ambient light\n    const uint8_t red = (value * 255) / 100;\n    const uint8_t green = 0;\n    const uint8_t blue = 255 - red;\n    knobSetAmbientLightRGB(red, green, blue);\n\n    // Send new value on UART\n    knobUartSendByte('0' + value / 100);\n    knobUartSendByte('0' + (value % 100) / 10);\n    knobUartSendByte('0' + value % 10);\n    knobUartSendByte('\\r');\n    knobUartSendByte('\\n');\n#endif\n}\n")),(0,a.kt)("p",null,'When running the application on the display module, it will now transmit data on the UART when the knob is unlocked and turned. This UART data can be received on the PC through the same interface as used for UART programming. To do so, we need a "Terminal application" installed on the PC, e.g. Tera Term or PuTTY. Here is the needed interface configuration done in Tera Term as example:'),(0,a.kt)(l.Z,{imageSource:"/img/academy/tutorials/tutorial-07/terminal-setup.png",mdxType:"Figure"},"Screenshot of the interface configuration in Tera Term. Note that the COM Port will vary and should be selected to match your setup."),(0,a.kt)("p",null,"After connecting the terminal application on the PC, it should now start receiving and showing the value strings when the knob is turned:"),(0,a.kt)(l.Z,{imageSource:"/img/academy/tutorials/tutorial-07/terminal-reception.png",mdxType:"Figure"},"Screenshot of the value strings received in Tera Term"),(0,a.kt)("h2",c({},{id:"step-7-receive-data-from-uart"}),"Step 7: Receive Data from UART"),(0,a.kt)("p",null,"In this step, we will make the application react when receiving UART commands from the PC, according to this simple protocol:"),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",c({parentName:"tr"},{align:null}),"Command"),(0,a.kt)("th",c({parentName:"tr"},{align:null}),"Action"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",c({parentName:"tr"},{align:null}),"'q'"),(0,a.kt)("td",c({parentName:"tr"},{align:null}),"Hide wifi icon")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",c({parentName:"tr"},{align:null}),"'w'"),(0,a.kt)("td",c({parentName:"tr"},{align:null}),"Show wifi icon")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",c({parentName:"tr"},{align:null}),"'e'"),(0,a.kt)("td",c({parentName:"tr"},{align:null}),"Hide alarm icon")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",c({parentName:"tr"},{align:null}),"'r'"),(0,a.kt)("td",c({parentName:"tr"},{align:null}),"Show alarm icon")))),(0,a.kt)("p",null,"There is a function for receiving UART data available in the project template in ",(0,a.kt)("inlineCode",{parentName:"p"},"Core/Src/knob_interface.hpp"),":"),(0,a.kt)(u.Z,{mdxType:"CodeHeader"},"Core/Src/knob_interface.hpp"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-cpp",metastring:"{}","{}":!0}),"public:\n...\nuint8_t knobUartReceiveByte(uint8_t* data);\n...\n")),(0,a.kt)("p",null,"This function will return ",(0,a.kt)("strong",{parentName:"p"},"true"),", when new data has been received and copy the actual byte to the given pointer. We will use this function to poll the UART receive buffer in every tick of the ToucHGFX application. To do so, we first need to add a TouchGFX interaction to call a method every tick:"),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",c({parentName:"tr"},{align:null}),"Interaction"),(0,a.kt)("th",c({parentName:"tr"},{align:null}),"Properties"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",c({parentName:"tr"},{align:null}),"Poll UART communication"),(0,a.kt)("td",c({parentName:"tr"},{align:null}),(0,a.kt)("ul",null,(0,a.kt)("li",null,"Trigger: On every N tick"),(0,a.kt)("li",null,"Tick count: 1"),(0,a.kt)("li",null,"Action: Call new virtual function"),(0,a.kt)("li",null,"Function Name: receiveUartCommand")))))),(0,a.kt)("p",null,"We now add the following code to read the UART and implement the above protocol:"),(0,a.kt)(u.Z,{mdxType:"CodeHeader"},"TouchGFX/gui/include/gui/screen1_screen/Screen1View.hpp"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-cpp",metastring:"{7}","{7}":!0}),"public:\n...\n    virtual void toggleLock();\n    virtual void decrementValue();\n    virtual void incrementValue();\n    void changeValue(int change);\n    virtual void receiveUartCommand();\n")),(0,a.kt)(u.Z,{mdxType:"CodeHeader"},"TouchGFX/gui/src/screen1_screen/Screen1View.cpp"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-cpp"}),"void Screen1View::receiveUartCommand()\n{\n#ifndef SIMULATOR\n    uint8_t data;\n    if (knobUartReceiveByte(&data))\n    {\n        switch (data)\n        {\n        case 'q':\n            wifiImage.setVisible(false);\n            wifiImage.invalidate();\n            break;\n        case 'w':\n            wifiImage.setVisible(true);\n            wifiImage.invalidate();\n            break;\n        case 'e':\n            alarmImage.setVisible(false);\n            alarmImage.invalidate();\n            break;\n        case 'r':\n            alarmImage.setVisible(true);\n            alarmImage.invalidate();\n            break;\n        }\n    }\n#endif\n}\n")),(0,a.kt)("p",null,"When running the updated application, it is now possible to hide and show the two icons on the display according to the protocol in the table above. This can be tested with the same terminal program used in the previous step. Here, the commands can simply be sent by selecting the window of the connected terminal program and clicking the q, w, e, and r key on the keyboard."),(0,a.kt)("p",null,"This step concludes Tutorial 7."),(0,a.kt)(o.Z,{mdxType:"Tip"},"In the example application we have built in this tutorial, we have put the UART and LED control directly in the View code. In most applications, it can however be recommended to handle all the hardware control in the Model class using the pattern Model-View-Presenter described ",(0,a.kt)(i.Z,{to:"../../docs/development/ui-development/software-architecture/model-view-presenter-design-pattern",mdxType:"Link"},"here"),"."),(0,a.kt)(s.Z,{mdxType:"FurtherReading"},'To learn more about the concepts covered in this tutorial, one suggestion is to take a look at the "Knob Demo" available in TouchGFX Designer. This demo is designed for the same display knob module and uses the same mechanisms, but in a much more comprehensive GUI application.'))}w.isMDXComponent=!0},28128:(e,t,n)=>{n.d(t,{Z:()=>l});var a=n(59496);class i extends a.Component{render(){return a.createElement("div",{className:"code-header"},a.createElement("div",null,a.createElement("h5",null,this.props.children)))}}const l=i},89639:(e,t,n)=>{n.d(t,{Z:()=>l});var a=n(59496),i=n(97395);const l=function(e){const t=e.noShadow||!1,n=e.width,l=e.height,r=(0,i.Z)(e.imageSource);return t?a.createElement("div",{className:"figure noshadow"},a.createElement("a",{href:r,target:"_blank"},a.createElement("img",{width:n,height:l,src:r})),a.createElement("p",null,e.children)):a.createElement("div",{className:"figure"},a.createElement("a",{href:r,target:"_blank"},a.createElement("img",{width:n,height:l,src:r})),a.createElement("p",null,e.children))}},12963:(e,t,n)=>{n.d(t,{Z:()=>l});var a=n(59496),i=n(97395);const l=function(e){const t=e.width,n=e.height,l=e.points||[],r=(0,i.Z)(e.imageSource);return a.createElement("div",{style:{position:"relative"}},a.createElement("div",{className:"figure"},a.createElement("a",{href:r,target:"_blank"},a.createElement("img",{width:t,height:n,src:r})),l.map((function(e,t){return a.createElement("svg",{style:{position:"absolute",top:0,left:0,pointerEvents:"none"},viewBox:"0 0 500 500"},a.createElement("g",{transform:"translate("+e[0]+", "+e[1]+")"},a.createElement("path",{id:"p1",d:"M12 2c3.196 0 6 2.618 6 5.602 0 2.238-1.058 3.488-2.659 5.381-1.078 1.274-2.303 2.722-3.341 4.697-1.038-1.976-2.263-3.423-3.341-4.697-1.601-1.893-2.659-3.143-2.659-5.381 0-2.984 2.804-5.602 6-5.602z",fill:"white",stroke:"black"}),a.createElement("text",{x:"11.7",y:"9.5","font-size":"x-small","dominant-baseline":"middle","text-anchor":"middle"},t+1)))})),a.createElement("p",null,e.children)))}},48753:(e,t,n)=>{n.d(t,{Z:()=>o});var a=n(59496),i=n(96151);const l=a.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},a.createElement("path",{fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}));class r extends a.Component{render(){return a.createElement(i.Z,{color:"var(--highlight-color-further-reading)",header:"Further reading",type:"further-reading",icon:l},this.props.children)}}const o=r},96151:(e,t,n)=>{n.d(t,{Z:()=>l});var a=n(59496);class i extends a.Component{render(){const e=`highlight highlight-${this.props.type}`;return a.createElement("div",{className:e},a.createElement("div",{className:"highlight-heading"},a.createElement("h5",null,a.createElement("div",{className:"highlight-icon"},this.props.icon),this.props.header)),a.createElement("div",{className:"highlight-content"},this.props.children))}}const l=i},21100:(e,t,n)=>{n.d(t,{Z:()=>o});var a=n(59496),i=n(96151);const l=a.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},a.createElement("path",{fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}));class r extends a.Component{render(){return a.createElement(i.Z,{color:"var(--highlight-color-tip)",header:"Tip",type:"tip",icon:l},this.props.children)}}const o=r}}]);