"use strict";(self.webpackChunktouchgfx_documentation=self.webpackChunktouchgfx_documentation||[]).push([[69813],{49613:(t,e,a)=>{a.d(e,{Zo:()=>m,kt:()=>h});var n=a(59496);function r(t,e,a){return e in t?Object.defineProperty(t,e,{value:a,enumerable:!0,configurable:!0,writable:!0}):t[e]=a,t}function l(t,e){var a=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),a.push.apply(a,n)}return a}function i(t){for(var e=1;e<arguments.length;e++){var a=null!=arguments[e]?arguments[e]:{};e%2?l(Object(a),!0).forEach((function(e){r(t,e,a[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(a,e))}))}return t}function o(t,e){if(null==t)return{};var a,n,r=function(t,e){if(null==t)return{};var a,n,r={},l=Object.keys(t);for(n=0;n<l.length;n++)a=l[n],e.indexOf(a)>=0||(r[a]=t[a]);return r}(t,e);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(t);for(n=0;n<l.length;n++)a=l[n],e.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(t,a)&&(r[a]=t[a])}return r}var s=n.createContext({}),p=function(t){var e=n.useContext(s),a=e;return t&&(a="function"==typeof t?t(e):i(i({},e),t)),a},m=function(t){var e=p(t.components);return n.createElement(s.Provider,{value:e},t.children)},c="mdxType",d={inlineCode:"code",wrapper:function(t){var e=t.children;return n.createElement(n.Fragment,{},e)}},u=n.forwardRef((function(t,e){var a=t.components,r=t.mdxType,l=t.originalType,s=t.parentName,m=o(t,["components","mdxType","originalType","parentName"]),c=p(a),u=r,h=c["".concat(s,".").concat(u)]||c[u]||d[u]||l;return a?n.createElement(h,i(i({ref:e},m),{},{components:a})):n.createElement(h,i({ref:e},m))}));function h(t,e){var a=arguments,r=e&&e.mdxType;if("string"==typeof t||r){var l=a.length,i=new Array(l);i[0]=u;var o={};for(var s in e)hasOwnProperty.call(e,s)&&(o[s]=e[s]);o.originalType=t,o[c]="string"==typeof t?t:r,i[1]=o;for(var p=2;p<l;p++)i[p]=a[p];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},89639:(t,e,a)=>{a.d(e,{Z:()=>l});var n=a(59496),r=a(7029);const l=function(t){const e=t.noShadow||!1,a=t.width,l=t.height,i=(0,r.Z)(t.imageSource);return e?n.createElement("div",{className:"figure noshadow"},n.createElement("a",{href:i,target:"_blank"},n.createElement("img",{width:a,height:l,src:i})),n.createElement("p",null,t.children)):n.createElement("div",{className:"figure"},n.createElement("a",{href:i,target:"_blank"},n.createElement("img",{width:a,height:l,src:i})),n.createElement("p",null,t.children))}},48753:(t,e,a)=>{a.d(e,{Z:()=>o});var n=a(59496),r=a(96151);const l=n.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},n.createElement("path",{fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}));class i extends n.Component{render(){return n.createElement(r.Z,{color:"var(--highlight-color-further-reading)",header:"Further reading",type:"further-reading",icon:l},this.props.children)}}const o=i},96151:(t,e,a)=>{a.d(e,{Z:()=>l});var n=a(59496);class r extends n.Component{render(){const t=`highlight highlight-${this.props.type}`;return n.createElement("div",{className:t},n.createElement("div",{className:"highlight-heading"},n.createElement("h5",null,n.createElement("div",{className:"highlight-icon"},this.props.icon),this.props.header)),n.createElement("div",{className:"highlight-content"},this.props.children))}}const l=r},71632:(t,e,a)=>{a.r(e),a.d(e,{assets:()=>c,contentTitle:()=>p,default:()=>g,frontMatter:()=>s,metadata:()=>m,toc:()=>d});a(59496);var n=a(49613),r=a(89639),l=a(48753);function i(){return i=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var a=arguments[e];for(var n in a)Object.prototype.hasOwnProperty.call(a,n)&&(t[n]=a[n])}return t},i.apply(this,arguments)}function o(t,e){if(null==t)return{};var a,n,r=function(t,e){if(null==t)return{};var a,n,r={},l=Object.keys(t);for(n=0;n<l.length;n++)a=l[n],e.indexOf(a)>=0||(r[a]=t[a]);return r}(t,e);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(t);for(n=0;n<l.length;n++)a=l[n],e.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(t,a)&&(r[a]=t[a])}return r}const s={id:"running-graphics-on-stm32h7r",title:"Running graphics on STM32H7R7 & S7"},p=void 0,m={unversionedId:"development/scenarios/running-graphics-on-stm32h7r",id:"development/scenarios/running-graphics-on-stm32h7r",title:"Running graphics on STM32H7R7 & S7",description:"This article addresses the specific architecture of the STM32H7R/S series MCUs and discusses the required considerations when using it for graphics. However, most of these considerations are applicable to all STM32 MCUs running graphics with external RAM and flash.",source:"@site/i18n/zh-TW/docusaurus-plugin-content-docs/current/development/scenarios/running-graphics-on-stm32h7r.mdx",sourceDirName:"development/scenarios",slug:"/development/scenarios/running-graphics-on-stm32h7r",permalink:"/4.25/zh-TW/docs/development/scenarios/running-graphics-on-stm32h7r",draft:!1,tags:[],version:"current",frontMatter:{id:"running-graphics-on-stm32h7r",title:"Running graphics on STM32H7R7 & S7"},sidebar:"docs",previous:{title:"NeoChrom/NeoChromVG\u4e0a\u7684TouchGFX",permalink:"/4.25/zh-TW/docs/development/scenarios/touchgfx-on-gpu2d"},next:{title:"Running graphics from external RAM",permalink:"/4.25/zh-TW/docs/development/scenarios/running-graphics-from-external-ram"}},c={},d=[{value:"Memory setup",id:"memory-setup",level:2},{value:"External Memory Manager",id:"external-memory-manager",level:3},{value:"Framebuffers in external RAM",id:"framebuffers-in-external-ram",level:3},{value:"Tightly coupled memory",id:"tightly-coupled-memory",level:3},{value:"Application type",id:"application-type",level:2},{value:"Execute in Place (XiP)",id:"execute-in-place-xip",level:3},{value:"Load and Run (LRUN)",id:"load-and-run-lrun",level:3},{value:"Performance comparison",id:"performance-comparison",level:3},{value:"MPU configuration",id:"mpu-configuration",level:2},{value:"Debugging",id:"debugging",level:2},{value:"Conclusion and general recommendations for graphics applications",id:"conclusion-and-general-recommendations-for-graphics-applications",level:2}],u={toc:d},h="wrapper";function g(t){var{components:e}=t,a=o(t,["components"]);return(0,n.kt)(h,i({},u,a,{components:e,mdxType:"MDXLayout"}),(0,n.kt)("p",null,"This article addresses the specific architecture of the STM32H7R/S series MCUs and discusses the required considerations when using it for graphics. However, most of these considerations are applicable to all STM32 MCUs running graphics with external RAM and flash."),(0,n.kt)("p",null,"The article is not a beginner\u2019s guide on how to create TouchGFX Board Setups (TBSs), as the STM32H7R/S is a high-performance and hence advanced MCU. Therefore, the article will also only dive into areas specific and important to STM32H7R/S. For a general introduction on how to create TouchGFX TBSs, refer to the ",(0,n.kt)("a",i({parentName:"p"},{href:"../board-bring-up/board-introduction"}),"Board Bring Up guide"),".",(0,n.kt)("br",{parentName:"p"}),"\n","For more information on the STM32H7R7/S7 please visit the ",(0,n.kt)("a",i({parentName:"p"},{href:"https://www.st.com/en/microcontrollers-microprocessors/stm32h7r7-7s7.html"}),"product page")," or the ",(0,n.kt)("a",i({parentName:"p"},{href:"https://www.youtube.com/playlist?list=PLnMKNibPkDnF2fL7nhQ08V0bPi2poXVpH"}),"YouTube playlist containing a full STM32H7RS demo workshop"),"."),(0,n.kt)("p",null,"TouchGFX Designer contains a TBS for STM32H7S78 DK, which is a complete example project of running TouchGFX on STM32H7R/S. The TBS can be used as reference when developing a TouchGFX application for STM32H7R/S. The project is based on STM32CubeMX, which means the recommended configuration for cache, MPU, external memory, etc. can be accessed by opening the STM32H7S78-DK.ioc file."),(0,n.kt)(r.Z,{imageSource:"/img/development/scenarios/running-graphics-on-stm32h7r/stm32h7s-tbs.png",mdxType:"Figure"},"TouchGFX Board Setup available in TouchGFX Designer"),(0,n.kt)("h2",i({},{id:"memory-setup"}),"Memory setup"),(0,n.kt)("p",null,"STM32H7R/S is a bootflash MCU. A bootflash MCU is an MCU with a small embedded flash that contains the bootloader, while the main application is placed in external memory along with assets. STM32H7R/S also has 620 kB of embedded SRAM. As a result, STM32H7R/S relies on both external RAM and flash when used for graphics applications. When using external memories for graphics, the memory bandwidth to the external memories will often be the bottleneck since they run at half or a third of the CPU frequency. In the case of STM32H7R7/S7 the two XSPI (16 and 8 bit) interfaces can run at up to 200 MHz in double transfer rate and the FMC (16 or 32 bit) can run at up to 100 MHz."),(0,n.kt)("h3",i({},{id:"external-memory-manager"}),"External Memory Manager"),(0,n.kt)("p",null,"Two tools called External Memory Manager and External Memory Loader are available from STM32CubeMX under Categories \u2192 Middleware and Software Packs. These tools are created to assist the user in setting up the external memories in bootflash or flashless applications. The tools make it easier to create external loaders and e.g. select application type. An introduction to the tools can be found ",(0,n.kt)("a",i({parentName:"p"},{href:"https://wiki.st.com/stm32mcu/wiki/Getting_started_with_External_memory_Manager_and_External_memory_loader"}),"here"),". A new article called ''Introduction to external serial memory with STM32'' will soon be published."),(0,n.kt)(l.Z,{mdxType:"FurtherReading"},(0,n.kt)("p",null,(0,n.kt)("a",i({parentName:"p"},{href:"https://wiki.st.com/stm32mcu/wiki/Getting_started_with_External_memory_Manager_and_External_memory_loader"}),"Getting started with External Memory Manager and External Memory Loader"))),(0,n.kt)("h3",i({},{id:"framebuffers-in-external-ram"}),"Framebuffers in external RAM"),(0,n.kt)("p",null,"The first and most important thing to consider when having framebuffers in external RAM is the memory bandwidth requirements and constraints. With a display with no GRAM, it is required to continuously transfer the framebuffer at the specified rate by the display. For the displays used on the discovery kits, this is 60 Hz. This means that a lot of bandwidth on the external RAM interface will be occupied with only updating the LTDC. The required bandwidth by the LTDC can be calculated as follows:"),(0,n.kt)("p",null,"pixel clock = LCD_CLK= total screen size ","*"," refresh rate",(0,n.kt)("br",{parentName:"p"}),"\n","Required bandwith(for one LTDC layer) = LCD_CLK ","*"," Bpp"),(0,n.kt)("p",null,"Furthermore, DMA2D and GPU2D will also require bandwidth on the external RAM when performing operations on the framebuffers. If the memory is also used for something else, such as application code, this will decrease the bandwidth even further.",(0,n.kt)("br",{parentName:"p"}),"\n","Combined, these factors can clutter the external RAM bus."),(0,n.kt)("p",null,"An article explaining considerations when running graphics with framebuffers in external RAM can be found ",(0,n.kt)("a",i({parentName:"p"},{href:"running-graphics-from-external-ram"}),"here"),"."),(0,n.kt)("p",null,"For further information on constraints and considerations when having an LTDC display interface and framebuffers in external RAM, refer to the ",(0,n.kt)("a",i({parentName:"p"},{href:"https://www.st.com/resource/en/application_note/an4861-introduction-to-lcdtft-display-controller-ltdc-on-stm32-mcus-stmicroelectronics.pdf"}),"LTDC application note"),". Pay special attention to chapter 5: \u201cCreating a graphical application with LTDC\u201d and chapter 7: \u201cLTDC application examples\u201d.",(0,n.kt)("br",{parentName:"p"}),"\n","If the bandwidth on the external RAM is at its limit, consider chapter 5.5.2: \u201cOptimizing the LTDC framebuffer fetching from external memories\u201d and chapter 5.5.3: \u201cOptimizing the LTDC framebuffer fetching from SDRAM\u201d."),(0,n.kt)(l.Z,{mdxType:"FurtherReading"},(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",i({parentName:"li"},{href:"running-graphics-from-external-ram"}),"Running graphics from external RAM")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",i({parentName:"li"},{href:"https://www.st.com/resource/en/application_note/an4861-introduction-to-lcdtft-display-controller-ltdc-on-stm32-mcus-stmicroelectronics.pdf"}),"AN4861: Introduction to LCD-TFT display controller (LTDC) on STM32 MCUs")))),(0,n.kt)("h3",i({},{id:"tightly-coupled-memory"}),"Tightly coupled memory"),(0,n.kt)("p",null,"The STM32H7R/S Cortex-M7 features a 64-bit wide direct access to tightly coupled memories (TCM) with zero wait state. It has up to 192 kB of both data TCM (DTCM) and instruction TCM (ITCM). The DTCM and ITCM are hence the best locations for read/write of data and instruction fetch respectively. Therefore, the ITCM should be used for critical code with deterministic execution, such as interrupt handlers that cannot wait for cache misses, as well as e.g. critical control loops. In real-time applications that use RTOS, the heap is generally massively used. It is therefore recommended to place the RTOS stack and heap in DTCM. If there is any space left, global variables could be placed here as well."),(0,n.kt)("p",null,"It is important to note that ITCM and DTCM are using some parts of the SRAM1 and SRAM3 memories. This implies that the size of the internal SRAM will shrink when using ITCM and DTCM."),(0,n.kt)(r.Z,{imageSource:"/img/development/scenarios/running-graphics-on-stm32h7r/tcm-illustration.png",mdxType:"Figure"},"Illustration of the tightly coupled memory on STM32H7R/S"),(0,n.kt)("p",null,"Like other H7 MCUs, STM32H7R/S has Level 1 (L1) cache. For more information on L1 cache, refer to the ",(0,n.kt)("a",i({parentName:"p"},{href:"https://www.st.com/resource/en/application_note/an4839-level-1-cache-on-stm32f7-series-and-stm32h7-series-stmicroelectronics.pdf"}),"H7 cache application note"),". Pay special attention to chapter 4: \u201cMistakes to avoid and tips\u201d."),(0,n.kt)("p",null,"For a detailed description of how to setup external SPI memories, refer to ",(0,n.kt)("a",i({parentName:"p"},{href:"https://www.st.com/resource/en/application_note/an5050-getting-started-with-octospi-hexadecaspi-and-xspi-interface-on-stm32-mcus-stmicroelectronics.pdf"}),"OSPI, HSPI and XSPI application note"),"."),(0,n.kt)(l.Z,{mdxType:"FurtherReading"},(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",i({parentName:"li"},{href:"https://www.st.com/resource/en/application_note/an6062-introduction-to-stm32h7rx7sx-system-architecture-and-performance-stmicroelectronics.pdf"}),"AN6062: Introduction to STM32H7Rx/7Sx system architecture and performance")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",i({parentName:"li"},{href:"https://www.st.com/resource/en/application_note/an4839-level-1-cache-on-stm32f7-series-and-stm32h7-series-stmicroelectronics.pdf"}),"AN4839: Level 1 cache on STM32F7 Series and STM32H7 Series")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",i({parentName:"li"},{href:"https://www.st.com/resource/en/application_note/an5050-getting-started-with-octospi-hexadecaspi-and-xspi-interface-on-stm32-mcus-stmicroelectronics.pdf"}),"AN5050: Getting started with Octo-SPI, Hexadeca-SPI, and XSPI interfaces\non STM32 MCUs"),"."))),(0,n.kt)("h2",i({},{id:"application-type"}),"Application type"),(0,n.kt)("p",null,"During startup, the bootloader can do different things depending on the selected application type. It can either point to the application already in place in the external flash, or load the application to another memory, typically external RAM.",(0,n.kt)("br",{parentName:"p"}),"\n","Executing the application already in place in external flash is called execute-in-place (XiP). Copying the application from flash to RAM during boot and then executing from RAM is called load-and-run (LRUN)."),(0,n.kt)("p",null,"If the application is encrypted, it is only possible to use LRUN. For further information on encryption on STM32, refer to the ",(0,n.kt)("a",i({parentName:"p"},{href:"https://www.st.com/resource/en/application_note/an6088-how-to-use-mce-for-encryptiondecryption-on-stm32-mcus-stmicroelectronics.pdf"}),"application note on encryption"),"."),(0,n.kt)(l.Z,{mdxType:"FurtherReading"},(0,n.kt)("p",null,(0,n.kt)("a",i({parentName:"p"},{href:"https://www.st.com/resource/en/application_note/an6088-how-to-use-mce-for-encryptiondecryption-on-stm32-mcus-stmicroelectronics.pdf"}),"AN6088: How to use MCE for encryption/decryption on STM32 MCUs"))),(0,n.kt)("h3",i({},{id:"execute-in-place-xip"}),"Execute in Place (XiP)"),(0,n.kt)("p",null,"An example of how the memory layout for XiP could look like for a graphics application is illustrated below. XiP is the default application type."),(0,n.kt)(r.Z,{imageSource:"/img/development/scenarios/running-graphics-on-stm32h7r/xip-illustration.png",mdxType:"Figure"},"Illustration of XiP application for graphics"),(0,n.kt)("p",null,"As shown in the XiP illustration, the OctoSPI interface to the external flash is used to access both application code and graphics assets. The CPU constantly accesses the application code, which can lead to slower access times for NeoChrom GPU or Chrom-ART when accessing the assets. This will negatively impact graphics performance. To mitigate this challenge, it is highly recommended to enable the instruction cache for external flash when running XiP. By doing so, repeated instructions will be read from the cache instead of the external flash, thereby reducing the load on the bandwidth and increasing the efficiency of the external flash interface."),(0,n.kt)("h3",i({},{id:"load-and-run-lrun"}),"Load and Run (LRUN)"),(0,n.kt)("p",null,"A corresponding example for LRUN is illustrated below."),(0,n.kt)(r.Z,{imageSource:"/img/development/scenarios/running-graphics-on-stm32h7r/lrun-illustration.png",mdxType:"Figure"},"Illustration of LRUN application for graphics"),(0,n.kt)("p",null,"As shown in the LRUN illustration, the application code is now separated from the graphics assets, which improves the access of assets. However, this also means that it is now the interface to the external RAM, which will be loaded, since it is needed to access both framebuffers and application code. In this case, it is highly recommended to enable instruction cache on the external RAM interface."),(0,n.kt)("p",null,"When using LRUN on STM32H7R/S with a graphics application, there are a few extra things to consider to achieve the best possible performance.",(0,n.kt)("br",{parentName:"p"}),"\n","First, consider if the assets (bitmaps, fonts, etc.) could be kept in external flash. Since the assets are accessed frequently, storing them in external RAM will significantly load the bandwidth of the external RAM. Furthermore, it is typically unnecessary to encrypt assets.",(0,n.kt)("br",{parentName:"p"}),"\n","Secondly, it is worth investigating if the application code will fit in internal SRAM as illustrated below. The application code can be accessed and executed even faster from internal SRAM compared to having it in external flash or external RAM, as the internal buses are faster. The AXI bus on STM32H7R/S, to which the internal SRAM is connected, can run at speeds of up to 300 MHz. Furthermore, this configuration allows assets, framebuffers, and application code to be placed in three different locations, thereby distributing the bandwidth load across three separate buses."),(0,n.kt)(r.Z,{imageSource:"/img/development/scenarios/running-graphics-on-stm32h7r/lrun-intram-illustration.png",mdxType:"Figure"},"Illustration of LRUN application for graphics with application code in internal RAM"),(0,n.kt)("h3",i({},{id:"performance-comparison"}),"Performance comparison"),(0,n.kt)("p",null,"Below are examples of complex GUIs using XiP and LRUN respectively. The LRUN application has the application code in internal SRAM. The comparison shows how the MCU load is impacted by the different configurations. By placing the TouchGFX framework and application into the internal SRAM, the number of cycles for fetching in external RAM and flash is reduced, which effectively decreases the MCU load.",(0,n.kt)("br",{parentName:"p"}),"\n","Demo reference is the out-of-box demo running on STM32H7S78-DK."),(0,n.kt)(r.Z,{imageSource:"/img/development/scenarios/running-graphics-on-stm32h7r/lrun-xip-comparison.png",mdxType:"Figure"},"Comparison of MCU load for LRUN and XiP application"),(0,n.kt)("p",null,"The comparison shows that the MCU load is reduced when the application code is placed in internal SRAM. The MCU load is reduced by approximately 50% when using LRUN compared to XiP."),(0,n.kt)("p",null,"The comparison shows that the MCU load is significantly reduced when the application code is placed in internal SRAM. This is due to the faster access times of the internal SRAM compared to external RAM and flash. The MCU load is reduced by 50% when using LRUN with the application code in internal SRAM compared to XiP. Using LRUN with application code stored in internal SRAM offers the best performance. However, this configuration is only feasible when the application code fits within the available internal SRAM."),(0,n.kt)("h2",i({},{id:"mpu-configuration"}),"MPU configuration"),(0,n.kt)("p",null,"The memory protection unit (MPU) is used to protect memory areas from unintended memory access and -execution.",(0,n.kt)("br",{parentName:"p"}),"\n","On Arm\xae Cortex\xae-M7 processors, it is important to prevent speculative access as it may cause high latency or system errors when performed on external memories. For STM32H7R/S, this will impact the AXI masters accessing the memories and it will significantly decrease graphics performance.",(0,n.kt)("br",{parentName:"p"}),"\n","The MPU can be used to prevent speculative read access, by controlling the accessible address ranges. The easiest way to do this is by using a background region with the entire memory area, which restricts access by setting it to \u201cstrongly ordered, execute never\u201d."),(0,n.kt)("p",null,"The background region should be defined in the default region with ID -1 since all other regions will then have priority over this region. Then, other MPU regions with respective settings should be defined for the memory areas that need access. It is possible to define up to 16 regions on STM32H7R/S."),(0,n.kt)("p",null,"The MPU configuration from the STM32H7S78 DK TBS is inserted below. This configuration can be used as reference."),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",i({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"th"},"Region 0")),(0,n.kt)("th",i({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"th"},"All")),(0,n.kt)("th",i({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"th"},"Note")))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),(0,n.kt)("em",{parentName:"td"},"Attribute")),(0,n.kt)("td",i({parentName:"tr"},{align:null}),(0,n.kt)("em",{parentName:"td"},"Value")),(0,n.kt)("td",i({parentName:"tr"},{align:null}))),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"MPU Region Base Address"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"0x0"),(0,n.kt)("td",i({parentName:"tr"},{align:null}))),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"MPU Region Size"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"4 GB"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Covers the entire memory area of the MCU")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"MPU SubRegion Disable"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"0x0"),(0,n.kt)("td",i({parentName:"tr"},{align:null}))),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"MPU TEX field level"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Level 0"),(0,n.kt)("td",i({parentName:"tr"},{align:null}))),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"MPU Access Permission"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"ALL ACCESS NOT PERMITTED"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Restrict all access")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"MPU Instruction Access"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"DISABLE"),(0,n.kt)("td",i({parentName:"tr"},{align:null}))),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"MPU Shareability Permission"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"ENABLE"),(0,n.kt)("td",i({parentName:"tr"},{align:null}))),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"MPU Cacheable Permission"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"DISABLE"),(0,n.kt)("td",i({parentName:"tr"},{align:null}))),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"MPU Bufferable Permission"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"DISABLE"),(0,n.kt)("td",i({parentName:"tr"},{align:null}))))),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",i({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"th"},"Region 1")),(0,n.kt)("th",i({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"th"},"External flash")),(0,n.kt)("th",i({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"th"},"Note")))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),(0,n.kt)("em",{parentName:"td"},"Attribute")),(0,n.kt)("td",i({parentName:"tr"},{align:null}),(0,n.kt)("em",{parentName:"td"},"Value")),(0,n.kt)("td",i({parentName:"tr"},{align:null}))),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"MPU Region Base Address"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"0x70000000"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Base address of XSPI2 (external flash)")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"MPU Region Size"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"128 MB"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"128 MBytes external flash on the board")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"MPU SubRegion Disable"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"0x0"),(0,n.kt)("td",i({parentName:"tr"},{align:null}))),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"MPU TEX field level"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Level 1"),(0,n.kt)("td",i({parentName:"tr"},{align:null}))),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"MPU Access Permission"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"ALL ACCESS PERMITTED"),(0,n.kt)("td",i({parentName:"tr"},{align:null}))),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"MPU Instruction Access"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"DISABLE"),(0,n.kt)("td",i({parentName:"tr"},{align:null}))),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"MPU Shareability Permission"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"DISABLE"),(0,n.kt)("td",i({parentName:"tr"},{align:null}))),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"MPU Cacheable Permission"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"ENABLE"),(0,n.kt)("td",i({parentName:"tr"},{align:null}))),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"MPU Bufferable Permission"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"ENABLE"),(0,n.kt)("td",i({parentName:"tr"},{align:null}))))),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",i({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"th"},"Region 2")),(0,n.kt)("th",i({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"th"},"External flash")),(0,n.kt)("th",i({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"th"},"Note")))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),(0,n.kt)("em",{parentName:"td"},"Attribute")),(0,n.kt)("td",i({parentName:"tr"},{align:null}),(0,n.kt)("em",{parentName:"td"},"Value")),(0,n.kt)("td",i({parentName:"tr"},{align:null}))),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"MPU Region"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Enabled"),(0,n.kt)("td",i({parentName:"tr"},{align:null}))),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"MPU Region Base Address"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"0x70000000"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Base address of XSPI2 (external flash)")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"MPU Region Size"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"2 MB"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Properties for the first 2 MB of the external flash, where application code is placed, is overwritten")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"MPU SubRegion Disable"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"0x0"),(0,n.kt)("td",i({parentName:"tr"},{align:null}))),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"MPU TEX field level"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Level 1"),(0,n.kt)("td",i({parentName:"tr"},{align:null}))),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"MPU Access Permission"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"ALL ACCESS PERMITTED"),(0,n.kt)("td",i({parentName:"tr"},{align:null}))),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"MPU Instruction Access"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"ENABLE"),(0,n.kt)("td",i({parentName:"tr"},{align:null}))),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"MPU Shareability Permission"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"DISABLE"),(0,n.kt)("td",i({parentName:"tr"},{align:null}))),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"MPU Cacheable Permission"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"ENABLE"),(0,n.kt)("td",i({parentName:"tr"},{align:null}))),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"MPU Bufferable Permission"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"ENABLE"),(0,n.kt)("td",i({parentName:"tr"},{align:null}))))),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",i({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"th"},"Region 3")),(0,n.kt)("th",i({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"th"},"External PSRAM")),(0,n.kt)("th",i({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"th"},"Note")))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),(0,n.kt)("em",{parentName:"td"},"Attribute")),(0,n.kt)("td",i({parentName:"tr"},{align:null}),(0,n.kt)("em",{parentName:"td"},"Value")),(0,n.kt)("td",i({parentName:"tr"},{align:null}))),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"MPU Region Base Address"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"0x90000000"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Base address of XSPI1 (external PSRAM)")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"MPU Region Size"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"32 MB"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"32 MBytes external PSRAM on the board")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"MPU SubRegion Disable"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"0x0"),(0,n.kt)("td",i({parentName:"tr"},{align:null}))),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"MPU TEX field level"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Level 1"),(0,n.kt)("td",i({parentName:"tr"},{align:null}))),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"MPU Access Permission"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"ALL ACCESS PERMITTED"),(0,n.kt)("td",i({parentName:"tr"},{align:null}))),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"MPU Instruction Access"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"DISABLE"),(0,n.kt)("td",i({parentName:"tr"},{align:null}))),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"MPU Shareability Permission"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"DISABLE"),(0,n.kt)("td",i({parentName:"tr"},{align:null}))),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"MPU Cacheable Permission"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"DISABLE"),(0,n.kt)("td",i({parentName:"tr"},{align:null}))),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"MPU Bufferable Permission"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"DISABLE"),(0,n.kt)("td",i({parentName:"tr"},{align:null}))))),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",i({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"th"},"Region 4")),(0,n.kt)("th",i({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"th"},"DTCM")),(0,n.kt)("th",i({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"th"},"Note")))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),(0,n.kt)("em",{parentName:"td"},"Attribute")),(0,n.kt)("td",i({parentName:"tr"},{align:null}),(0,n.kt)("em",{parentName:"td"},"Value")),(0,n.kt)("td",i({parentName:"tr"},{align:null}))),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"MPU Region Base Address"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"0x20000000"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Base address of DTCM")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"MPU Region Size"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"64 kB"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Default 64 kB of DTCM")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"MPU SubRegion Disable"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"0x0"),(0,n.kt)("td",i({parentName:"tr"},{align:null}))),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"MPU TEX field level"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Level 1"),(0,n.kt)("td",i({parentName:"tr"},{align:null}))),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"MPU Access Permission"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"ALL ACCESS PERMITTED"),(0,n.kt)("td",i({parentName:"tr"},{align:null}))),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"MPU Instruction Access"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"DISABLE"),(0,n.kt)("td",i({parentName:"tr"},{align:null}))),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"MPU Shareability Permission"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"DISABLE"),(0,n.kt)("td",i({parentName:"tr"},{align:null}))),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"MPU Cacheable Permission"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"DISABLE"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Disable caching on DTCM, since it does not yield performance increase")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"MPU Bufferable Permission"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"DISABLE"),(0,n.kt)("td",i({parentName:"tr"},{align:null}))))),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",i({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"th"},"Region 5")),(0,n.kt)("th",i({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"th"},"SRAM")),(0,n.kt)("th",i({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"th"},"Note")))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),(0,n.kt)("em",{parentName:"td"},"Attribute")),(0,n.kt)("td",i({parentName:"tr"},{align:null}),(0,n.kt)("em",{parentName:"td"},"Value")),(0,n.kt)("td",i({parentName:"tr"},{align:null}))),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"MPU Region Base Address"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"0x24000000"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Base address of SRAM1")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"MPU Region Size"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"512 kB"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Covers SRAM1, SRAM2, SRAM3 and SRAM4")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"MPU SubRegion Disable"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"0x0"),(0,n.kt)("td",i({parentName:"tr"},{align:null}))),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"MPU TEX field level"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Level 1"),(0,n.kt)("td",i({parentName:"tr"},{align:null}))),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"MPU Access Permission"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"ALL ACCESS PERMITTED"),(0,n.kt)("td",i({parentName:"tr"},{align:null}))),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"MPU Instruction Access"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"DISABLE"),(0,n.kt)("td",i({parentName:"tr"},{align:null}))),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"MPU Shareability Permission"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"ENABLE"),(0,n.kt)("td",i({parentName:"tr"},{align:null}))),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"MPU Cacheable Permission"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"ENABLE"),(0,n.kt)("td",i({parentName:"tr"},{align:null}))),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"MPU Bufferable Permission"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"ENABLE"),(0,n.kt)("td",i({parentName:"tr"},{align:null}))))),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",i({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"th"},"Region 6")),(0,n.kt)("th",i({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"th"},"GPU2D command list")),(0,n.kt)("th",i({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"th"},"Note")))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),(0,n.kt)("em",{parentName:"td"},"Attribute")),(0,n.kt)("td",i({parentName:"tr"},{align:null}),(0,n.kt)("em",{parentName:"td"},"Value")),(0,n.kt)("td",i({parentName:"tr"},{align:null}))),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"MPU Region Base Address"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"0x2406e000"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"NeoChrom GPU command list is placed here")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"MPU Region Size"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"16 kB"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Default size of NeoChrom GPU command list when using TouchGFX (defined in nema_hal.c)")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"MPU SubRegion Disable"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"0x0"),(0,n.kt)("td",i({parentName:"tr"},{align:null}))),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"MPU TEX field level"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Level 0"),(0,n.kt)("td",i({parentName:"tr"},{align:null}))),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"MPU Access Permission"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"ALL ACCESS PERMITTED"),(0,n.kt)("td",i({parentName:"tr"},{align:null}))),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"MPU Instruction Access"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"DISABLE"),(0,n.kt)("td",i({parentName:"tr"},{align:null}))),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"MPU Shareability Permission"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"ENABLE"),(0,n.kt)("td",i({parentName:"tr"},{align:null}))),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"MPU Cacheable Permission"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"DISABLE"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"Disable caching on command list")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),"MPU Bufferable Permission"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"ENABLE"),(0,n.kt)("td",i({parentName:"tr"},{align:null}))))),(0,n.kt)("p",null,"For general graphics-specific MPU configuration tips, refer to chapter 5.6.2: \u201cConfigure the memory protection unit (MPU)\u201d in the ",(0,n.kt)("a",i({parentName:"p"},{href:"https://www.st.com/resource/en/application_note/an4861-introduction-to-lcdtft-display-controller-ltdc-on-stm32-mcus-stmicroelectronics.pdf"}),"LTDC application note"),"."),(0,n.kt)("p",null,"For further reference, see the ",(0,n.kt)("a",i({parentName:"p"},{href:"https://www.st.com/resource/en/application_note/an4838-introduction-to-memory-protection-unit-management-on-stm32-mcus-stmicroelectronics.pdf"}),"MPU application note"),". Pay special attention to chapter 3: \u201cCortex-M0+/M3/M4/M7 memory types, registers and attributes\u201d and chapter 6: \u201cMPU setting example with STM32Cube HAL on Armv6 and Armv7 Architectures\u201d."),(0,n.kt)(l.Z,{mdxType:"FurtherReading"},(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",i({parentName:"li"},{href:"https://www.st.com/resource/en/application_note/an4861-introduction-to-lcdtft-display-controller-ltdc-on-stm32-mcus-stmicroelectronics.pdf"}),"AN4861: Introduction to LCD-TFT display controller (LTDC) on STM32 MCUs")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",i({parentName:"li"},{href:"https://www.st.com/resource/en/application_note/an4838-introduction-to-memory-protection-unit-management-on-stm32-mcus-stmicroelectronics.pdf"}),"AN4838: Introduction to memory protection unit management on STM32 MCUs")))),(0,n.kt)("h2",i({},{id:"debugging"}),"Debugging"),(0,n.kt)("p",null,"The following guide to debugging STM32H7R/S in STM32CubeIDE is available in the readme in the TBS available in TouchGFX Designer."),(0,n.kt)("p",null,"Debugging the code in an IDE can be complex because of the Bootloader and Application structure of the TBS for STM32H7S78-DK. To step through the code of the TouchGFX application in STM32CubeIDE, follow these steps:"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},"Generate code in TouchGFX Designer"),(0,n.kt)("li",{parentName:"ol"},"Open the project in STM32CubeIDE"),(0,n.kt)("li",{parentName:"ol"},"Launch a debug session for the Boot project"),(0,n.kt)("li",{parentName:"ol"},"Wait for the compilation and flashing to complete"),(0,n.kt)("li",{parentName:"ol"},"Terminate the debug session (Ctrl + F2)"),(0,n.kt)("li",{parentName:"ol"},"Launch a debug session for the Appli project"),(0,n.kt)("li",{parentName:"ol"},"Wait for the compilation and flashing to complete"),(0,n.kt)("li",{parentName:"ol"},"Click Resume (F8)"),(0,n.kt)("li",{parentName:"ol"},"Press the black NRST button on the STM32H7S78-DK board"),(0,n.kt)("li",{parentName:"ol"},"The application is now at a break point at the first line of main() in the Appli project. If not, click Resume (F8) once more"),(0,n.kt)("li",{parentName:"ol"},"Proceed by e.g. clicking Resume (F8) or Step Over (F6)")),(0,n.kt)("p",null,"For further information on debugging, refer to the wiki page on ",(0,n.kt)("a",i({parentName:"p"},{href:"https://wiki.stmicroelectronics.cn/stm32mcu/wiki/Security:How_to_start_with_DA_access_on_STM32H7RS"}),"How to start with DA access on STM32H7RS"),"."),(0,n.kt)(l.Z,{mdxType:"FurtherReading"},(0,n.kt)("p",null,(0,n.kt)("a",i({parentName:"p"},{href:"https://wiki.stmicroelectronics.cn/stm32mcu/wiki/Security:How_to_start_with_DA_access_on_STM32H7RS"}),"How to start with DA access on STM32H7RS"))),(0,n.kt)("h2",i({},{id:"conclusion-and-general-recommendations-for-graphics-applications"}),"Conclusion and general recommendations for graphics applications"),(0,n.kt)("p",null,"As explained above, there are several considerations to be made when developing a graphics application for STM32H7R/S. However, by keeping these considerations in mind, it is possible to achieve great graphics performance due to the fast CPU and the powerful GPU2D."),(0,n.kt)("p",null,"First of all, it is very important to be aware of the bandwidth on the external memory buses. This applies to all MCUs that are used with external RAM and flash, but it is especially crucial to consider due to the bootflash structure of STM32H7R/S."),(0,n.kt)("p",null,"The performance can be significantly increased by placing critical instructions and data in the ITCM and DTCM memory."),(0,n.kt)("p",null,"Enable the L1 instruction and data cache integrated into the Arm\xae Cortex\xae-M7 processor as this will boost the performance as well."),(0,n.kt)("p",null,"Choose whether to run either XiP or LRUN based on application requirements but remember to be aware of memory bandwidth. If the application code can fit in internal SRAM, LRUN will be the best performing."),(0,n.kt)("p",null,"It is important to avoid speculative read access as this will potentially decrease performance quite significantly. This is done by applying appropriate MPU configurations to all memory regions."))}g.isMDXComponent=!0}}]);