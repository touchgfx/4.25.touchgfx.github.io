"use strict";(self.webpackChunktouchgfx_documentation=self.webpackChunktouchgfx_documentation||[]).push([[3898],{49613:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>m});var r=n(59496);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=r.createContext({}),l=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=l(e.components);return r.createElement(c.Provider,{value:t},e.children)},u="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,c=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=l(n),p=a,m=u["".concat(c,".").concat(p)]||u[p]||h[p]||o;return n?r.createElement(m,i(i({ref:t},d),{},{components:n})):r.createElement(m,i({ref:t},d))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=p;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s[u]="string"==typeof e?e:a,i[1]=s;for(var l=2;l<o;l++)i[l]=n[l];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}p.displayName="MDXCreateElement"},93822:(e,t,n)=>{n.d(t,{Z:()=>s});var r=n(59496),a=n(96151);const o=r.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 16 16"},r.createElement("path",{fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"}));class i extends r.Component{render(){return r.createElement(a.Z,{color:"var(--highlight-color-caution)",header:"Caution",type:"caution",icon:o},this.props.children)}}const s=i},28128:(e,t,n)=>{n.d(t,{Z:()=>o});var r=n(59496);class a extends r.Component{render(){return r.createElement("div",{className:"code-header"},r.createElement("div",null,r.createElement("h5",null,this.props.children)))}}const o=a},89639:(e,t,n)=>{n.d(t,{Z:()=>o});var r=n(59496),a=n(97395);const o=function(e){const t=e.noShadow||!1,n=e.width,o=e.height,i=(0,a.Z)(e.imageSource);return t?r.createElement("div",{className:"figure noshadow"},r.createElement("a",{href:i,target:"_blank"},r.createElement("img",{width:n,height:o,src:i})),r.createElement("p",null,e.children)):r.createElement("div",{className:"figure"},r.createElement("a",{href:i,target:"_blank"},r.createElement("img",{width:n,height:o,src:i})),r.createElement("p",null,e.children))}},96151:(e,t,n)=>{n.d(t,{Z:()=>o});var r=n(59496);class a extends r.Component{render(){const e=`highlight highlight-${this.props.type}`;return r.createElement("div",{className:e},r.createElement("div",{className:"highlight-heading"},r.createElement("h5",null,r.createElement("div",{className:"highlight-icon"},this.props.icon),this.props.header)),r.createElement("div",{className:"highlight-content"},this.props.children))}}const o=a},49018:(e,t,n)=>{n.d(t,{Z:()=>s});var r=n(59496),a=n(96151);const o=r.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},r.createElement("path",{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}));class i extends r.Component{render(){return r.createElement(a.Z,{color:"var(--highlight-color-note)",header:"Note",type:"note",icon:o},this.props.children)}}const s=i},40934:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>u,default:()=>f,frontMatter:()=>d,metadata:()=>h,toc:()=>m});n(59496);var r=n(49613),a=n(89639),o=n(49018),i=n(93822),s=n(28128);function c(){return c=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},c.apply(this,arguments)}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}const d={id:"cmake-as-build-system",title:"CMake as build system"},u=void 0,h={unversionedId:"development/scenarios/cmake-as-build-system",id:"development/scenarios/cmake-as-build-system",title:"CMake as build system",description:"Introduction",source:"@site/i18n/zh-CN/docusaurus-plugin-content-docs/current/development/scenarios/cmake-as-build-system.mdx",sourceDirName:"development/scenarios",slug:"/development/scenarios/cmake-as-build-system",permalink:"/4.25/zh-CN/docs/development/scenarios/cmake-as-build-system",draft:!1,tags:[],version:"current",frontMatter:{id:"cmake-as-build-system",title:"CMake as build system"},sidebar:"docs",previous:{title:"Converting a Keil compiler 5 project to Keil compiler 6",permalink:"/4.25/zh-CN/docs/development/scenarios/converting-keil5-project-to-keil6"},next:{title:"Miscellaneous",permalink:"/4.25/zh-CN/docs/category/miscellaneous-1"}},p={},m=[{value:"Introduction",id:"introduction",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Change toolchain in STM32CubeMX",id:"change-toolchain",level:2},{value:"Generate code in TouchGFX designer",id:"generate-code",level:2},{value:"Project structure",id:"project-structure",level:2},{value:"Updating linker scripts",id:"updating-linker-scripts",level:2},{value:"Building a project",id:"building-a-project",level:2}],g={toc:m},k="wrapper";function f(e){var{components:t}=e,n=l(e,["components"]);return(0,r.kt)(k,c({},g,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",c({},{id:"introduction"}),"Introduction"),(0,r.kt)("p",null,"From TouchGFX V4.25.0 and STM32CubeMX V6.14.0 onwards, the CMake build system is a supported toolchain for TouchGFX projects. This scenario will show you how to set up, build, and debug a TouchGFX project using CMake as build system."),(0,r.kt)("p",null,"To learn more about CMake, visit the official ",(0,r.kt)("a",c({parentName:"p"},{href:"https://cmake.org/cmake/help/latest/index.html#"}),"CMake documentation"),"."),(0,r.kt)("h2",c({},{id:"prerequisites"}),"Prerequisites"),(0,r.kt)("p",null,"It is recommended to download the STM32Cube Command Line Toolset (",(0,r.kt)("a",c({parentName:"p"},{href:"https://www.st.com/en/development-tools/stm32cubeclt.html"}),"STM32CubeCLT"),"). This includes all the required tools (compiler, debugger, CMake, Ninja, etc.) to configure, build, and debug CMake projects generated by STM32CubeMX."),(0,r.kt)(o.Z,{mdxType:"Note"},"It is possible to use another compiler, build system (e.g., Make), and/or debugger with CMake, but this guide assumes a setup using the STM32CubeCLT."),(0,r.kt)("h2",c({},{id:"change-toolchain"}),"Change toolchain in STM32CubeMX"),(0,r.kt)("p",null,'First, change the toolchain in the "Project Manager" tab in STM32CubeMX to CMake. Then, generate code.'),(0,r.kt)(a.Z,{noShadow:!0,imageSource:"/img/development/scenarios/cmake-as-build-system/change-toolchain.png",mdxType:"Figure"},"CMake toolchain selected"),(0,r.kt)("h2",c({},{id:"generate-code"}),"Generate code in TouchGFX designer"),(0,r.kt)("p",null,"Generate code from the TouchGFX designer by pressing the button or the F4 key on your keyboard, to add the TouchGFX specific code to the project."),(0,r.kt)(a.Z,{noShadow:!0,imageSource:"/img/development/scenarios/cmake-as-build-system/generate-code.png",mdxType:"Figure"},"Generate code"),(0,r.kt)("h2",c({},{id:"project-structure"}),"Project structure"),(0,r.kt)("p",null,"After generating code in STM32CubeMX and TouchGFX Designer, a file structure similar to the one below will be created:"),(0,r.kt)("pre",null,(0,r.kt)("code",c({parentName:"pre"},{}),"\u251c\u2500\u2500\u2500<project-name>.ioc\n\u251c\u2500\u2500\u2500CMakeLists.txt                  # Root CMake list\n\u251c\u2500\u2500\u2500CMakePresets.json               # Predefined CMake configurations\n\u251c\u2500\u2500\u2500<mcu-part-number>.ld                   # Generated linker scripts, e.g., STM32U5g9xx_FLASH.ld\n\u251c\u2500\u2500\u2500cmake\n|   \u251c\u2500\u2500\u2500gcc-arm-none-eabi.cmake     # CMake toolchain file\n\u2502   \u251c\u2500\u2500\u2500stm32cubemx\n\u2502   \u2502   \u2514\u2500\u2500\u2500CMakeLists.txt          # STM32CubeMX CMake list\n\u2502   \u2514\u2500\u2500\u2500touchgfx\n\u2502       \u2514\u2500\u2500\u2500CMakeLists.txt          # TouchGFX CMake list\n\u251c\u2500\u2500\u2500Core\n\u251c\u2500\u2500\u2500Drivers\n\u251c\u2500\u2500\u2500Middlewares\n\u2514\u2500\u2500\u2500TouchGFX\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"CMakeLists.txt")," file in the root of the project is intended for user modifications and is the entry point for the CMake configuration. The ",(0,r.kt)("inlineCode",{parentName:"p"},"CMakePresets.json")," file defines various configuration presets (e.g., Debug, Release) for the project."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"stm32cubemx/CMakeLists.txt")," list file manages the files generated by STM32CubeMX, while the ",(0,r.kt)("inlineCode",{parentName:"p"},"touchgfx/CMakeLists.txt")," file manages the TouchGFX specific GUI files. Therefore, it is important to to re-generate code in the TouchGFX Designer when adding/deleting GUI elements and assets to the project to reflect the changes to the build system."),(0,r.kt)("p",null,"When generating code in TouchGFX Designer the first time, it will try to add the following line to the root ",(0,r.kt)("inlineCode",{parentName:"p"},"CMakeLists.txt"),", which includes TouchGFX to the build system:"),(0,r.kt)(s.Z,{mdxType:"CodeHeader"},"CMakeLists.txt"),(0,r.kt)("pre",null,(0,r.kt)("code",c({parentName:"pre"},{className:"language-cmake",metastring:"{6}","{6}":!0}),"...\n# Add STM32CubeMX generated sources\nadd_subdirectory(cmake/stm32cubemx)\n\n# Add touchgfx generated sources and libraries\nadd_subdirectory(cmake/touchgfx)\n...\n")),(0,r.kt)("p",null,"It is required that the TouchGFX CMake list file is included ",(0,r.kt)("strong",{parentName:"p"},"after")," the STM32CubeMX CMake list, as there are dependencies to MCU specific HAL and Drivers that are defined in the STM32CubeMX CMake list."),(0,r.kt)(i.Z,{mdxType:"Caution"},"If the TouchGFX Designer fails to correctly include the touchgfx CMake list, a warning message is generated in the TouchGFX Designer log. In this case, the line should be added manually in the CMake list file specified by the warning."),(0,r.kt)("h2",c({},{id:"updating-linker-scripts"}),"Updating linker scripts"),(0,r.kt)("p",null,"After generating code with STM32CubeMX, one or more linker scripts compatible with arm GCC are generated by STM32CubeMX. The linker scrips are generated once, and can be modified manually to fit the project requirements."),(0,r.kt)("p",null,"If the project is based on a ",(0,r.kt)("em",{parentName:"p"},"TouchGFX Board Setup"),", the linker scripts that are already defined for the STM32CubeIDE toolchain can be used as a reference to update the default linker script."),(0,r.kt)("p",null,"Alternatively, users can update the generated ",(0,r.kt)("a",c({parentName:"p"},{href:"https://cmake.org/cmake/help/latest/manual/cmake-toolchains.7.html"}),"CMake toolchain file")," ",(0,r.kt)("inlineCode",{parentName:"p"},"gcc-arm-none-eabi.cmake")," to point out another linker script to be used by the linker instead of the default one. For example, to use the already defined STM32CubeIDE linker script:"),(0,r.kt)(s.Z,{mdxType:"CodeHeader"},"gcc-arm-none-eabi.cmake"),(0,r.kt)("pre",null,(0,r.kt)("code",c({parentName:"pre"},{className:"language-cmake",metastring:"{3}","{3}":!0}),'...\nset(CMAKE_C_LINK_FLAGS "${TARGET_FLAGS}")\nset(CMAKE_C_LINK_FLAGS "${CMAKE_C_LINK_FLAGS} -T \\"${CMAKE_SOURCE_DIR}/STM32CubeIDE/STM32U5G9ZJTXQ_FLASH.ld\\"")\n...\n')),(0,r.kt)("h2",c({},{id:"building-a-project"}),"Building a project"),(0,r.kt)("p",null,"After generating code and ensuring TouchGFX is included as part of the build system the project can be build and debugged using the STM32 VS Code Extension. The STM32 VS Code Extension is a useful tool that allow developers to build CMake projects and debug them on target using the STM32CubeCLT."),(0,r.kt)("p",null,"First, the project must be imported using the STM32 VS Code Extension by selecting ",(0,r.kt)("inlineCode",{parentName:"p"},"Import CMake project")," and choosing the root of the project as the project location:"),(0,r.kt)(a.Z,{noShadow:!0,imageSource:"/img/development/scenarios/cmake-as-build-system/import-project.png",width:"300",mdxType:"Figure"},"Importing CMake project"),(0,r.kt)("p",null,"The extension will detect the MCU and toolchain used in the project. Various VSCode tasks and launch configurations are generated by the extension in the VSCode meta data folder ",(0,r.kt)("inlineCode",{parentName:"p"},".vscode/"),". These can be used to build, clean, flash, and debug the project. Alternatively, the CMake VS Code extension or a command line can be used to configure and build the project using CMake directly."))}f.isMDXComponent=!0}}]);