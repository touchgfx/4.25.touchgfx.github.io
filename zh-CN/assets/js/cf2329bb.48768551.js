"use strict";(self.webpackChunktouchgfx_documentation=self.webpackChunktouchgfx_documentation||[]).push([[22994],{49613:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>u});var n=a(59496);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=n.createContext({}),p=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},c=function(e){var t=p(e.components);return n.createElement(s.Provider,{value:t},e.children)},h="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),h=p(a),d=r,u=h["".concat(s,".").concat(d)]||h[d]||m[d]||i;return a?n.createElement(u,o(o({ref:t},c),{},{components:a})):n.createElement(u,o({ref:t},c))}));function u(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,o=new Array(i);o[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[h]="string"==typeof e?e:r,o[1]=l;for(var p=2;p<i;p++)o[p]=a[p];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},93822:(e,t,a)=>{a.d(t,{Z:()=>l});var n=a(59496),r=a(96151);const i=n.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 16 16"},n.createElement("path",{fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"}));class o extends n.Component{render(){return n.createElement(r.Z,{color:"var(--highlight-color-caution)",header:"Caution",type:"caution",icon:i},this.props.children)}}const l=o},89639:(e,t,a)=>{a.d(t,{Z:()=>i});var n=a(59496),r=a(7029);const i=function(e){const t=e.noShadow||!1,a=e.width,i=e.height,o=(0,r.Z)(e.imageSource);return t?n.createElement("div",{className:"figure noshadow"},n.createElement("a",{href:o,target:"_blank"},n.createElement("img",{width:a,height:i,src:o})),n.createElement("p",null,e.children)):n.createElement("div",{className:"figure"},n.createElement("a",{href:o,target:"_blank"},n.createElement("img",{width:a,height:i,src:o})),n.createElement("p",null,e.children))}},48753:(e,t,a)=>{a.d(t,{Z:()=>l});var n=a(59496),r=a(96151);const i=n.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},n.createElement("path",{fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}));class o extends n.Component{render(){return n.createElement(r.Z,{color:"var(--highlight-color-further-reading)",header:"Further reading",type:"further-reading",icon:i},this.props.children)}}const l=o},96151:(e,t,a)=>{a.d(t,{Z:()=>i});var n=a(59496);class r extends n.Component{render(){const e=`highlight highlight-${this.props.type}`;return n.createElement("div",{className:e},n.createElement("div",{className:"highlight-heading"},n.createElement("h5",null,n.createElement("div",{className:"highlight-icon"},this.props.icon),this.props.header)),n.createElement("div",{className:"highlight-content"},this.props.children))}}const i=r},25540:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>m,contentTitle:()=>c,default:()=>b,frontMatter:()=>p,metadata:()=>h,toc:()=>d});a(59496);var n=a(49613),r=a(89639),i=a(48753),o=a(93822);function l(){return l=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var a=arguments[t];for(var n in a)Object.prototype.hasOwnProperty.call(a,n)&&(e[n]=a[n])}return e},l.apply(this,arguments)}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}const p={id:"running-graphics-from-external-ram",title:"Running graphics from external RAM"},c=void 0,h={unversionedId:"development/scenarios/running-graphics-from-external-ram",id:"development/scenarios/running-graphics-from-external-ram",title:"Running graphics from external RAM",description:"This section describes how to calculate the graphics performance of a typical setup illustrated below. The example is a high resolution 24bit RGB-TFT display at 1024x600 pixels with 16bpp framebuffers stored in external 32bit SDRAM. The graphical assets are stored in an external OSPI NOR flash.",source:"@site/i18n/zh-CN/docusaurus-plugin-content-docs/current/development/scenarios/running-graphics-from-external-ram.mdx",sourceDirName:"development/scenarios",slug:"/development/scenarios/running-graphics-from-external-ram",permalink:"/4.25/zh-CN/docs/development/scenarios/running-graphics-from-external-ram",draft:!1,tags:[],version:"current",frontMatter:{id:"running-graphics-from-external-ram",title:"Running graphics from external RAM"},sidebar:"docs",previous:{title:"Running graphics on STM32H7R7 & S7",permalink:"/4.25/zh-CN/docs/development/scenarios/running-graphics-on-stm32h7r"},next:{title:"\u901a\u8fc7\u90e8\u5206\u5e27\u7f13\u51b2\u964d\u4f4e\u5185\u5b58\u4f7f\u7528\u7387",permalink:"/4.25/zh-CN/docs/development/scenarios/lowering-memory-usage-with-partial-framebuffer"}},m={},d=[{value:"Step 1: Display specifications",id:"step-1-display-specifications",level:2},{value:"Step 2: Display requirements and pixel clock calculations",id:"step-2-display-requirements-and-pixel-clock-calculations",level:2},{value:"Step 3: Framebuffer and memory strategy",id:"step-3-framebuffer-and-memory-strategy",level:2},{value:"Step 4: Framebuffer performance",id:"step-4-framebuffer-performance",level:2},{value:"Step 5: Calculating remaining bandwidth after a display update",id:"step-5-calculating-remaining-bandwidth-after-a-display-update",level:2},{value:"Step 6: UI Rendering performance (GUI FPS)",id:"step-6-ui-rendering-performance-gui-fps",level:2},{value:"Note",id:"note",level:2},{value:"Glossary",id:"glossary",level:2}],u={toc:d},f="wrapper";function b(e){var{components:t}=e,a=s(e,["components"]);return(0,n.kt)(f,l({},u,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("p",null,"This section describes how to calculate the graphics performance of a typical setup illustrated below. The example is a high resolution 24bit RGB-TFT display at 1024x600 pixels with 16bpp framebuffers stored in external 32bit SDRAM. The graphical assets are stored in an external OSPI NOR flash."),(0,n.kt)(r.Z,{imageSource:"/img/development/scenarios/running-graphics-from-external-ram/example-setup.png",mdxType:"Figure"},"Illustration of the setup used in the example"),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"Objective")),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},"Provide a step-by-step overview for developers to better understand and estimate their system performance for a graphical user interface application."),(0,n.kt)("li",{parentName:"ol"},"Check if the selected display and its requirements can be sustained by the defined specified system."),(0,n.kt)("li",{parentName:"ol"},"Understand how complex a GUI it would be possible to develop within the subsystem defined.")),(0,n.kt)("h2",l({},{id:"step-1-display-specifications"}),"Step 1: Display specifications"),(0,n.kt)("p",null,"The display used on the STM32H7S78 Discovery Kit is the MB1860. Link to BoM for the Discovery Kit can be found ",(0,n.kt)("a",l({parentName:"p"},{href:"https://www.st.com/en/evaluation-tools/stm32h7s78-dk.html#cad-resources"}),"here"),". The display on the Discovery Kit has a resolution of 800px x 480px, which is lower than the resolution used in this example. The display specifications for the example can be seen below:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Display height: 600px"),(0,n.kt)("li",{parentName:"ul"},"Display width: 1024px"),(0,n.kt)("li",{parentName:"ul"},"Display refresh rate: 60Hz"),(0,n.kt)("li",{parentName:"ul"},"Display blanking area","*",": Typically ~10%")),(0,n.kt)("p",null,(0,n.kt)("em",{parentName:"p"},"*","Display blanking covers the sum of inactive pixels. The main contribution is the porches for the LTDC.")),(0,n.kt)("h2",l({},{id:"step-2-display-requirements-and-pixel-clock-calculations"}),"Step 2: Display requirements and pixel clock calculations"),(0,n.kt)("p",null,"At this step we need to calculate the display requirements, to understand if our MCU and memory selection can operate the display under the needed specifications."),(0,n.kt)("p",null,"From the display size specified above, we know that the total number of pixels is:"),(0,n.kt)("p",null,"pixel height x pixel width = 600px x 1024px = 614.400px"),(0,n.kt)("p",null,"The display has a refresh rate of (1000ms / 60 = 16ms) 60Hz, so the LTDC needs to fetch the framebuffer and send it to the display approximately every 16ms. The system (RAM) bandwidth required to keep the display updated at 60Hz (average, without blanking) can then be found with the following formula:"),(0,n.kt)("p",null,"display pixels x update frequency x framebuffer color depth (RGB565)"),(0,n.kt)("p",null,"614.400px x 60Hz x 16bpp = 589.824.000bits/sec = 589,82Mbit/sec"),(0,n.kt)("p",null,"The pixel clock required to update the display at 60Hz can be found with the calculation below."),(0,n.kt)("p",null,"(total number of pixels x refresh rate x (blanking% / 100 + 1)) / 1.000.000."),(0,n.kt)("p",null,"(614.400px x 60Hz x (10 / 100 + 1)) / 1.000.000 = 40,55 MHz pixel clock"),(0,n.kt)(o.Z,{mdxType:"Caution"},(0,n.kt)("p",null,"It is important not to exceed the maximum pixel clock supported by the LTDC.\nCheck the ",(0,n.kt)("a",l({parentName:"p"},{href:"https://www.st.com/resource/en/application_note/an4861-lcdtft-display-controller-ltdc-on-stm32-mcus-stmicroelectronics.pdf"}),"LTDC application note, AN4861,")," for an overview of the maximum supported pixel clock in different configurations. An overview of maximum pixel clock for STM32H7R/S can be found in table 13.")),(0,n.kt)("p",null,"An overview of the maximum supported pixel clock for STM32H7R/S can be found in table 13 of the ",(0,n.kt)("a",l({parentName:"p"},{href:"https://www.st.com/resource/en/application_note/an4861-lcdtft-display-controller-ltdc-on-stm32-mcus-stmicroelectronics.pdf"}),"LTDC application note"),", which is inserted below."),(0,n.kt)(r.Z,{imageSource:"/img/development/scenarios/running-graphics-from-external-ram/max-pixel-clock-table.png",mdxType:"Figure"},"STM32H7R3/7S3 and STM32H7R7/7S7 maximal supported pixel clock"),(0,n.kt)("h2",l({},{id:"step-3-framebuffer-and-memory-strategy"}),"Step 3: Framebuffer and memory strategy"),(0,n.kt)("p",null,"In this example, we use an external 32-bit SDRAM connected to a 32-bit wide FMC interface running at 100MHz, employing a double framebuffer strategy. Alternatively, developers can use 16bit SDRAM, 4/8/16 bit Serial RAMs like Hyper RAM and Serial PSRAM at 200MHz DTR also."),(0,n.kt)("p",null,"For all external memories some extra cycles are needed to start the operations, and for this example we take the assumption that the SDRAM is working at ~80% efficiency."),(0,n.kt)("h2",l({},{id:"step-4-framebuffer-performance"}),"Step 4: Framebuffer performance"),(0,n.kt)("p",null,"The theoretical RAM throughput is given by the following equation, when front and back buffer is placed at different RAM banks:"),(0,n.kt)("p",null,"interface width x interface frequency = Mbit/sec"),(0,n.kt)("p",null,"32bit x 100MHz  = 3.200Mbit/sec = 400MB/Sec"),(0,n.kt)("p",null,"However, this throughput is based on the RAM being 100% efficient. If we consider the estimated efficiency from step 3, the actual throughput is:"),(0,n.kt)("p",null,"3.200Mbit/sec x 0.8 = 2.560Mbit/sec = 320Mbytes/sec"),(0,n.kt)("h2",l({},{id:"step-5-calculating-remaining-bandwidth-after-a-display-update"}),"Step 5: Calculating remaining bandwidth after a display update"),(0,n.kt)("p",null,"Earlier we saw that the display required 589,82Mbit/sec, and that our external RAM has a throughput of 2.560Mbit/sec. Now let us check how much is left for the screen rendering/animations."),(0,n.kt)("p",null,"2.560Mbit/sec \u2013 589,82Mbit/sec = 1.970,18Mbit/sec = 246,27MBytes/sec"),(0,n.kt)("p",null,"Overall, the example system can keep the display updated and on top of this there is also ~1.970Mbit/sec remaining bandwidth for extra animations and more UI layers."),(0,n.kt)("h2",l({},{id:"step-6-ui-rendering-performance-gui-fps"}),"Step 6: UI Rendering performance (GUI FPS)"),(0,n.kt)("p",null,"In this UI case, we are targeting 60FPS GUI rendering. This means the system must render and transfer a new frame within 16ms. Additionally, we can accept a drop to 30FPS for some advanced UI animations, ensuring a fluid user experience throughout."),(0,n.kt)("p",null,"Let\u2019s calculate the framebuffer performance per framebuffer slice, meaning how many Mbit can we render inside each frame (per 16ms). First, we use the remaining framebuffer bandwidth (1.970Mbit/sec) and divide by 60FPS."),(0,n.kt)("p",null,"1.970Mbit/sec / 60FPS = 32,8Mbit per frame (approximately every 16ms at 60FPS)."),(0,n.kt)("p",null,"This means that the RAM throughput is 32,8Mbit per 16ms to render and update the UI."),(0,n.kt)("p",null,"Step 2 in the setup illustration in the beginning shows a possible extra rendering for altering/updating the UI. Since the framebuffers are 16bpp, all operations on the framebuffers are done in 16bpp. Writing a pixel in the framebuffer will hence acquire 16bits of the SDRAM bandwidth. If a pixel needs to be blended, the pixel will first be read from the framebuffer by NeoChrom GPU. After the pixel is blended (modified), it will be written back to the framebuffer. This means that the system needs to transfer 16bits twice for a read-modify-write operation resulting in a use of 16bit + 16bit = 32bit of the SDRAM bandwidth as illustrated in the image below."),(0,n.kt)(r.Z,{imageSource:"/img/development/scenarios/running-graphics-from-external-ram/read-modify-write.png",mdxType:"Figure"},"Illustration of a read-modify-write operation on the framebuffer"),(0,n.kt)("p",null,"We can now calculate how many pixels we can perform one operation on within each frame:"),(0,n.kt)("p",null,"32,8Mbit/frame / 16bpp = 2,05Mpixels"),(0,n.kt)("p",null,"To give a reference point, we calculate how many full screen operations it is possible to do within each frame:"),(0,n.kt)("p",null,"2,05Mpixels / 614.000px = 3,34 times"),(0,n.kt)("p",null,"This means that we can for example draw a full-screen box and then blend it with another box (16bpp write + 16bpp read + 16bpp write). This could further be blended with a third box covering 34% / 2 = 17% of the screen."),(0,n.kt)("p",null,"As mentioned at the beginning of step 6, we can accept a drop to 30FPS for some advanced UI animations. This means that we have twice the available bandwidth compared to 60FPS, resulting in the following number of full-screen operations possible within each frame:"),(0,n.kt)("p",null,"3,34 x 2 = 6,68 times"),(0,n.kt)("p",null,"It cannot be said unequivocally how many full-screen operations it should be possible to do within each frame, as it heavily depends on the complexity of the UI. Furthermore, it is important to consider if the external RAM is required for anything else than framebuffers. However, a reasonable guideline for many applications is that it should be at least above 3 times."),(0,n.kt)("p",null,"To compare with a concrete example, the ",(0,n.kt)("a",l({parentName:"p"},{href:"https://www.youtube.com/watch?v=Ho_lXv0RQqo&t"}),"STM32H7S78-DK")," runs an 800x480 RGB TFT display, with 16bit framebuffers in external 16bit serial PSRAM at 200MHz DTR (800MB/S theoretically if 100% efficient). This type of memory protocol uses more cycles initially resulting in a lower memory initialization efficiency compared to SDRAM (See ",(0,n.kt)("a",l({parentName:"p"},{href:"https://www.st.com/resource/en/application_note/an6062-introduction-to-stm32h7rx7sx-system-architecture-and-performance-stmicroelectronics.pdf"}),"AN6062")," for more details on serial RAM performance). The above example and calculations show that, at this resolution, even most complex UIs can be rendered while maintaining 60 FPS."),(0,n.kt)("p",null,"Another reference is the ",(0,n.kt)("a",l({parentName:"p"},{href:"https://www.youtube.com/watch?v=qYx2ngj6yhs&t"}),"TouchGFX Demo")," showing a complex UI with 2 different RAM and Flash memory frequencies."),(0,n.kt)(i.Z,{mdxType:"FurtherReading"},(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",l({parentName:"li"},{href:"https://www.st.com/resource/en/application_note/an6062-introduction-to-stm32h7rx7sx-system-architecture-and-performance-stmicroelectronics.pdf"}),"AN6062: Introduction to STM32H7Rx/7Sx system architecture and performance")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",l({parentName:"li"},{href:"https://www.st.com/resource/en/application_note/an4861-lcdtft-display-controller-ltdc-on-stm32-mcus-stmicroelectronics.pdf"}),"AN4861: Introduction to LCD-TFT display controller (LTDC) on STM32 MCUs")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",l({parentName:"li"},{href:"https://www.youtube.com/watch?v=Ho_lXv0RQqo&t"}),"Video of STM32H7S78-DK")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",l({parentName:"li"},{href:"https://www.youtube.com/watch?v=qYx2ngj6yhs&t"}),"Video of TouchGFX Demo with modifiable RAM and flash frequencies")))),(0,n.kt)("h2",l({},{id:"note"}),"Note"),(0,n.kt)("p",null,"It is important to note that the calculations above do not consider the available computing power; they solely focus on the RAM bandwidth. Additionally, the calculations are based on assumptions regarding the RAM efficiency. While these assumptions are not arbitrary, they remain assumptions, nonetheless."),(0,n.kt)("p",null,"Despite these limitations, the procedure in the example can still serve as an indication of possible performance."),(0,n.kt)("h2",l({},{id:"glossary"}),"Glossary"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("em",{parentName:"li"},"Read-modify-write:")," A process where a memory location is read, modified, and then written back."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("em",{parentName:"li"},"Pixel clock:")," The frequency at which pixels are transmitted to the display, determining the refresh rate and resolution of the screen. It defines the speed at which the display controller sends pixel data to the display panel."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("em",{parentName:"li"},"Framebuffer:")," An area in RAM containing a bitmap that drives the display. The framebuffer stores pixel values, which are read by the display controller. The rendering operations are performed to the framebuffer."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("em",{parentName:"li"},"Blanking:")," Display blanking covers the sum of inactive pixels. The main contribution is the porches for the LTDC."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("em",{parentName:"li"},"FMC:")," Flexible Memory Controller. A hardware component that manages the interface between the CPU and various types of memory, such as SRAM, NOR, NAND, and SDRAM. In this example it is used for the external SDRAM."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("em",{parentName:"li"},"XSPI:")," Extended-SPI interface. An advanced version of SPI that supports higher data rates and additional features for enhanced communication with peripheral devices. In this example it is used for the external NOR flash. For more information visit the ",(0,n.kt)("a",l({parentName:"li"},{href:"https://wiki.st.com/stm32mcu/wiki/Introduction_to_external_serial_memories_XSPI_interoperability_for_STM32"}),"wiki"),"."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("em",{parentName:"li"},"Memory protocol overhead:")," The extra time and resources required to manage communication and data transfer between memory and the processor, including tasks like error checking, handshaking, and addressing. This overhead impacts the overall system performance."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("em",{parentName:"li"},"DTR:")," Double Transfer Rate. Data is transferred on both rising and falling clock edges. The bandwith is hence doubled.")))}b.isMDXComponent=!0}}]);